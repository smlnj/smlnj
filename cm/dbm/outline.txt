cm/dbm/outline.txt

This is a combination of an "outline" of the CM files, and also random notes.

[See cm/Overview]

Outline of CM with notes on functionality, changes, etc.


================================================================================== 
Goals of CM revamping project
==================================================================================
 
Overall goals:

 * determine and document the "architecture" and "semantics" of CM 
 * exploit the vastly increased computational resources available since 
     2000 to simplify algorithms and representations 
 * looking for _major_ design simplifications,
     e.g. dropping "groups" and using only Libraries

Design goals:

 * considering adding "names" for libraries (in place of naming
   by file paths of CDFs, or by the generated "stable id" of CDFs)
   [need for some form of additional "unique id" for libraries?]
 * dropping concurrency for the time being?
     Is concurrency an orthogonal concern that could be added back later? 

Implementation improvements/simplifications

 * dropping "privileges" (a minor simplification)
 * dethunkizing fields/compenents by default, while looking for
     instances of thunkification that actually still matter. 
 * determine the role of and need for skeletons (do they need to be cached?) 
 * rethinking pickling (possibly moving to ASDL-based pickles)
 * interaction with compiler (compile and bootstrap directories)
     CM/compiler interface needs to be refined, documented
     CM/REPL interactions, dependencies? (identify and/or eliminate)
       "autoload"?
     CM becoming a compiler "component"?
 * interaction with compiler syntax representations (ast and absyn)
     and with the compiler's SML parser(s) [planned revision of ast and absyn]


================================================================================== 
Top level CM Directories:
==================================================================================

paths/ 

  internal representation of file paths -- "abstract syntax of paths) (Path.path),
    - parsing file path strings (OS native formats, "standard" format?)
    - unparsing abstract paths to strings (file paths in standard? format)
    - path operations
    - "segmented paths" (in PIDMAP, ?), role, semantics, need for
        internal representation (e.g. in the path type)?
    - interaction with anchors and anchor environments (anchor expansion)
        iterative anchor expansion, cycle detection?

  files
    locations (path)
    file_ids (from FS)
    stable ids, and "interning" files

  anchor environments
    global and "local" or "dynamic"
    binding anchors, (local and global)
    lookup  (global, then local)
    expansion of anchors in anchored paths (dropped)

  pathconfig file processing (dbm/pathconfig.sml)
    mainly produces global anchor bindings

  SrcPathMap -> FileMap (files ordered by stable ids) (dbm/filemap.sml)
  SrcPathSet -> FileSet (files ordered by stable ids) (dbm/fileset.sml)


parse/

  parse and "interpret" CDFs


depend/

  determine and represent module dependencies 
  complications caused by open declarations in SML source? 

  graph.sml  -- GroupGraph, "group" dependence graphs  (type ggroup)
  ggraph.sml -- DependencyGraph -- dependence graphs
                (types snode, bnode, sbnode, impexp)

    BNODES for BinInfo.info  (binary files)
    SNODE for SmlInfo.info   (source files)
    ["PNODE" mentioned in the Overview file does not exist.]

    far nodes (farsbnode, farbnode) ["external" nodes in other groups/libraries]

    impexp -- ?

  "PortableGraph" is not defined. But it is referenced in to-portable.sml and
  from-portable.sml, which are both therefore incomplete and not used or useable.

  da-env.sml [structure DAEnv]
    The value type decl is extraneous (replace value with env in the declaration
    of datatype env.
    All we need is env. Thus probably drop the value type in DAEnv.
    Not sure whether DAEnv.value is ever used; it is equivalent to DAEnv.env.

  se2dae.sml
    cvtMemo does not need to take a thunk argument. Thus the function is probably
    misnamed.

    Dependence of DAEnv on BrowseStatEnv (compiler/ElabData/statenv/browse.sml)
    may introduce some interesting issues later. Ast for modules is a hack that
    needs to be redone, which will affect browse.sml, and may have consequences
    somewhere in CM, in particular in dependency analysis
    
  mklist.sml (MkList) -> mkbootlist.sml (MkBootList)
    support module for MkBootList (bootstrap/mkbootlist.sml). Those two files
    have been merged (depend/dbm/mllist.sml) and so there is only the structure
    MkBootList. Odd variant of foldl has been replaced by List.foldl. Some
    dethinkification (in graph.sml and ggraph.sml).

  reachable.sml
    ?

  build.sml
    - flattened arguments of build function


semant/

  (mainly?) semantic actions for the CDF parser
  driver for dependency analysis, compilation

  version.sml -- supports having multiple different versions of binfiles
    But do we ever use this?  (nextMajor is called just once, in semant/members.sml)
    Version seems to be designed to support multiple "versions" of binfiles
    coexisting. We almost certainly do not need (or want) this.
    There are already a number of places where SMLNJVersion.version is referred
    to, and this versioning should suffice.

    JHR says that there are other clients for the Version structure (compiler, tools?).
    Since Version seems to be quite generic, perhaps it belongs in compiler/Basics
    or compiler/Support (aka compiler/Admin).

  iinfo.sml
    Why is the statenv field a thunk?
    A field like this should only be thunkified if computing the actual static
    environment is optional, meaning that its construction may be avoided in some cases
    and its "forcing" or construction will have significant cost. If you have
    already computed a value, e.g. a static environment, there is no point in
    thunkifying it -- you have already paid the computational cost to compute the
    value.

    The problem is that it can be quite hard to determine, with several layers
    of complex code (e.g. stabilization, unpickleutil, etc.), whether or where the
    thunkified value is actually computed, and whether its computation can be avoided.

    A second issue is whether the forcing of a thunk may involve state that has
    changed "underneath" since the thunk itself was constructed. What kind of
    state changes might alter the outcome of forcing the thunk?  Dependence of a
    thunk on some underlying state that might change over time is again hard to
    analyze. And there is the design choice of whether to cope with such change
    by delaying computation until after any relevant state changes have occurred,
    or to detect changes that affect a computation "after the fact" and thus 
    "invalidate" computations (and their values) that have already been completed.

  sharing.sml
    Does this have something to do with prohibiting the "sharing" of groups by
    multiple libraries?

    sharing "declarations" in CDFs? (Check CM manual.) semantics?

    Sharing.request seems to be a "per source file" attribute (field in SmlInfo.info).
    same for Sharing.mode, which is a persinfo field.

  group-reg.sml
    keeping track of groups that exist in a FileMap.map (a "group environment" mapping
    them (the group CDF file) to the corresponding Source.source.
    (register = "bind", lookup = lookup).

    The "error" function uses groupreg mapping to provide CDF source (along with the region
    of a group member specification within the group CDF) for calls of ErrorMsg.error
    to identify the member specification where an error occurred.


smlfile/

  representation of (static) information about SML source files (module declarations)

  SmlInfo (smlinfo.sml)

  Q: Why is the guid (now getguid) field of persinfo a thunk, and when
  is it supposed to be forced to generate the actual guid?  The 


stable/

  combining compiled libraries (& their subgroups) into stable, amalgamated
  binary files

  BinInfo.info - info pertaining ot members of stabilized libraries
  BinInfo.info is to stabilized binary code (binfiles) as SmlInfo.info is to
    SML source code


compile/

  "traversals" (compile/generic.sml)
     recompilation
     execution (link)

  compilation type (compile/compile-type.sml)

  instantiations:
     compile/recomp.sml  -- recompilation traversal
     compile/exec.sml	 -- execution/link traversal

  persistant state
     recomp  (uses recomp state)
     full (extends (inherits from) recomp) used when executing as well as compiling


bootstrap/
   
  special case of compile, where source code is compiled to produce bin files
  but not executed. (execution will be performed under control of the runtime boot loader)

util/

  * drop SetFn (set-fn.sml) and MapFn (map-fn.sml); use RedBlackSetFn
    and RedBlackMapFn directly in their place instead.
    

tools/main/




================================================================================== 
General Comments/Proposals -- CM 3.0 design ideas
==================================================================================

* Privileges
  - these have never been "enforced", therefore expendable --
    privileges are not part of the necessary (i.e. existing) functionality of CM.
  - deleting all entities (record fields, functions, etc.) relating
    solely to privileges.

* Unification of "Groups" and "Libraries"
  - All groups become libraries.
  - Eliminates the problem of what groups belong to what libraries.
  - Does this cause the loss of any "name space management" features of groups?
  - Introduce group/library _names_ distinct from CDF file paths.
    Do group names supercede "anchors"?

* 1st class "Groups"
  - group/library representation datastructures (a GroupInfo structure
    analagous to SmlInfo, perhaps)
    -- group _name_ : a string or symbol, distinct from the file path
       of a group CDF 
    -- exports (module symbols)
    -- members (sml source files)
    -- imports (group/libraries) dependencies
  - group dependency graph, distinct from source file dependency graph
  - specify group imports using group names, rather than (anchored) file paths
  - group name -> file path environment
    file paths should be purely "semantic" things, not used in group/library definitions
  - anchors become bound group variables
  - conditional compilation as "group/library expressions"

* files (classification, contents)
  - bin files (compiled code + interface SE (pickle))
  - source files (text files)
    -- SML source files (members of groups)
    -- CDF files (group/library definitions)
    -- CM .cmi files ("CM scripts"?)
    -- configuration files: pathconfig, depends, ... (system/*)
    -- skel and guid files (maybe eliminate skel?)
       (CM data caching)
  - format of config files (JSON?, SEXP?)
  - an SML source file should appear at most once as a member of a group/library
  - a group/library can be imported by multiple group/libraries

* anchor binding and environments
  - need for the "bind" keyword notation in CDFs (should be a form of "let")
    (complile-time "dynamic" binding of anchors)
  - could anchors become some form of CM "group/library" variable?
  - relation with concrete file paths should be secondary
  
    
================================================================================== 
Ast-based dependency analysis
==================================================================================

* Relevant source files:

  dbm/depend/
    graph.sml
    ggraph.sml
    da-env.sml  
    se2dae.sml
    build.sml

  dbm/smlfile
    skeleton.sml
    convert.sml (skel-cvt.sml)
    skel-exports.sml

* terminology

  Defn:
    _module_ symbols are symbols in the structure, functor, signature, and
      functor signature name spaces, or equivalently a symbol that is bound to
      a structure, functor, etc.
    _strfct_ symbols are the subset of structure and functor symbols

    a _short_ path consists of a single module symbol
    a _long_ path is a path of length > 1, and it must start with a
      structure symbol (only structures can be projected from)
    a single symbol "path" that is not a module symbol is _trivial_
      and represents a core language element (variable, tycon, exncon, etc.)
    a _path head_ is the first symbol of a short or long path; for a long path
      the path head is always a structure symbol

    [We don't track trivial paths -- they can be neither exports nor imports,
     nor can they "mask" exports and imports.]

    A _structure path_ is a short or long path whose last symbol is a structure
    symbol. I.e. a path that names a structure.

    A _functor path_ is a path whose last symbol is a functor symbol.

    A c-unit is a "compilation unit", normally an SML source file (member of
    a group).

    An occurrence of a symbol is _covered_ by an open declaration if
       (1) the occurrence is within the scope of the open declaration, and
       (2) the symbol is not the name of any 1st-order component of the
           structure designated by the path.

* structures vs functors

  -- structure symbols/paths can be selected from
     - A structure symbol can occur as the head of a long path; a structure path
       can be extended with further projections.
  -- structure paths can be "opened" (occur in open declarations)
  -- functor symbols cannot be the head of a long path (cannot be selected from)
  -- functor symbols/paths cannot be "opened"
  -- functor symbols can designate the functor in a functor application, and can
     occur as the definiens (rhs fctexp) in a functor declaration. (and in rhs of
     where clauses? No!)

* structures: what do we need to know (about a structure declaration)

  -- name (a structure symbol)
  -- 1st order (direct) module components (both structures and functors, or just
     functors?)
  -- context
     (a) (local) module names that are in scope
     (b) opened paths in scope -- their component structures can be added to (a)
         - opened paths can be local or "free". If local we can already know their
	   substructure names. If "free", we have to wait until a 2nd pass to determine
	   their substructures.
         - If the head of an opened path is "local" (defined _previously_ in the current
	   structure expression StrBase), we know its substructure tree, and thus what
	   module symbols the open decl binds.
  -- "free" module names occurring within component declarations -- potential imports
     - but if in the scope of any opens of "free" structure paths, freeness of the module
       names will have to be determined later, when we can learn the component symbols of
       the "free" path that was opened.

* Two path algorithm to determine "imported" symbols

  (1) construct component tree decorated with "potential" imports, qualified by the
      opened paths that are in scope for each components. Exports are just the top-level
      declared module symbols.

  (2) analysis of opens across source files (compilation units) to determine which "free"
      module symbols are actual imports.
       
Principle: imports cannot affect exports in a structure/functor declaration.
  Thus we can calculate the exports of a c-unit before we know its true imports.
  [Because only the top name of a module declaration is exported. Because no
   top-level opens are allowed in a c-unit.]

Observation:
For each "potential" import (overtly free symbol occurrence), it can be
disqualified as an import by any "open path" in whose scope that occurrence lies.
[A given "free" symbol may have multiple "free" occurrences. And these occurrences
may be governed by different sets of open declarations. So occurrences are qualified
by sets of "in-scope" or "visible" open declarations.] A free symbol is an import
if _some_ occurrence of that symbol is not "covered" by an open declaration.

====================================================================================== 
Interface functions
======================================================================================

<structure tree>

<structure symbol> -> <structure tree>   (~~ structure tree environment)

<structure tree> * <path> -> <structure tree> option

<opened paths> * <symbol set>  -- potentially imported symbols

<opened paths> : path list  (scope relative)

<structure tree> * <structure tree env> -> <symbol set> (imports)
                   (locally bound substrs)

Each node of a structure tree has an associated set of potential import symbols
(free symbols). These potential import symbols may be covered by an in-scope open.

For a locally bound path, we may be able to determine its substructure set and
use that to immediately "resolve" an open of that path, translating the open into
additional locally bound structure names, which may bind structure symbol occurrences
so that they are not added to the "free" set.

====================================================================================== 
Determining components of opened paths
======================================================================================

Example 1.

structure A =
struct
  structure AA = struct ... end
  structure AB = struct ... end
end

structure B =
struct
  open A
end

structure C =
struct
  local
    open B
  in
    val x = AB.y
  end
end

Is "AB" an import of the C-declaration?
Is "AB" a component of B?
Is "AB" a compoent of A?

Is "AB" an import of C? =>
Is "AB" a substructure of B? ("AB" "covered" by open B) =>
Is "AB" a substructure of A? => yes

The components (substructures) of B are determined by the substructures of A, which
is an import of B.

So we have to chain back through structures until we can resolve any open decls and
get a definite set of substructures. This process must terminate unless there is a
dependency cycle, which needs to be detected (by recording which structures (symbols)
have been examined.

Example 2.

Core declarations in core expressions/declarations.
Consider the following schematic let expression (LetExp).

let
  <decs1>
  open <paths1>
  <decs2>
  open <paths2>
  <decs3>
in
  <body>
end

Assumptions:

(1) <decs1>, <decs2>, and <decs3> produce no module bindings (only core bindings,
    values, exception contructores and (maybe) types).

(2) str bindings introduced by the open decs can introduce structure bindings and
    these structure bindings can "cover" path heads of "free" paths in the following
    core declarations and in the body exp.

We are _segmenting_ the let declaractions, where segments of core decs are separated
by open decs.

Nested scoping of the let declarations

--------------------------------------------------------------------------------------
                            |  bnd-ph      |   free-ph  |  "imports"
  |-----------------------------------------------------------------------------------
1 | decs1                   |    {}        |    fphs1   |  fphs1/context
  |   |-------------------------------------------------------------------------------
2 |   |open paths1          | U cmp$paths1 |  hd$paths1 |  bnd-ph(2)/context
  |   |-------------------------------------------------------------------------------
3 |   |   |decs2            |    {}        |    fphs2   |  fphs2/context/paths1  
  |   |   |   |----------------------------------------------------------------------
4 |   |   |   |open paths2  | U cmp$paths2 |  hd$paths2 |  bnd_ph(4)/context/paths1
  |   |   |   |   |-------------------------------------------------------------------
5 |   |   |   |   |decs3    |    {}        |    fphs3   |  fphs3/context/paths1/paths2
  |   |   |   |   |   |---------------------------------------------------------------
6 |   |   |   |   |   |body |    {}        |    fphsb   |  fphsb/context/paths1/paths2  
--------------------------------------------------------------------------------------
6 letexp                    |    {}        |    fphsb   |  U {imports(i), i = 1..6}

where cmp$paths1 = map cmp paths1, and cmp str = set of substructures of str
where U = union operator on sets of sets of (str) symbols
where context is the set of opened path sets in scope at this let exp.

====================================================================================== 
Elaboration of module declarations
======================================================================================

Environment of elaboration:

  binding module names to their representations

Required:

  * mapping from structure symbols to a structure representation that include
    the substructure heirarchy.

  * opened path context (path set list)

Notes:
* In a module-level declaration sequence, a structure declaration may shadow a
  structure binding introduced by an open declaration, and vice versa.

  (* structure binding shadowed by a following open *) 
  structure A = <strexp>
  open p   (* where p is bound to a structure with an A substructure *)
  (* A is not an import, though hd p may be *)

  (* binding from open shadowed by a following structure dec *) 
  open p   (* where p is bound to a structure with an A substructure *)
  structure A = <strexp>
  (* A is local, not an import *)


1. structure declarations (StrDec strbs).

2. functor declarations

3. signature declarations

4. functor signature declarations
