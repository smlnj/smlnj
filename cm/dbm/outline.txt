cm/dbm/outline.txt

This is a combination of an "outline" of the CM files, and also random notes.

[See cm/Overview]

Outline of CM with notes on functionality, changes, etc.


================================================================================== 
Goals of CM revamping project
==================================================================================
 
Overall goals:

 * determine and document the "architecture" and "semantics" of CM 
 * exploit the vastly increased computational resources available since 
     2000 to simplify algorithms and representations 
 * looking for _major_ design simplifications,
     e.g. dropping "groups" and using only Libraries

Design goals:

 * considering adding "names" for libraries (in place of naming
   by file paths of CDFs, or by the generated "stable id" of CDFs)
   [need for some form of additional "unique id" for libraries?]
 * dropping concurrency for the time being?
     Is concurrency an orthogonal concern that could be added back later? 

Implementation improvements/simplifications

 * dropping "privileges" (a minor simplification)
 * dethunkizing fields/compenents by default, while looking for
     instances of thunkification that actually still matter. 
 * determine the role of and need for skeletons (do they need to be cached?) 
 * rethinking pickling (possibly moving to ASDL-based pickles)
 * interaction with compiler (compile and bootstrap directories)
     CM/compiler interface needs to be refined, documented
     CM/REPL interactions, dependencies? (identify and/or eliminate)
       "autoload"?
     CM becoming a compiler "component"?
 * interaction with compiler syntax representations (ast and absyn)
     and with the compiler's SML parser(s) [planned revision of ast and absyn]


================================================================================== 
Top level CM Directories:
==================================================================================

paths/ 

  internal representation of file paths -- "abstract syntax of paths) (Path.path),
    - parsing file path strings (OS native formats, "standard" format?)
    - unparsing abstract paths to strings (file paths in standard? format)
    - path operations
    - "segmented paths" (in PIDMAP, ?), role, semantics, need for
        internal representation (e.g. in the path type)?
    - interaction with anchors and anchor environments (anchor expansion)
        iterative anchor expansion, cycle detection?

  files
    locations (path)
    file_ids (from FS)
    stable ids, and "interning" files

  anchor environments
    global and "local" or "dynamic"
    binding anchors, (local and global)
    lookup  (global, then local)
    expansion of anchors in anchored paths (dropped)

  pathconfig file processing (dbm/pathconfig.sml)
    mainly produces global anchor bindings

  SrcPathMap -> FileMap (files ordered by stable ids) (dbm/filemap.sml)
  SrcPathSet -> FileSet (files ordered by stable ids) (dbm/fileset.sml)


parse/

  parse and "interpret" CDFs


depend/

  determine and represent module dependencies 
  complications caused by open declarations in SML source? 

  graph.sml  -- GroupGraph, "group" dependence graphs  (type ggroup)
  ggraph.sml -- DependencyGraph -- dependence graphs
                (types snode, bnode, sbnode, impexp)

    BNODES for BinInfo.info  (binary files)
    SNODE for SmlInfo.info   (source files)
    ["PNODE" mentioned in the Overview file does not exist.]

    far nodes (farsbnode, farbnode) ["external" nodes in other groups/libraries]

    impexp -- ?

  "PortableGraph" is not defined. But it is referenced in to-portable.sml and
  from-portable.sml, which are both therefore incomplete and not used or useable.

  da-env.sml [structure DAEnv]
    The value type decl is extraneous (replace value with env in the declaration
    of datatype env.
    All we need is env. Thus probably drop the value type in DAEnv.
    Not sure whether DAEnv.value is ever used; it is equivalent to DAEnv.env.

  se2dae.sml
    cvtMemo does not need to take a thunk argument. Thus the function is probably
    misnamed.

    Dependence of DAEnv on BrowseStatEnv (compiler/ElabData/statenv/browse.sml)
    may introduce some interesting issues later. Ast for modules is a hack that
    needs to be redone, which will affect browse.sml, and may have consequences
    somewhere in CM, in particular in dependency analysis
    
  mklist.sml (MkList) -> mkbootlist.sml (MkBootList)
    support module for MkBootList (bootstrap/mkbootlist.sml). Those two files
    have been merged (depend/dbm/mllist.sml) and so there is only the structure
    MkBootList. Odd variant of foldl has been replaced by List.foldl. Some
    dethinkification (in graph.sml and ggraph.sml).

  reachable.sml
    ?

  build.sml
    - flattened arguments of build function


semant/

  (mainly?) semantic actions for the CDF parser
  driver for dependency analysis, compilation

  version.sml -- supports having multiple different versions of binfiles
    But do we ever use this?  (nextMajor is called just once, in semant/members.sml)
    Version seems to be designed to support multiple "versions" of binfiles
    coexisting. We almost certainly do not need (or want) this.
    There are already a number of places where SMLNJVersion.version is referred
    to, and this versioning should suffice.

  iinfo.sml
    Why is the statenv field a thunk?
    A field like this should only be thunkified if computing the actual static
    environment is optional, meaning that its construction may be avoided in some cases
    and its "forcing" or construction will have significant cost. If you have
    already computed a value, e.g. a static environment, there is no point in
    thunkifying it -- you have already paid the computational cost to compute the
    value.

    The problem is that it can be quite hard to determine, with several layers
    of complex code (e.g. stabilization, unpickleutil, etc.), whether or where the
    thunkified value is actually computed, and whether its computation can be avoided.

    A second issue is whether the forcing of a thunk may involve state that has
    changed "underneath" since the thunk itself was constructed. What kind of
    state changes might alter the outcome of forcing the thunk?  Dependence of a
    thunk on some underlying state that might change over time is again hard to
    analyze. And there is the design choice of whether to cope with such change
    by delaying computation until after any relevant state changes have occurred,
    or to detect changes that affect a computation "after the fact" and thus 
    "invalidate" computations (and their values) that have already been completed.


smlfile/

  representation of static information about SML source files (module declarations)

  SmlInfo (smlinfo.sml)


stable/

  combining compiled libraries (& their subgroups) into stable, amalgamated
  binary files

  BinInfo.info - info pertaining ot members of stabilized libraries
  BinInfo.info is to stabilized binary code (binfiles) as SmlInfo.info is to
    SML source code


compile/

  "traversals" (compile/generic.sml)
     recompilation
     execution (link)

  compilation type (compile/compile-type.sml)

  instantiations:
     compile/recomp.sml  -- recompilation traversal
     compile/exec.sml	 -- execution/link traversal

  persistant state
     recomp  (uses recomp state)
     full (extends (inherits from) recomp) used when executing as well as compiling


bootstrap/
   
  special case of compile, where source code is compiled to produce bin files
  but not executed. (execution will be performed under control of the runtime boot loader)

util/

  * drop SetFn (set-fn.sml) and MapFn (map-fn.sml); use RedBlackSetFn
    and RedBlackMapFn directly instead.
    

tools/main/

--------------------------------------------------------------------------------

Privileges
  these have never been "enforced", therefore expendable
  privileges are not part of the needed functionality of CM
