cm/dbm/outline.txt

This is a combination of an "outline" of the CM files, and also random notes.

[See cm/Overview]

Outline of CM with notes on functionality, changes, etc.


================================================================================== 
Goals of CM revamping project
==================================================================================
 
Overall goals:

 * determine and document the "architecture" and "semantics" of CM 
 * exploit the vastly increased computational resources available since 
     2000 to simplify algorithms and representations 
 * looking for _major_ design simplifications,
     e.g. dropping "groups" and using only Libraries

Design goals:

 * considering adding "names" for libraries (in place of naming
   by file paths of CDFs, or by the generated "stable id" of CDFs)
   [need for some form of additional "unique id" for libraries?]
 * dropping concurrency for the time being?
     Is concurrency an orthogonal concern that could be added back later? 

Implementation improvements/simplifications

 * dropping "privileges" (a minor simplification)
 * dethunkizing fields/compenents by default, while looking for
     instances of thunkification that actually still matter. 
 * determine the role of and need for skeletons (do they need to be cached?) 
 * rethinking pickling (possibly moving to ASDL-based pickles)
 * interaction with compiler (compile and bootstrap directories)
     CM/compiler interface needs to be refined, documented
     CM/REPL interactions, dependencies? (identify and/or eliminate)
       "autoload"?
     CM becoming a compiler "component"?
 * interaction with compiler syntax representations (ast and absyn)
     and with the compiler's SML parser(s) [planned revision of ast and absyn]


================================================================================== 
Top level CM Directories:
==================================================================================

paths/ 

  internal representation of file paths -- "abstract syntax of paths) (Path.path),
    - parsing file path strings (OS native formats, "standard" format?)
    - unparsing abstract paths to strings (file paths in standard? format)
    - path operations
    - "segmented paths" (in PIDMAP, ?), role, semantics, need for
        internal representation (e.g. in the path type)?
    - interaction with anchors and anchor environments (anchor expansion)
        iterative anchor expansion, cycle detection?

  files
    locations (path)
    file_ids (from FS)
    stable ids, and "interning" files

  anchor environments
    global and "local" or "dynamic"
    binding anchors, (local and global)
    lookup  (global, then local)
    expansion of anchors in anchored paths (dropped)

  pathconfig file processing (dbm/pathconfig.sml)
    mainly produces global anchor bindings

  SrcPathMap -> FileMap (files ordered by stable ids) (dbm/filemap.sml)
  SrcPathSet -> FileSet (files ordered by stable ids) (dbm/fileset.sml)


parse/

  parse and "interpret" CDFs


depend/

  determine and represent module dependencies 
  complications caused by open declarations in SML source? 

  graph.sml  -- GroupGraph, "group" dependence graphs  (type ggroup)
  ggraph.sml -- DependencyGraph -- dependence graphs
                (types snode, bnode, sbnode, impexp)

    BNODES for BinInfo.info  (binary files)
    SNODE for SmlInfo.info   (source files)
    ["PNODE" mentioned in the Overview file does not exist.]

    far nodes (farsbnode, farbnode) ["external" nodes in other groups/libraries]

    impexp -- ?

  "PortableGraph" is not defined. But it is referenced in to-portable.sml and
  from-portable.sml, which are both therefore incomplete and not used or useable.

  da-env.sml [structure DAEnv]
    The value type decl is extraneous (replace value with env in the declaration
    of datatype env.
    All we need is env. Thus probably drop the value type in DAEnv.
    Not sure whether DAEnv.value is ever used; it is equivalent to DAEnv.env.

  se2dae.sml
    cvtMemo does not need to take a thunk argument. Thus the function is probably
    misnamed.

    Dependence of DAEnv on BrowseStatEnv (compiler/ElabData/statenv/browse.sml)
    may introduce some interesting issues later. Ast for modules is a hack that
    needs to be redone, which will affect browse.sml, and may have consequences
    somewhere in CM, in particular in dependency analysis
    
  mklist.sml (MkList) -> mkbootlist.sml (MkBootList)
    support module for MkBootList (bootstrap/mkbootlist.sml). Those two files
    have been merged (depend/dbm/mllist.sml) and so there is only the structure
    MkBootList. Odd variant of foldl has been replaced by List.foldl. Some
    dethinkification (in graph.sml and ggraph.sml).

  reachable.sml
    ?

  build.sml
    - flattened arguments of build function


semant/

  (mainly?) semantic actions for the CDF parser
  driver for dependency analysis, compilation

  version.sml -- supports having multiple different versions of binfiles
    But do we ever use this?  (nextMajor is called just once, in semant/members.sml)
    Version seems to be designed to support multiple "versions" of binfiles
    coexisting. We almost certainly do not need (or want) this.
    There are already a number of places where SMLNJVersion.version is referred
    to, and this versioning should suffice.

    JHR says that there are other clients for the Version structure (compiler, tools?).
    Since Version seems to be quite generic, perhaps it belongs in compiler/Basics
    or compiler/Support (aka compiler/Admin).

  iinfo.sml
    Why is the statenv field a thunk?
    A field like this should only be thunkified if computing the actual static
    environment is optional, meaning that its construction may be avoided in some cases
    and its "forcing" or construction will have significant cost. If you have
    already computed a value, e.g. a static environment, there is no point in
    thunkifying it -- you have already paid the computational cost to compute the
    value.

    The problem is that it can be quite hard to determine, with several layers
    of complex code (e.g. stabilization, unpickleutil, etc.), whether or where the
    thunkified value is actually computed, and whether its computation can be avoided.

    A second issue is whether the forcing of a thunk may involve state that has
    changed "underneath" since the thunk itself was constructed. What kind of
    state changes might alter the outcome of forcing the thunk?  Dependence of a
    thunk on some underlying state that might change over time is again hard to
    analyze. And there is the design choice of whether to cope with such change
    by delaying computation until after any relevant state changes have occurred,
    or to detect changes that affect a computation "after the fact" and thus 
    "invalidate" computations (and their values) that have already been completed.

  sharing.sml
    Does this have something to do with prohibiting the "sharing" of groups by
    multiple libraries?

    sharing "declarations" in CDFs? (Check CM manual.) semantics?

    Sharing.request seems to be a "per source file" attribute (field in SmlInfo.info).
    same for Sharing.mode, which is a persinfo field.

  group-reg.sml
    keeping track of groups that exist in a FileMap.map (a "group environment" mapping
    them (the group CDF file) to the corresponding Source.source.
    (register = "bind", lookup = lookup).

    The "error" function uses groupreg mapping to provide CDF source (along with the region
    of a group member specification within the group CDF) for calls of ErrorMsg.error
    to identify the member specification where an error occurred.


smlfile/

  representation of (static) information about SML source files (module declarations)

  SmlInfo (smlinfo.sml)

  Q: Why is the guid (now getguid) field of persinfo a thunk, and when
  is it supposed to be forced to generate the actual guid?  The 


stable/

  combining compiled libraries (& their subgroups) into stable, amalgamated
  binary files

  BinInfo.info - info pertaining ot members of stabilized libraries
  BinInfo.info is to stabilized binary code (binfiles) as SmlInfo.info is to
    SML source code


compile/

  "traversals" (compile/generic.sml)
     recompilation
     execution (link)

  compilation type (compile/compile-type.sml)

  instantiations:
     compile/recomp.sml  -- recompilation traversal
     compile/exec.sml	 -- execution/link traversal

  persistant state
     recomp  (uses recomp state)
     full (extends (inherits from) recomp) used when executing as well as compiling


bootstrap/
   
  special case of compile, where source code is compiled to produce bin files
  but not executed. (execution will be performed under control of the runtime boot loader)

util/

  * drop SetFn (set-fn.sml) and MapFn (map-fn.sml); use RedBlackSetFn
    and RedBlackMapFn directly in their place instead.
    

tools/main/




================================================================================== 
General Comments/Proposals -- CM 3.0 design ideas
==================================================================================

* Privileges
  - these have never been "enforced", therefore expendable --
    privileges are not part of the necessary (i.e. existing) functionality of CM.
  - deleting all entities (record fields, functions, etc.) relating
    solely to privileges.

* Unification of "Groups" and "Libraries"
  - All groups become libraries.
  - Eliminates the problem of what groups belong to what libraries.
  - Does this cause the loss of any "name space management" features of groups?
  - Introduce group/library _names_ distinct from CDF file paths.
    Do group names supercede "anchors"?

* 1st class "Groups"
  - group/library representation datastructures (a GroupInfo structure
    analagous to SmlInfo, perhaps)
    -- group _name_ : a string or symbol, distinct from the file path
       of a group CDF 
    -- exports (module symbols)
    -- members (sml source files)
    -- imports (group/libraries) dependencies
  - group dependency graph, distinct from source file dependency graph
  - specify group imports using group names, rather than (anchored) file paths
  - group name -> file path environment
    file paths should be purely "semantic" things, not used in group/library definitions
  - anchors become bound group variables
  - conditional compilation as "group/library expressions"

* files (classification, contents)
  - bin files (compiled code + interface SE (pickle))
  - source files (text files)
    -- SML source files (members of groups)
    -- CDF files (group/library definitions)
    -- CM .cmi files ("CM scripts"?)
    -- configuration files: pathconfig, depends, ... (system/*)
    -- skel and guid files (maybe eliminate skel?)
       (CM data caching)
  - format of config files (JSON?, SEXP?)
  - an SML source file should appear at most once as a member of a group/library
  - a group/library can be imported by multiple group/libraries

* anchor binding and environments
  - need for the "bind" keyword notation in CDFs (should be a form of "let")
    (complile-time "dynamic" binding of anchors)
  - could anchors become some form of CM "group/library" variable?
  - relation with concrete file paths should be secondary
  
    
