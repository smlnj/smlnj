Scanning ast to define import/export symbol lists:
(for determining dependencies between source files)

* Dependency Analysis Problem:

The problem is to determine, based on a simple concrete parse of the source files (the Ast representation) whether one source file depends on another.

In the absence of the "open" declaration, this seems to be fairly straightforward. We need to determine which
module symbols are locally defined, which are "exported", and which represent implicit imports from other
files (or compilation units).  But in the presence of open declarations, things become much more complicated.

The current solution involves:

(1) the "Skeleton" representation (smlfile/dbm/skeleton.sml) with types decl and exp, and
(2) the translation from the Ast representation to skeleton representation (smlfile/dbm/interface.sml), and
(3) the use of the skeleton representation to determine dependency (where?).


Example: the impact of open

Hypothetical imported structure A:

---------------------
fileA.sml
---------------------
   structure A =
   struct
     structure AA = struct val x = 3 end
   end
---------------------
exports: S:A, S:A.AA
imports: nil

fileA.sml may be a member of the same group (as fileB.sml below), or it may be a member of an imported
group.


Structure/file being scanned:

---------------------
fileB.sml
---------------------
  structure B =
  struct
    open A           <- signalling the import of A (if this is the "first" open),
                        introducing AA as "local" (secondary import)
    val y = AA.x     (a path in an expression starting with AA)
    (* ... open AA ... *)  (alternatively, AA could be mentioned in an open declaration *)
  end
---------------------
exports: S:B
imports: S:A  [satisfied by fileA.sml]

[for an import like A, need to know what substructures it contained (AA, which becomes
"local" after A is opened). And we need to know what substructures AA contains, in case
it is opened, and so on.]

[A could be defined in, and exported from, an imported group of the group containing fileB.sml
as a member. So dependency may be with respect to either a local member of an export of an
imported group.]

"A" is an imported structure symbol for B (fileB.sml)

Is "AA" an imported symbol?  No!  (It could be called a "secondary" import.)

After opening A, we don't know whether a structure symbol AA is an independent import
or whether it was introduced into the environment by "open A".

How do we detect this while scanning B in isolation?

Do we need a signature for structure A?

What if we are scanning B before we scan A? And before dependency analysis
shows that fileA.sml needs to be compiled before fileB.sml.

What if we conservatively record AA as an imported structure. And assume that
AA will not appear in any member's export list.  Does the extra, spurious AA
in the import list of fileB.sml cause a problem?

But there might be a problem (such as a false cyclical dependency) if in fact
AA were exported by some other file, say fileC.sml. We might falsely conclude
that fileB.sml depends on fileC.sml (when, in fact, fileC.sml depends on fileB.sml).


---------------------------------------------------------------------------------------- 
Attempted (naive) solution: try 2-pass approach.

1. calculate module exports, assuming no top-level open in SML source members
2. calculate imports, knowing the ???

Requirements:

1. need to be able to calculate the dependency relation, possibly in
multiple passes, but independently of the initial order in which source files are
scanned for I/E information.

2. use only "concrete" syntax representation (ast)


----------------------------------------------------------------------------------------
Skeletons, a worked example (for the above example: fileA.sml, fileB.sml):

  structure A =
  struct
    structure AA = struct val x = 3 end
  end

1. val x = 3
   <dec_x> = ValDec [vb_x]
   <vb_x> = Vb {pat=VarPat ["x"], exp=IntExp "3", lazyp=_}   --  omitting lazy flag 
   pat_s (VarPat ["x"], ss_empty)
     = s_addMP (["x"], ss_empty)
     = ss_empty
   exp_dl (IntExp "3", nil) = nil
   vb_dl (<dec_x>, nil)
     = dl_addS (ss_empty, nil)
     = nil
   dec_dl (<dec_x>, nil)
     = foldl vd_dl nil [vb_x]
     = vd_dl (<vb_x>, nil)
     = nil

2. struct val x = 3 end  (: Ast.strexp)
   <strexp_AA> = 
     = BaseStr (SeqDec [<dec_x>])
   dec_dl (SeqDec [<dec_x>], nil)
     = foldr dec_dl nil [<dec_x>]
     = dec_dl (<dec_x>, nil)
     = nil
   strexp_p (<strexp_AA>)
     = (ss, Decl decls)
       where (ss, decls) = split_dl (nil) = (ss_empty, nil)
     = (ss_empty, Decl nil)

3. structure AA = struct val x = 3 end (: Ast.dec)
   <dec_AA> = StrDec [<strb_AA>]
   <strb_AA> = Strb {name = "AA", def = <strexp_AA>, constraint = NoSig}
       strexp_p <strexp_AA> = (ss_empty, Decl nil) [2]
       sigexpc_p NoSig = NONE
       pairOp (strexp_p def, sigexpc_p constraint)
       = strexp_p def
       = (ss_empty, Decl nil)
   (ss, binds) = foldl ss_binds (ss_empty, nil) [<strb_AA>] nil
     = (ss_empty, Decl nil)
   dec_dl (<dec_AA>, nil)
     = parbind ss_binds [<strb_AA>] nil  
     = dl_addS (ss_empty, parbindcons ([("AA", Decl nil)], nil)
     = parbindcons ([("AA", Decl nil)], nil)
     = [Bind ("AA", Decl nil)] : decls

Note that there is no Ref decl in the result. Thus <dec_AA> contains no free
(imported) module symbols.

The (locally) defined, or exported symbols consist of ["AA"].

4. struct structure AA = ... end  (<strexp_A>: Ast.strexp)
   <strexp_A> : Ast.strexp = BaseStr (SeqDec [<dec_AA>])
   <dec_AA> : Ast.dec = StrDec [strb_AA]  [3]
   strexp_p <strexp_A>
     = strexp_p (BaseStr (SeqDec [<dec_AA>]))
       decls_A =
         dec_dl (SeqDec [<dec_AA>], nil)
	 = foldr dec_dl nil [<dec_AA>]
	 = dec_dl (<dec_AA>, nil)
	 = [Par [Bind ("AA", Decl nil)]].
       (ss, decls) = split_dl decls_A = (ss_empty, decls_A)
     = (ss_empty, Decl [Par [Bind ("AA", Decl nil)]])

5. structure A = <strexp_A>
   dec_A = StrDec [<strb_A>]
   <strb_A>= Strb {name = "A", def = <strexp_A>, constraint = NoSig}
   dec_dl (<dec_A>, nil) 
     = parbind ss_binds [<strb_A>] nil
     = dl_addS (ss, decl0)
       where 
         (ss, binds) = foldl ss_binds (ss_empty, nil) [<strb_A>] 
                     = ss_binds (<strb_A>, (ss_empty, nil))              
		     = (SS.union (ss_empty, ss'), [("A", mexp)])
		       where
		         (ss', mexp) = strexp_p <strexp_A>
			             = (ss_empty, Decl [Par [Bind ("AA, Decl nil)]])
		     = (ss_empty, [("A", Decl [Par [Bind ("AA, Decl nil)]])])
       where decl0 = parbindcons (binds, nil)) 
                   = parcons ([Bind ("A", Decl [Par [Bind ("AA, Decl nil)]])], nil))
		   = [Bind ("A", Decl [Bind ("AA, Decl nil)])]
     = dl_addS (ss_empty, [Bind ("A", Decl [Bind ("AA, Decl nil)])])
     = [Bind ("A", Decl [Bind ("AA", Decl nil)])] : decls  -- skeleton for fileA.sml

   No Ref(s), no imports?
   Exports: {"A"}   (i.e. structure symbol "A")


------------------------------------------------------------------------------------------
 structure B =
 struct
   open A
   val y = AA.x
 end

<openA> = OpenDec [["A"]]
<vb_y> = Vb {pat = VarPat ["y"], exp = VarExp ["AA", "x"], lazyp = false}
<dec_y> = ValDec [<vb_y>]
<body_B> = SeqDec [<openA>, <dec_y>]
<strexp_B> = BaseStr <body_B>
<strb_B> = Strb {name = "B", def = <strexp_B>, constraint = NoSig}
<dec_B> = StrDec [<strb_B>]

dec_dl (dec_B, nil)
= dec_dl (StrDec [<strb_B>], nil)
= parbind ss_binds [<strb_B>] nil
= dl_addS (ss, parconbinds (binds, nil))
  (ss, binds)
     = foldl ss_binds (ss_empty, nil) [<strb_B>]
     = ss_binds (<strb_B>), (ss_empty, nil)
     = (SS.union (ss_empty, ss'), (name, mexp) :: nil)
	  (ss', mexp)
	     = strexp_p def
	     = strexp_p <strexp_B>
	     = (ss'', Decl decls)
		  (ss'', decls)
                     = split_dl decls
			 decls
			   = dec_dl (<body_B>, nil)
			   = dec_dl (SeqDec [<openA>, dec_y], nil)
			   = foldr dec_dl nil [<openA>, dec_y] 
			   = dec_dl (<openA>, dec_dl (<dec_y>, nil))
			   = dec_dl (<openA>, vb_dl (<dec_y>, nil))
			   = dec_dl (<openA>, [Ref {"AA"}]) 
			   = [Open [["A"]], Ref {"AA"}]
		     = (ss_empty, [Open [["A"]], Ref {"AA"}])
            = (ss_empty,  Decl [Open [["A"]], Ref {"AA"}])
    = (ss_empty, [("B", Decl [Open [["A"]], Ref {"AA"}])])
= dl_addS (ss_empty, parbindcons (binds, nil))
= parbindcons (binds, nil)
= [Bind ("B", Decl [Open [["A"]], Ref {"AA"}])]

Note that the Ref "AA" is buried beneath the Open [["A"]].
- How will the dependency of B on A be detected?
- How will the fact that "AA" is a spurious "import" be detected?
   (i.e. that "AA" is locally bound by "open A")
- How do we know that the reference to "AA" is in the scope of the "open A"?
  -- we need to know (from A's skeleton, presumably), that AA is defined as a structure
     component of A.
     
------------------------------------------------------------------------------------------
fileA.sml:
[Bind ("A", Decl [Bind ("AA", Decl nil)])] : decls

fileB.sml:
[Ref {"AA"}, Bind ("B", Decl [Open (Var "A")])] : decls

How would this change for (fileC.sml)?

 structure B =
 struct
   val y = AA.x
   open A 
 end

Would the Ref {"AA"} be in a different place? That would be recognized as outside
the scope of "open A"?

------------------------------------------------------------------------------------------


Possible Simplification Rules:

    Par nil => nil      -- not quite right: lhs is decl, rhs is list
    Seq nil => nil      -- not quite right: lhs is decl, rhs is list
    [Par nil] => nil      -- can this happen?  (not quite: lhs is decl, rhs is list)
    [Seq nil] => nil      -- can this happen?  (not quite: lhs is decl, rhs is list)
    Par nil :: decls => decls ?
    Seq nil :: decls => decls ?
    Par [decl] = decl   -- parcons does this & all Par nodes are constructed through parcon
    Seq [decl] = decl   -- seq function does this & all Seq nodes are constructed by seq


==========================================================================================
Summary
==========================================================================================

1. Start with Ast rep of declaration in a source file: Ast.dec.

2. Translate Ast.dec (convert.sml/SkelCvt.sml) into a Skeleton.decl.

3. Translate Skeleton.decl (Build.declExports in dbm/build.sml) into a DAEnv.env
   (dependency analysis) environment.

Question: does the DAEnv representation contain the same information as the
   skeleton it is derived from?  One assumes so. Verify?

4. From the DAEnv.env environment it should be possilbe to:

   A. For top-level structure declarations, one must be able to determine:

      a. what is directly exported by the declaration, namely the exported structure
         symbol (a single symbol, the name of the structure)

      b. substructure components, heirarchically
      	 in order to handle open decls for that structure in other module declarations
	 -- possibly "nested", i.e. you open structure A, then within the scope
	    of that open, you open a component of A, and so on (e.g. open B.C
	    where B is a substructure of A)

      c. what are the "imports" of the structure declarations, i.e. roughly the
         _free_ module references. This is made non-obvious because a structure (path head)
	 that is mentioned in the scope of an open declaration will not be free if
	 it is (recursively) a stucture bound by the open declaration.  So bound symbols
	 introduced via "open" have to be filtered out, but only within the scope of the
	 open dec.

         This means that if you mention a structure A in an open, you will need to know
	 the substructure tree of A (the substructures of A, their substructures, and so on).
	 This information is presumably derivable from the DAEnv representation of A.
  
   B. For top-level structure signature declarations, one must be able to determine

      a. the name of the signature, which is an exported symbol of the compilation unit (file)

      b. symbols for structures (path heads) that occur _free_ in the signature specs or
      	 where clauses.

      c. cope with include specifications, which are like open declarations for structures,
         but simpler (no hierarchy, because no signature declarations within signatures).
         The signature names of include statements should be added to the _free_ module
	 references.

      d. The single export is the signature name

      e. the imports are names of signatures (both structure and functor signatures)
         and structures that appear in the sigexp.  But there will not be any
	 free functor names (functor symbol imports).
      

   C. For top-level functor declarations, one must be able to determine

      a. the name of the functor, which is the sole export

      b. The imports, which are the free structure paths of the parameter and result
         signature expressions (sigexps)

      c. Imports for the functor body strexp, which can be calculated in the same
      	 way as they are for the strexp of a structure declaration.


   D. For top-level functor signature declarations, one must be able to determine

      a. the name of the functor signature, which is the sole export

      b. the imports of the parameter and result signatures
         (including the curried case if we add 1st-class curried functor signatures to Ast)
	 These are calculated as for signature expressions in signature declarations and
	 structure and functor declarations.

5. If a compilation unit (source file) contains a sequence of declarations, their
   export and import symbols have to be combined to give the exports and imports of
   of the complete compilation unit.

6. We have to produce the preliminary representations (skeletons and/or DAEnvs) of all
   the compilation units in a group before we can determine the dependency graph for
   the compilation units.

   Exports are easy to determine, but imports (of structure symbols in path heads) require
   that we know the substructure hierarchy of the imported structure to cope with the
   effects of open declarations.

7. So we need a tree representation that allows us to determine whether a given
   construct is in the scope of an outer open declaration. We also need to know whether
   any structure path head is in the scope of an outer declaration of that structure
   symbol.

