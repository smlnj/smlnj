Scanning ast to define import/export symbol lists:
(for determining dependencies between source files)

* Dependency Analysis Problem:

The problem is to determine, based on a simple concrete parse of the source files (the Ast representation) whether one source file depends on another.

In the absence of the "open" declaration, this seems to be fairly straightforward. We need to determine which
module symbols are locally defined, which are "exported", and which represent implicit imports from other
files (or compilation units).  But in the presence of open declarations, things become much more complicated.

The current solution involves:

(1) the "Skeleton" representation (smlfile/dbm/skeleton.sml) with types decl and exp, and
(2) the translation from the Ast representation to skeleton representation (smlfile/dbm/interface.sml), and
(3) the use of the skeleton representation to determine dependency (where?).


Example: the impact of open

Hypothetical imported structure A:

---------------------
fileA.sml
---------------------
   structure A =
   struct
     structure AA = struct val x = 3 end
   end
---------------------
exports: S:A, S:A.AA
imports: nil

fileA.sml may be a member of the same group (as fileB.sml below), or it may be a member of an imported
group.


Structure/file being scanned:

---------------------
fileB.sml
---------------------
  structure B =
  struct
    open A           <- signalling the import of A (if this is the "first" open),
                        introducing AA as "local" (secondary import)
    val y = AA.x     (a path in an expression starting with AA)
    (* ... open AA ... *)  (alternatively, AA could be mentioned in an open declaration *)
  end
---------------------
exports: S:B
imports: S:A  [satisfied by fileA.sml]

[for an import like A, need to know what substructures it contained (AA, which becomes
"local" after A is opened). And we need to know what substructures AA contains, in case
it is opened, and so on.]

[A could be defined in, and exported from, an imported group of the group containing fileB.sml
as a member. So dependency may be with respect to either a local member of an export of an
imported group.]

"A" is an imported structure symbol for B (fileB.sml)

Is "AA" an imported symbol?  No!  (It could be called a "secondary" import.)

After opening A, we don't know whether a structure symbol AA is an independent import
or whether it was introduced into the environment by "open A".

How do we detect this while scanning B in isolation?

Do we need a signature for structure A?

What if we are scanning B before we scan A? And before dependency analysis
shows that fileA.sml needs to be compiled before fileB.sml.

What if we conservatively record AA as an imported structure. And assume that
AA will not appear in any member's export list.  Does the extra, spurious AA
in the import list of fileB.sml cause a problem?

But there might be a problem (such as a false cyclical dependency) if in fact
AA were exported by some other file, say fileC.sml. We might falsely conclude
that fileB.sml depends on fileC.sml (when, in fact, fileC.sml depends on fileB.sml).


---------------------------------------------------------------------------------------- 
Attempted (naive) solution: try 2-pass approach.

1. calculate module exports, assuming no top-level open in SML source members
2. calculate imports, knowing the ???

Requirements:

1. need to be able to calculate the dependency relation, possibly in
multiple passes, but independently of the initial order in which source files are
scanned for I/E information.

2. use only "concrete" syntax representation (ast)


----------------------------------------------------------------------------------------
Skeletons, a worked example (for the above example: fileA.sml, fileB.sml):

  structure A =
  struct
    structure AA = struct val x = 3 end
  end

1. val x = 3
   <dec_x> = ValDec [vb_x]
   <vb_x> = Vb {pat=VarPat ["x"], exp=IntExp "3", lazyp=_}   --  omitting lazy flag 
   pat_s (VarPat ["x"], ss_empty)
     = s_addMP (["x"], ss_empty)
     = ss_empty
   exp_dl (IntExp "3", nil) = nil
   vb_dl (<dec_x>, nil)
     = dl_addS (ss_empty, nil)
     = nil
   dec_dl (<dec_x>, nil)
     = foldl vd_dl nil [vb_x]
     = vd_dl (<vb_x>, nil)
     = nil

2. struct val x = 3 end  (: Ast.strexp)
   <strexp_AA> = 
     = BaseStr (SeqDec [<dec_x>])
   dec_dl (SeqDec [<dec_x>], nil)
     = foldr dec_dl nil [<dec_x>]
     = dec_dl (<dec_x>, nil)
     = nil
   strexp_p (<strexp_AA>)
     = (ss, Decl decls)
       where (ss, decls) = split_dl (nil) = (ss_empty, nil)
     = (ss_empty, Decl nil)

3. structure AA = struct val x = 3 end (: Ast.dec)
   <dec_AA> = StrDec [<strb_AA>]
   <strb_AA> = Strb {name = "AA", def = <strexp_AA>, constraint = NoSig}
       strexp_p <strexp_AA> = (ss_empty, Decl nil) [2]
       sigexpc_p NoSig = NONE
       pairOp (strexp_p def, sigexpc_p constraint)
       = strexp_p def
       = (ss_empty, Decl nil)
   (ss, binds) = foldl ss_binds (ss_empty, nil) [<strb_AA>] nil
     = (ss_empty, Decl nil)
   dec_dl (<dec_AA>, nil)
     = parbind ss_binds [<strb_AA>] nil  
     = dl_addS (ss_empty, parbindcons ([("AA", Decl nil)], nil)
     = parbindcons ([("AA", Decl nil)], nil)
     = [Bind ("AA", Decl nil)] : decls

Note that there is no Ref decl in the result. Thus <dec_AA> contains no free
(imported) module symbols.

The (locally) defined, or exported symbols consist of ["AA"].

4. struct structure AA = ... end  (<strexp_A>: Ast.strexp)
   <strexp_A> : Ast.strexp = BaseStr (SeqDec [<dec_AA>])
   <dec_AA> : Ast.dec = StrDec [strb_AA]  [3]
   strexp_p <strexp_A>
     = strexp_p (BaseStr (SeqDec [<dec_AA>]))
       decls_A =
         dec_dl (SeqDec [<dec_AA>], nil)
	 = foldr dec_dl nil [<dec_AA>]
	 = dec_dl (<dec_AA>, nil)
	 = [Par [Bind ("AA", Decl nil)]].
       (ss, decls) = split_dl decls_A = (ss_empty, decls_A)
     = (ss_empty, Decl [Par [Bind ("AA", Decl nil)]])

5. structure A = <strexp_A>
   dec_A = StrDec [<strb_A>]
   <strb_A>= Strb {name = "A", def = <strexp_A>, constraint = NoSig}
   dec_dl (<dec_A>, nil) 
     = parbind ss_binds [<strb_A>] nil
     = dl_addS (ss, decl0)
       where 
         (ss, binds) = foldl ss_binds (ss_empty, nil) [<strb_A>] 
                     = ss_binds (<strb_A>, (ss_empty, nil))              
		     = (SS.union (ss_empty, ss'), [("A", mexp)])
		       where
		         (ss', mexp) = strexp_p <strexp_A>
			             = (ss_empty, Decl [Par [Bind ("AA, Decl nil)]])
		     = (ss_empty, [("A", Decl [Par [Bind ("AA, Decl nil)]])])
       where decl0 = parbindcons (binds, nil)) 
                   = parcons ([Bind ("A", Decl [Par [Bind ("AA, Decl nil)]])], nil))
		   = [Bind ("A", Decl [Bind ("AA, Decl nil)])]
     = dl_addS (ss_empty, [Bind ("A", Decl [Bind ("AA, Decl nil)])])
     = [Bind ("A", Decl [Bind ("AA", Decl nil)])] : decls  -- skeleton for fileA.sml

   No Ref(s), no imports?
   Exports: {"A"}   (i.e. structure symbol "A")


------------------------------------------------------------------------------------------
 structure B =
 struct
   open A
   val y = AA.x
 end

<openA> = OpenDec [["A"]]
<vb_y> = Vb {pat = VarPat ["y"], exp = VarExp ["AA", "x"], lazyp = false}
<dec_y> = ValDec [<vb_y>]
<body_B> = SeqDec [<openA>, <dec_y>]
<strexp_B> = BaseStr <body_B>
<strb_B> = Strb {name = "B", def = <strexp_B>, constraint = NoSig}
<dec_B> = StrDec [<strb_B>]

dec_dl (dec_B, nil)
= dec_dl (StrDec [<strb_B>], nil)
= parbind ss_binds [<strb_B>] nil
= dl_addS (ss, parconbinds (binds, nil))
  (ss, binds)
     = foldl ss_binds (ss_empty, nil) [<strb_B>]
     = ss_binds (<strb_B>), (ss_empty, nil)
     = (SS.union (ss_empty, ss'), (name, mexp) :: nil)
	  (ss', mexp)
	     = strexp_p def
	     = strexp_p <strexp_B>
	     = (ss'', Decl decls)
		  (ss'', decls)
                     = split_dl decls
			 decls
			   = dec_dl (<body_B>, nil)
			   = dec_dl (SeqDec [<openA>, dec_y], nil)
			   = foldr dec_dl nil [<openA>, dec_y] 
			   = dec_dl (<openA>, dec_dl (<dec_y>, nil))
			   = dec_dl (<openA>, vb_dl (<dec_y>, nil))
			   = dec_dl (<openA>, [Ref {"AA"}]) 
			   = [Open [["A"]], Ref {"AA"}]
		     = (ss_empty, [Open [["A"]], Ref {"AA"}])
            = (ss_empty,  Decl [Open [["A"]], Ref {"AA"}])
    = (ss_empty, [("B", Decl [Open [["A"]], Ref {"AA"}])])
= dl_addS (ss_empty, parbindcons (binds, nil))
= parbindcons (binds, nil)
= [Bind ("B", Decl [Open [["A"]], Ref {"AA"}])]

Note that the Ref "AA" is buried beneath the Open [["A"]].
- How will the dependency of B on A be detected?
- How will the fact that "AA" is a spurious "import" be detected?
   (i.e. that "AA" is locally bound by "open A")
- How do we know that the reference to "AA" is in the scope of the "open A"?
  -- we need to know (from A's skeleton, presumably), that AA is defined as a structure
     component of A.
     
------------------------------------------------------------------------------------------
fileA.sml:
[Bind ("A", Decl [Bind ("AA", Decl nil)])] : decls

fileB.sml:
[Ref {"AA"}, Bind ("B", Decl [Open (Var "A")])] : decls

How would this change for (fileC.sml)?

 structure B =
 struct
   val y = AA.x
   open A 
 end

Would the Ref {"AA"} be in a different place? That would be recognized as outside
the scope of "open A"?

------------------------------------------------------------------------------------------


Possible Simplification Rules:

    Par nil => nil      -- not quite right: lhs is decl, rhs is list
    Seq nil => nil      -- not quite right: lhs is decl, rhs is list
    [Par nil] => nil      -- can this happen?  (not quite: lhs is decl, rhs is list)
    [Seq nil] => nil      -- can this happen?  (not quite: lhs is decl, rhs is list)
    Par nil :: decls => decls ?
    Seq nil :: decls => decls ?
    Par [decl] = decl   -- parcons does this & all Par nodes are constructed through parcon
    Seq [decl] = decl   -- seq function does this & all Seq nodes are constructed by seq


==========================================================================================
Summary
==========================================================================================

1. Start with Ast rep of declaration in a source file: Ast.dec.

2. Translate Ast.dec (convert.sml/SkelCvt.sml) into a Skeleton.decl.

3. Translate Skeleton.decl (Build.declExports in dbm/build.sml) into a DAEnv.env
   (dependency analysis) environment.

Question: does the DAEnv representation contain the same information as the
   skeleton it is derived from?  One assumes so. Verify?

4. From the DAEnv.env environment it should be possilbe to:

   A. For top-level structure declarations, one must be able to determine:

      a. what is directly exported by the declaration, namely the exported structure
         symbol (a single symbol, the name of the structure)

      b. substructure components, heirarchically
      	 in order to handle open decls for that structure in other module declarations
	 -- possibly "nested", i.e. you open structure A, then within the scope
	    of that open, you open a component of A, and so on (e.g. open B.C
	    where B is a substructure of A)

      c. what are the "imports" of the structure declarations, i.e. roughly the
         _free_ module references. This is made non-obvious because a structure (path head)
	 that is mentioned in the scope of an open declaration will not be free if
	 it is (recursively) a stucture bound by the open declaration.  So bound symbols
	 introduced via "open" have to be filtered out, but only within the scope of the
	 open dec.

         This means that if you mention a structure A in an open, you will need to know
	 the substructure tree of A (the substructures of A, their substructures, and so on).
	 This information is presumably derivable from the DAEnv representation of A.
  
      d. Note that free paths in a structure declaration can refer to structures, functors,
         structure signatures and functor signatures (because of higher-order functors).

   B. For top-level structure signature declarations, one must be able to determine

      a. the name of the signature, which is an exported symbol of the compilation unit (file)

      b. symbols for structures (path heads) that occur _free_ in the signature specs or
      	 where clauses.

      c. cope with include specifications, which are like open declarations for structures,
         but simpler (no hierarchy, because no signature declarations within signatures).
         The signature names of include statements should be added to the _free_ module
	 references.

      d. The single export is the signature name

      e. the imports are names of signatures (both structure and functor signatures)
         and structures that appear in the sigexp.  But there will not be any
	 free functor names (functor symbol imports).
      

   C. For top-level functor declarations, one must be able to determine

      a. the name of the functor, which is the sole export

      b. The imports, which are the free structure paths of the parameter and result
         signature expressions (sigexps)

      c. Imports for the functor body strexp, which can be calculated in the same
      	 way as they are for the strexp of a structure declaration.


   D. For top-level functor signature declarations, one must be able to determine

      a. the name of the functor signature, which is the sole export

      b. the imports of the parameter and result signatures
         (including the curried case if we add 1st-class curried functor signatures to Ast)
	 These are calculated as for signature expressions in signature declarations and
	 structure and functor declarations.

   E. Note that free paths for signatures and functor signatures will be singleton paths,
      but free paths for structures and functors can have nontrivial tails.

5. If a compilation unit (source file) contains a sequence of declarations, their
   export and import symbols have to be combined to give the exports and imports of
   of the complete compilation unit.

6. We have to produce the preliminary representations (skeletons and/or DAEnvs) of all
   the compilation units in a group before we can determine the dependency graph for
   the compilation units.

   Exports are easy to determine, but imports (of structure symbols in path heads) require
   that we know the substructure hierarchy of the imported structure to cope with the
   effects of open declarations.

7. So we need a tree representation that allows us to determine whether a given
   construct is in the scope of an outer open declaration. We also need to know whether
   any structure path head is in the scope of an outer declaration of that structure
   symbol.

8. [Quesions]
   -- Is it possible to merge and simplify the skeleton and DAEnv representations
      into a single representation?
   -- Can the two pass construction

        Ast.dec -> Skeleton.decl -> DAEnv.env

      be replaced with a one-pass translation.

   -- what is the right way to "tentatively" keep track of set of free paths (path heads)?

9. Next goal: to try to simultaneously unify and simplify the skeleton+DAEnv representations.


======================================================================================
Big Example
======================================================================================

DEFN: "c-unit" is short for compilation unit, which is a CM group
source file member, which will contain only module-level bindings, and
in particular, no top-level open declarations.

c-unit context (env)  binds: A3, A8
-----------------------------------

structure S =
struct
  type t = A1.s list       pimport A1 
  val x = (3, A2.y)   	   pimport A2
  structure S1 = A3        pimport A3
  open A4                  pimport A4  (could bind S2, or rebind A3, A8, S1)
  val y = A5.z		   pimport A5/[A4]  (A5 an import, or a comp substructure of A4)
  val d = S1.e		   pimport? S1/[A4] (S1 cannot be presumed known after "open A4")
  open S2 		   pimport S2/[A4]  (S2 cannot be presumed known after "open A4")

  structure S2 =
    struct
      type t = A6.u        pimport A6/[A4, S2]     (won't check if A6.u defined)
      open A7              pimport A7/[A4, S2]
      val z = A8.v	   pimport A8/[A4, S2, A7]  (won't check if A8.v defined)
    end

  val h = S2.z		   ~pimport S2!   (S2 bound locally, and in scope) 
  open A9.B	           pimport A9/[A4]
  val h = S2.z		   pimport S2/[A4,?] or S2 local
  val a = A10.b		   pimport A10/[A4,A9.B]

  ...
end

* When we detect a potential import path (e.g. A.B.c, where A is a strsym), we never check
  whether B.c is a valid internal path for A, even after A is resolved with a binding.

Q: Do we attempt to detect during elaboration whether a path head is "locally bound",
  i.e. bound earlier in the current c-unit? If so, do we assume knowledge of the components
  (recursively), so that we can determine the component bindings introduced by an opening of
  that path?

  The problem is that after opening a free path (a path whose head is not known to be bound, a
  pimport path), all existing knowledge of bound structures has to be cancelled, since such an
  open dec may shaddow any previously known structure binding. This means that any inherited
  module environment is cancelled when opening a free path.
  
* Abbreviation: FPH = "free path head" (str symbols)

* Representation of "elaborated Ast declarations"

  We need 2 things:

  (1) the set of free path heads

  (2) the heirarchical module structure (particularly for structures and their substructures,
      recursively.

  The question is how these should be related. Or where should we attach the free path head
  sets to the nested structure trees?  We also have to partition the see of FPHs

  The basic problem is that declarations and the classification of "free" path heads interact,
  both in the case of open declarations and structure declarations, which can bind path heads
  (structure symbols).

  Because the structure (exported substructures, etc) of free structure symbols is unknown,
  we take a conservative approach of not trying to track which structure names (path heads)
  are bound in the current context, treating them all as unknown, even those that are locally
  declared.  Filtering out the bound structure symbols will take place in a second, post
  elaboration, pass.

  So in the first pass, _all_ path heads are treated as potentially, or provisionally, free.
  But we need to collect a free path head set for each "scope", i.e. for the scope of each
  structure/substructure declaration.  Since we are not trying to determine whether structure
  symbols are bound, we will include all structure declarations, even those that are not in
  the scope of a previous structure declaration.  This means we do not need to pass an
  environment of bound structure (or module) names, and we do not keep track of previous
  module declarations that may have occurred earlier in the current c-unit/source file.

  Initial core declarations, or consecutive sequences of core declarations occurring before
  any structure binding declaratioins, can have their FPHs collected for the current structure.
  

  For each structure declaration, we can collect the FPH set for all top-level,
  non-module (core) declarations that occure in the body of that structure (in the BasicStr
  case) before the first substructure or open declaration, i.e. before any new strsym
  bindings are (potentially) introduced.
  
  For functor declarations (in a strexp):

     functor F (P: <paramsig) = <strexp>

  we collect the FPHs of <paramsig>, which are in the structure scope. The FPHs of 
  <strexp> might be locally shadowed

  For (leading, i.e. "initial") component structure declarations of the form

     structure S : <signame> = <strpath>

  we could collect the <signame> and <strpath> as FPHs of the parent structure
  (not in danger of being locally shadowed). Note that <strpath> may be a singleton
  path (bound to a structure).

  Essentially, any strsym binding construct (str decl or open) requires introducing a new
  FPH set for the scope of that binding construct, to be supplanted following the "next"
  strsym binding construct.

  Functor declarations do not bind strsyms, and therefore do not introduce FPH scopes. 

  A strexp on the rhs of a structure or functor dec or as a functor call argument
  does not introduce a str binding scope, so does not require a new FPH set.

  Similarly, a sigexp does not bind strsyms, but may contain str specs or include
  specs that do bind strsyms, and hence by introduce local FPH scopes.

  We could use the term "FPH scope" for the "structural region" introduced by a
  strsym binding construct.  Each FPH scope then requires its own FPH set, which
  will be filtered by bound strsyms in the second pass, whose purpose is to keep
  track of such bound strsyms (including ones introduced by opening an "imported"
  path head).

  To summarize,

  -- core declarations do not introduce a FPH scope, and so use the "current" FPH set.
  -- strexps do not introduce a FPH scope (nor do sigexps)
  -- strdecs and opens within a basic strexp do introduce new FPH scopes, and thus
     require new FPH sets for that scope
  -- strspecs and includes in a basics sigexp can bind strsyms and therefore also
     introduce new FPH scopes and FPH sets.

* Where do we put the FPH sets associated with FPH scopes in the elaborated representation?
  Do we "linearize" the structure (analagous to skeleton decl)?

* Procedure:
  -- traverse Ast structure, collecting FPHs in the "current" FPH set.
  -- until a strsym binding construct is encountered, then "freeze" current FPH set
     which becomes an auxiliary value  _associated with that binding construct (declaration)_.

  (1) process a strsym binding dec
      - initialize a new FPH set and pass it as a parameter as we traverse following
        bindings, if any, where it can grow (e.g. while processing succeeding
	core decs).
      - when following bindings are "finished", meaning we run out of decs or we run
        into the next (potential) strsym binding dec, "issue" the final FPH set,
	associating it with the initial binding that introduced a new FPH scope
