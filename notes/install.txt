~/sml/Dev/github/smlnj/notes/install.txt  [newpp branch of smlnj]

Notes on SML/NJ build/install process
-------------------------------------
DBM, 2023.1

Trying to understand the install process in order to trouble-shoot the problem of
adding smlnj-lib/prettyprint without breaking the build process.

------------------------------------------------------------------------------------------
1. Catalog of files involved in building compiler (+cm), libraries, and tools:
------------------------------------------------------------------------------------------

Note: all filenames/paths are relative to the SML/NJ ROOT directory
      (e.g. ~/sml/Dev/github/smlnj in my case, which is a GitHub clone of the newpp branch
       of the smlnj/smlnj repository)

build.sh [:shell]
  - the main (top-level) build script

config/ [:dir]
  actions [:txt/config]
  dependencies [:txt/config]
  extrapathconfig [:txt/config]
  targets [:txt/config]
  releasedate [:txt/config]
    - contents is release date (a string), e.g "August 25, 2022\n"

system/ [:dir]
  README [:txt/doc] ("Compiler Hacker's Guide to new CM...")

  cmb-make  [:shell]
  makeml    [:shell]
  installml [:shell]
  cmb-cross [:shell]
  all-cross [:shell]
  iter-make [:shell]
  testml    [:shell]  

  pathconfig [:txt/config]  (CM path definitions)
  preloads.bare [:txt/config] (autoload declarations?)
  preloads.standard [:txt/config] (autoload declarations?)
  root.cm [:CM desc]

  batchcomp.sml [:sml]
  serv.sml  [:sml]
  rserv.sml [:sml]
  tserv.sml [:sml]

  sml.bin.amd64-unix/ [:dir]
  sml.boot.amd64-unix/ [:dir] (compiled code]

system/smlnj/ [:dir]

  smlnj-lib/ [:dir]
     controls-lib.cm [:CM desc]
     pp-lib.cm [:CM desc]          -- old prettyprint library (smlnj-lib/PP)
     prettyprint-lib.cm [:CM desc] -- new prettyprint library (smlnj-lib/PrettyPrint)
     smlnj-lib.cm [:CM desc]       -- smlnj-lib/Util
     [Q] Why are only these few libraries treated in this directory? What about all
         the other libraries in smlnj-lib?  Are these the only ones used internally by
	 the compiler (+cm)?

  cm.cm [:CM desc]
  cm/ [:dir]
    cm.cm [:CM desc]
      - something wierd related to pickling and sequencing
    tools.cm [:CM desc]

    tools.sml [:sml]
    fetch-cm.sml [:sml]
    [Q] Why do we need an "external" cm.cm and also an "internal" cm.cm?

  cmb.cm [:CM desc]
  cmb/ [:dir]
    current.cm [:CM desc]
    amd64-unix.cm [:CM desc]
    arm64-unix.cm [:CM desc]

    amd64-unix.sml
    arm64-unix.sml
    select-amd64-unix.sml
    select-arm64-unix.sml

  installer.cm [:CM desc]
  library-install.cm 
  installer/ [:dir]
    util.cm [:CM desc]
    installer-util.sml [:sml}
      - defines "fail" function, which prints "FAILURE:" messages
    patch-file.sml [:sml}
    generic-install.sml [:sml}
      - generates error messages like
          "FAILURE: Built ml-ulex; ml-ulex.amd64-darwin still missing"
      - generates messages like
          "Library <libname> already existed in <file path>"
    library-install.sml [:sml}
    nix-install.sml [:sml}
    win-install.sml [:sml}
    [Q] Why is util.cm inside (internal to) installer/ but installer.cm and
        library-install.cm are outside (external to) the installer/ directory?

  internal/ [:dir]
    cm0.cm
      - appears in ../cm/cm.cm 
    cm-lib.cm [:CM desc]
    cm-sig-lib.cm [:CM desc]
      - appears in ../cm/cm.cm (the "internal" cm.cm file)
    versiontool.cm
    smlnj-version.cm
    srcpath-lib.cm
    intsys.cm

    version.sml [:sml] (defines buildData, releaseDate, version, banner)
    version.template [:sml]  (template instantiated to create version.sml)
    versiontool.sml [:sml]
    int-sys.sml

  compiler.cm [:CM desc]
  compiler/ [:dir]
    all.cm [:CM desc]
    amd64.cm  [:CM desc]
    arm64.cm  [:CM desc]
    compiler.cm [:CM desc]
    current.cm [:CM desc]
    minimal.cm [:CM desc]
    minimal-only.cm [:CM desc]
    
    amd64.sml [:sml]
    arm64.sml [:sml]
    compiler.sml [:sml]
    minimal-compiler.sml [:sml]

    [Q] Why so many different .cm files here? What are their purposes?

  viscomp/ [:dir]
    amd64.cm [:CM desc]
    arm64.cm [:CM desc]
    core.cm [:CM desc] 
    basics.cm [:CM desc]
    parser.cm [:CM desc]
    elabdata.cm [:CM desc]
    elaborate.cm [:CM desc]
    execute.cm [:CM desc]
    debugprof.cm [:CM desc]

    [Q] What is the effect of this viscomp setup? How does it work?
        What is the potential for supporting a LSP library?
        We seem to be missing some cm files for major components (e.g. FLINT, CPS)
	which are by default included in core.cm.

  basis/ [:dir]
    basis.cm [:CM desc]

  init/ [:dir]
    init.cmi [:CM cmi]
    [+ 24 sml files related to initialization of (pervasiv environment?), ml-nlffi]

  asdl/ [:dir]
    asdl-lib.cm [:CM desc]

system/Basis/ [:dir]
  basis.cm [:CM desc]
  basis-common.cm  [:CM desc]

  Exports/ [:dir]
  TypesOnly/ [:dir]
  Implementation/ [:dir]
    - Basis source code

lib/ [:dir]
  pathconfig [:txt/config]
    - how derived? Relation to system/pathconfig and config/extrapathconfig?
    - why repeated lines?
  pp-lib.cm/ [:dir] (e.g.)
    .cm/ [:dir]
      amd64-unix/ [:dir]
        pp-lib.cm [:binary?, 69089 bytes] 
  SMLNJ-ASDL-LIB/ [:dir]
  SMLNJ-BASIS/ [:dir]
  SMLNJ-LIB/ [:dir]
  SMLNJ-ML-YACC-LIB/ [:dir]
  cml/ [:dir]
  cml-lib/ [:dir]
  compiler/ [:dir]
  *.cm/ [:dirs]  [dir-tool, grm-ext, hash-cons-lib, html-lib, etc.]
  [Why no prettyprint-lib.cm for smlnj-lib/PrettyPrint or system/smlnj/smlnj-lib/prettyprint-lib.cm?]

bin/ [:dir]
  .arch-n-opsys [:shell]
  .run-sml [:shell]
  .link-sml [:shell]
  .heap/ [:dir]
    sml.amd64-darwin [:heap image]
    ml-yacc.amd64-darwin [:heap image]
    ml-burg.amd64-darwin [:heap image]
    ...
  .run/ [:dir]
    run.amd64-darwin [:x86-64 executable]

  ml-build [:shell]  
    - script for building stand-alone programs (e.g. ml-yacc), (using SMLofNJ.exportFn)
    - documented in CM Manual, Section 15
  ml-makedepend [:shell]  
  heap2exec [:shell]  

  sml [:symlink] ( -> .run-sml) 
  ml-yacc [:symlink] ( -> .run-sml) 
  ml-burg [:symlink] ( -> .run-sml) 
  ...

[Q] Why is .link-sml hidden and ml-build not hidden?
    Is .link-sml ever used independently of ml-build?
    Does ml-build ever use other values of $LINK?


------------------------------------------------------------------------------------------ 
2. Where do the compiled binary files live?
------------------------------------------------------------------------------------------

(1) system/sml.boot.amd64-unix
    (binary files for the compiler itself?)
    [description of contents?
     per-(stable) library binary files?]

(2) system/sml.bin.amd64-unix
    [description of contents?
     contains per-source file binary files?]

(3) in .cm directories in source directories
    [for libraries and tools, but not compiler and cm?]
    These .cm directories contain three subdirectories:
      - GUID/
          (per source file, re-using source file name) GUIDs
      - SKEL/
          (per source file, re-using source file name) 
          skeletal description for calculating dependencies
      - amd64-unix/
          (per source file, re-using source file name) 
          binary files (code+static)

    E.g. smlnj/smlnj-lib/PP/src/.cm
    E.g. smlnj/tools/ml-lpt/ml-ulex/.cm 
    E.g. smlnj/tools/ml-lpt/ml-ulex/BackEnds/.cm 

    Note that code in amd64-unix and GUID info in GUID will be updated
    whenever the source is recompiled, but not necessarily the SKEL
    info, which may remain unchanged (?).

    Note that source directories in the compiler and cm (e.g. compiler/Basics/print)
    also contain .cm directories, but these .cm directories contain only GUID and SKEL
    subdirectories, but no sml64-unix subdirectories containing binary code.
    So the missing binary files for these sources are found where? sml.bin.amd64-unix?

(4) lib
    E.g. lib/pp-lib.cm/.cm/amd64-unix/pp-lib.cm (looks like a bin file?)


[Q] Why are binary code files found in so many places?
    Which is the canonical place (for any particular source file) ?
    Why is there no prettyprint-lib.cm directory in lib?

[Q] Why do we need both sml.bin and sml.boot?
    What goes in which?

[Q] Is sml.bin just used to build sml.boot and is thereafter redundant?
    Note that only a tarball of an sml.boot directory is needed by the
    root build.sh script.

[Q] Where is the format of binary files documented?


------------------------------------------------------------------------------------------ 
NOTE: For the following, I assume shell variable SMLNJ refers to the root directory of my
SML/NJ source tree:

    SMLNJ = ~/sml/Dev/github/smlnj

which is a clone of the smlnj/smlnj GitHub repository (currently on branch newpp).

We also define, e.g.

    ml-ulex = $SMLNJ/tools/ml-lpt/ml-ulex

the source directory for the ml-ulex tool. In some other respects the descriptions
have been particularized to my (file) system setup (BIN_DIR, LIB_DIR, RUN_DIR, SML).
------------------------------------------------------------------------------------------


------------------------------------------------------------------------------------------    
3. $SMLNJ/build.sh  (shell script)
------------------------------------------------------------------------------------------    
What happens in $SMLNJ/build.sh? (the main, or top-level build script)

1. The initial call of build.sh assumes that it is running in $SMLNJ, which contains the
source directory tree (probably a clone of the GitHub smlnj/smlnj repo), and that there is
boot tarball available:

     $SMLNJ/boot.amd64-unix.tgz

[Later it is intended that this tarball will be fetched if necessary, as used to happen
with config/install.sh.]

Then (as a first approximation)

  a. the runtime system must be compiled (which takes a long time with the llvm runtime)
     The result is the file bin/.run/run.amd64-darwin is created.
  b. the boot tarball is unpacked, producing a $SMLNJ/boot.amd64-unix directory (?)
  c. the sml.amd64-darwin heap image is built and placed in bin/.heap
     At this point we can run the bin/sml command.
  d. 

2. The other typical situation where build.sh is called is when

   ./cmb-make
   ./makeml
   ./installml -clean
   cd ..

have been executed in $SMLNJ/system, leaving a newly build sml heap file in bin/.heap.

---------------------
Comments, bugs, fixes

* Redundancy between complain and arguments of complain. Both printing "$cmd !!!", so
error messages start with, e.g. "./build.sh !!! ./build.sh !!! ...".
[Fixed]


------------------------------------------------------------------------------------------    
4. bin/ml-build  (shell script)
------------------------------------------------------------------------------------------    
What happens in ml-build?

Note: ml-build is "instantiated" (at some point, by build.sh?) with fixed file paths
for BIN_DIR and LIB_DIR that are used if the environment variable $SMLNJ_HOME is empty
or not defined.

1. If shell variable SMLNJ_HOME is undefined or is the empty string,
   
     BIN_DIR = $SMLNJ/bin  (using the local file path of $SMLNJ that was inserted into ml-build)
     LIB_DIR = $SMLNJ/lib

   otherwise, these are defined in terms of the value of $SMLNJ_HOME.

2. If shell variable CM_PATHCONFIG is undefined or empty it is defined by

      CM_PATHCONFIG = $LIB_DIR/pathconfig = $SMLNJ/lib/pathconfig
   
   and is exported to the shell environment.

3. defines variables

     SML = $BIN_DIR/sml = $SMLNJ/bin/sml (symbolic link to bin/.run-sml)
     LINK = $BIN_DIR/.link-sml = $SMLNJ/bin/.link-sml
     thisscript = $0 = ml-build
     
4. defines several "temporary" file names in terms of the (current) process id (pid)

     pid = $$  (process id for this invocation of ml-build (actually named "xx"))
     smlfile = $pid-export.sml
     cmfile = $pid-export.cm
     listfile = $pid-BOOTLIST
     linkargsfile = $pid-LINKARGS

   These files are "temporary" and will be deleted in the cleanup triggered by the
   trap set up in the next step (e).

   Alternatively, give them distinctive fixed names, as in:

     smlfile=MLBUILD_export.sml
     cmfile=MLBUILD_export.cm
     listfile=MLBUILD_BOOTLIST
     linkargsfile=MLBUILD_LINKARGS

   These would be extremely unlikely to overwrite existing files, except for a previous
   run of ml-build that did not clean up after itself.


5. sets up a trap for signals 0 1 2 3 15  (what are these signals?)
   with a command to delete smlfile, etc, and generated binary files for $smlfile
   This will clean up "at the conclusion" of the script. [It does so even when there
   is a segmentation fault while running ml-build.]

6. The variable "setup" is initialized to be empty, but can be set either by an "-S" command
   line option (and its argument), or by the first arg in the 2nd phase of command line
   argument processing (step h), if there are (at least?) 4 remaining arguments.
   Such a -S setup argument is passed separately from the other sml arguments
   (-D*, -U*, -C* arguments). Why?

7. command line options processing to capture -D*, -U*, -C* options to be passed to sml
   via the "dulist" variable, and also the -S option, if any, to possibly define the setup
   variable in terms of the following (required) argument.

8. further command line options are processed to define variables (successively)

     setup  (only if there was no -S option in the previous phase of options processing)
     root   -- the cm sources file
     main   -- the name (SML qualified identifier) of the function to be exported via
               exportFn, e.g. Main.main for the ml-ulex/build.sh call of ml-build 
     heap   -- name of the heap file generated by exportFn (and passed to exportFn as its
               2nd argument

   depending on how many additional arguments are passed. There should be at least 1 arg,
   used to define root. The variables main and heap are assigned default values if there
   were not enough arguments.  The setup variable (if empty) is defined as the first
   additional argument, but only if there are (at least) 4 arguments remaining.

9. Define a dummy structure name "XYZ_XXX_0123", and use this structure name in the text
   generated for the temporary files $smlfile and $cmfile:

   contents of $smlfile = $pid-export.sml:

      structure XYZ_XXX_0123 = struct val _ = SMLofNJ.exportFn ("${heap}", ${main}) end
      structure XYZ_XXX_0123 = struct val _ = SMLofNJ.exportFn ("ml-lex", Main.main) end 

   contents of $cmfile = $pid-export.cm:

      Group structure XXY_XXX_0123 is \$/basis.cm ${root} ${smlfile}
      Group tructure XYZ_XXX_0123 is $/basis.cm sources.cm {$pid-export.sml}

   When executed by CM, this will produce a heap image file named "ml-ulex.amd64-darwin".

10. invoke $SML with arguements

   What sml command is run here? It is the "local" one, defined by

      SML = $BIN_DIR/sml = $SMLNJ/bin/sml = $SMLNJ/bin/.run-sml

   This is linked to bin/.run-sml.

   The arguments are:

      $dulist     -- the -D*, -U*, -C* arguments passed to ml-build
      @CMbuild    -- the magic word to activate the desired CM (CMB?) compilation
      $setup      -- (empty when invoked from ml-ulex/build.sh)
      "$root"     -- the name of the cm description file for the CM compilation (i.e. ml-ulex/sources.cm)
      "$cmfile"   -- the name of the additional temporary CM file ($pid-export.cm) causing the compilation
                     and execution of the $smlfile ($pid-export.sml), that calls exportFn
      "$heap"     -- the basename of the heap file generated by calling exportFn (its 1st argument)
      "$listfile" -- the name of a BOOTLIST file to be output (by CM?)
      "$linkargsfile" -- the name of a "link arguments" file to be (possibly?) output
                         whose contents are to be passed to bin/.link-sml as arguments
			 after the successful execution of the $SML command.

   Why are both $root (sources.cm) and $cmfile ($pid-export.cm) passed to $SML, when the
   $pid-export.cm file includes sources.cm (as ${root} in its description. $cmfile
   should be sufficient.

11. After $SML is run to compile the temporary file $smlfile using $cmfile, we check
   for whether $linkargsfile (= $pid-LINKARGS) is "readable" (does that imply it exists,
   or is non-empty? If it is "readable", then we invoke bin/.link-sml with its contents as
   command-line arguments. Otherwise we return the exit status of the $SML command.

l2. At the end, the previously defined trap command is run (why exactly?, in response to
   which signal?), which causes the deletion of the temporary files $smlfile, $cmfile,
   $listfile, $linkargsfile, and also the deletion of files matching ".cm/*/$smlfile".
   But if the $SML command was "successful", there should remain the file $heap.
   

13. We should be able to preserve the temporary files and compilation result simply by
   commenting out the "trap" command in ml-build. Try this for debugging.

14. SUGGESTION: Why not include the export.sml file permanently in ml-ulex, and add
   export.sml to the ml-ulex sources.cm description, with its (dummy) structure exported.
   The permanent export structure could be named "ML_Ulex" or "Export" or "ExportULEX" and
   would replace Main in the export list of ml-ulex/sources.cm. Then the temporary cm file
   $pid-cmfile would not be needed.


------------------------------------------------------------------------------------------ 
5. bin/sml (shell) [= bin/.run-sml]  -- the script that "runs" sml
------------------------------------------------------------------------------------------ 
What does the $SML command do?

1. $BIN_DIR/sml ($SMLNJ/bin/sml) is a symbolic link to $BIN_DIR/.run-sml ($SMLNJ/bin/.run-sml).

   So this description really describes bin/.run-sml.

2. In ml-build,

   SML = $BIN_DIR/sml = $SMLNJ/bin/sml

3. .run-sml is "instantiated" to define the default BIN_DIR to be $SMLNJ/bin.

4. shell environment variables referenced

   SMLNJ_HOME
   SMLNJ_CYGWIN_RUNTIME
     -- SMLNJ_HOME redefined if $SMLNJ_HOME and $SMLNJ_CYGWIN_RUNTIME are both defined

   CM_PATHCONFIG (default $SMLNJ_HOME/lib/pathconfig = $SMLNJ/lib/pathconfig)
     -- defined and exported if not previously defined

5. other variables defined
 
   CMD = basename $0, which would normally be "sml" (or "ml-yacc", etc.)

   BIN_DIR (default $SMLNJ/bin = "/Users/dbm/sml/Dev/github/smlnj/bin")
     -- checked that it exists and is a directory

   RUN_DIR = $BIN_DIR/.run = $SMLNJ/bin/.run (runtime executable: .run-amd64-darwin)
   
   HEAP_DIR = $BIN_DIR/.heap = $SMLNJ/bin/.heap

   -- from bin/.arch-n-opsys:

   ARCH = amd64

   OPSYS = darwin

   HEAP_SUFFIX = amd64-darwin

6. .run-sml argument processing: case on next arg = ($1)

   @SMLrun=<filename> =>
      RUN = <filename>

   @SMLload=<filename> =>
      HEAP = $arg

   @SMLsuffix =>
     REPORT_SUFFIX = yes

   @SMLappl arg' =>
     APPL = arg'  (arg' is following argument; $1 after a shift. Two args consumed)

   @SMLalloc arg' =>
     ALLOC = arg' (two arguments consumed)
     
   -- reporting only: one argument consumed, no variables defined

   @SMLversion =>
     report SML version: "sml 2022.1"

   @SMLwordsize =>
     report SML word size: "64"
   
   until these @ arguments are all processed.
   Then passes the remaining arguments ($@) to the call of $RUN in the last line.

   If they are not defined by a corresponding @SML argument, the following variables are
   defined by default:

     APPL = $CMD (e.g. "sml")

     HEAP = "@SMLload=$HEAP_DIR/$APPL" = "@SMLload=$SMLNJ/bin/.heap/sml"
       -- note that there is no heap-suffix in this file path (e.g. no .amd64-darwin)

     RUN = $SMLNJ/bin/.run/run-amd64-darwin  (ignoring $ALT_OPSYS exceptional case) 


7. What do the (remaining) arguments do/mean when passed in the $RUN command?

   dulist  (-D*, -U*, -C* arguments originally passed to ml-build in ml-ulex/build.sh)

   @CMbuild

   root (ml-ulex sources.cm file)

   $cmfile ($pid-export.cm)  -- cm file to compile and execution $pid-export.sml

   $heap -- the heap file produced when SMLofNJ.exportFn is called in $pid-export.sml

   $listfile ($pid-listfile) -- file to which bootlist should be written
   
   $linksargfile ($pid-LINKARGS) -- file where args to bin/.link-sml are written


------------------------------------------------------------------------------------------    
6. bin/.link-sml (shell script)
------------------------------------------------------------------------------------------    
What happens in .link-sml?  [and why isn't it just bin/link-sml? or bin/ml-link?]

1. Why does it need to be a separate script from bin/ml-build? Could bin/ml-build and
   bin/.link-sml be merged into a single script?

2. bin/.link-sml (aka $LINK in ml-build) is run is [-r $linkargsfile] is true, with its
   arguments comming from the contents of the $linkargsfile.

3. Is .link-sml used to move the heap file generated by exportFn in ml-build invoked from
   (say) ml-ulex/build.sh to $SMLNJ/bin/.heap?

4. Note: .link-sml is "instantiated" with a fixed file path for BIN_DIR that is used 
   if $SMLNJ_HOME is not defined (or is the empty string).

5. .link-sml: runs bin/.run/run.amd64-darwin to execute the ml-ulex.amd64-darwin heap image
   that was created by the $SML command in ml-build. This image executes the body of the
   dummy/temp XYZ_XXX_0123 structure in the file $smlfile (= $pid-export.sml). The body of
   this structure executes a call of SMLofNJ.exportFn to create a heap image (named
   ml-ulex.amd64-darwin?) for the Main.main function defined in $ml-ulex/main.sml.

6. This heap image, $ml-ulex/ml-ulex.amd64-darwin, then needs to be "moved to" the 
   $SMLNJ/bin/.heap directory.  (Where is this done?)

7. Command-line Arguments: some combination of:

  @SMLrun=<runfile>  (default $RUN_DIR/run.amd64-darwin = bin/.run/run.amd64-darwin)
     => RUN = <runfile>

  SMLboot=<bootfile> (default = ?, or required arg?)
     => BOOT = <bootfile>

  SMLheap=<heapfile> (default = ?, or required?)
     => HEAP = <heapfile>

  @SMLversion => prints "$CMD 2022.1" = ".link-sml 2022.1"?

8. Where called:

  ml-build, called with arguments from the $linkargsfile = $pid-LINKARGS
    where $linkargsfile is output when runnning $SML


------------------------------------------------------------------------------------------    
7. tools/ml-lpt/ml-ulex/build.sh (shell script)  -- local build script for ml-ulex
------------------------------------------------------------------------------------------    
What happens in ml-ulex/build.sh?

This build.sh script is typical of the tool-building procedure for other tools.

This script is (assumed to be) executed with current directory:

    cwd = $SMLNJ/tools/ml-lpt/ml-ulex

a. defines variables

     CMD = $0 -- the command name, or "build.sh", used only in an error message

     ROOT = ml-ulex  -- name of current directory, used as default value of HEAP_IMAGE
     SMLNJROOT = $SMLNJ   (path ../../.. relative to current directory)
     BIN = $SMLNJROOT/bin
     LIB = $SMLNJROOT/lib

     BUILD = $BIN/ml-build -- the normal ml-build shell script
     
     (also defines SML = $BIN/sml, but this variable is not referenced)

   If the shell variable INSTALLDIR is defined in the shell environment, this can change
   where bin and lib are found and thus how $BIN and $LIB are defined.

   !!! Do we need or use this flexibility to redefine the $BIN and $LIN directories? !!!

b. processes command-line args to see if HEAP_IMAGE is specified (by option "-o")
   if not, defines

     HEAP_IMAGE = $ROOT = ml-ulex, the ml-ulex source directory
                  (or as defined by a "-o" command-line option)

c. Runs ml-build with arguments:

   -DNO_ML_ANTLR
   -DNO_ML_LEX
   -DNO_ML_YACC
   sources.cm
   Main.main
   $HEAP_IMAGE

   The first three arguments are passed on to sml by ml-build (collected as "dulist").
   ml-build binds the 3 remaining args to variables root, main, and heap, respectively.

   When ml-build is run with these arguments, it runs $SML (the "current", "local" version)
   with the following arguments:

   "-DNO_ML_ANTLR -DNO_ML_LEX -DNO_ML_YACC"  -- the -D options concatenated into $dulist
   @CMbuild        -- a magic argument causing CM (CMB?) to be invoked
   ""              -- empty $setup arg (can therefore be omited?)
   sources.cm      -- value of $root in ml-build
   $pid-export.cm  -- generated cm description file ($cmfile) for compiling the XYZ_XXX_0123
                       structure defined in the $smlfile temporary source file.
   Main.main       -- name of function to be exported by exportFn (its 2nd argument in $smlfile)
   $HEAP_IMAGE     -- name of heap file generated by exportFn (its 1st argument in $smlfile)
   $pid-BOOTLIST   -- filename used by CM (its content to be generated by CM)
   $pid-LINKARGS   -- name of file where CM _may_ write info to be passed as the arguments to
   		      bin/.link-sml.

d. Where (by whom) and with what arguments is this ml-ulex/build.sh script run?
   (Possibly by $SMLNJ/build.sh?) (similarly for the other tools)


------------------------------------------------------------------------------------------    
8. tools/ml-lpt/ml-ulex/build.sh (shell script)  -- local build script for ml-ulex
------------------------------------------------------------------------------------------    

Note that this directly invokes sml as "sml", so it will get the current "installed"
version of sml (i.e. the one found by the command "which sml"). This could cause a problem
if that sml is "broken" or otherwise inappropriate.



==========================================================================================
Summary: The ml-ulex build process


ml-ulex/build.sh + bin/ml-build together amount to defining a bunch of arguments to pass
to sml (invoking CM/CMB). They provide an (unused?) opportunity to affect some parameters
(e.g. the heap file name) through command-line arguments, or shell environment variables
(CM_PATHCONFIG).  The parameters are all strings, some of which are (native) file names.

One can imagine a simpler, more direct, one step process of defining these $SML
parameters (perhaps in ml-ulex/build.sh, or in a combined shell script).  The build.sh
files for the different tools are almost identical, differing only in 

  (1) The name of the tool's CM discription file (source.cm for ml-ulex, ml-burg.cm for ml-burg) 
      This becomes the $root parameter passed to $SML in ml-build.

  (2) The name of the function to be exported by exportFn (Main.main for ml-ulex and
      ml-burg, ExportParseGen.parseGen for ml-yacc), which becomes the second argument
      of SMLofNJ.exportFn in the generated source file ($smlfile) in ml-build.

and in the definition of the ROOT variable (the directory containing the build.sh
script: ml-ulex, ml-burg, ml-yacc, etc.).

The "outputs" of the $SML command run in (e.g.) the ml-ulex directory

  - a heap file: ./$HEAP_IMAGE.amd64-darwin = ./ml-ulex.amd64-darwin

  - a $linkargsfile: $pid-LINKARGS, where $pid is the process id of the ml-build process.

The $linkargsfile contains command-line arguments to be passed to bin/.link-sml.


------------------------------------------------------------------------------------------
scripts involved in building/installing ml-ulex
------------------------------------------------------------------------------------------

let ulex = $SMLNJ/tools/ml-lpt/ml-ulex

1. bin/build.sh ?

2. $ulex/build.sh

3. bin/ml-build

4. bin/sml

5. bin/.link-sml


==========================================================================================
Summary: the build process in general

0. The build process is too complex, too hard understand and debug when something "goes wrong".
   Also too hard to modify, extend, or re-architect. [i.e. complexity makes it "fragile"]

1. too many files and directories;
   too many .cm description files
   too many shell scripts
   shell scripts could be simplified by being more specific, less "flexible"

2. The tangled web of .cm files needs to be simplified and documented.
   .cm file dependency graph

3. There is a confusing multiplicity of places where generated binaries (and other info) are stored

4. This needs to be done before one could redesign the "architecture" of the system,
   e.g. the interactive system as a library; batch compiler as a library
   (also, a redesign of pickling based on asdl will touch a lot of stuff)

5. The formats of various ad hoc "configuration" files need to be documented
   (and how and where they are used):
     system/pathconfig, config/extrapathconfig, actions, dependencies, preloads,
     BOOTFILE, PIDMAP
     config/targets is relatively well self-documented

6. The content of, and construction of BOOTFILE files needs to be fully documented

7. Where in compiler+cm is the functionality found for dealing with:
      - pathconfigs
      - BOOTFILES, PIDMAP
   Differences/relations between predefined configuration files and "generated" configuration files.

8. Explain differences in the build processes for:
      - compiler (+cm?)
      - libraries
      - tools

9. Can CM be treated as a library/tool?
   How intimately is CM connected to the core compiler functionality?
   What compiler "hooks" or interface does it require (use)?
   The fact that CM is set up for autoloading in preloads seems to indicate that this
   may already be done.

10. To what extent can the whole build process (and all its files) be rationalized
    and streamlined?

11. What is special about the asdl tool? It seems to have several special "configuration"
    files.  Does it need special treatment, or is this just an historical artifact?

12. CM is fairly well documented for users, but we need more complete and detailed
    documentation for "maintainers". [See also my "errata" note on the CM manual.]

13. The build process is a collaboration (kind of coroutine-like) between shell scripts
    and SML code. What is the rationale for what belongs on the shell side, and what
    belongs on the SML side?  It looks to me like the shell scripts might be simplified.
    What functionality is missing on the SML side that forces the use of shell scripts?
    [In other words, what is lacking in sml as a shell? I would prefer more SML and
    less shell, myself.]


14. Nevertheless, CM is a great system that is enormously useful for SML/NJ programmers!
