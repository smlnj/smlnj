~/sml/Dev/github/smlnj/notes/install.txt  [newpp branch of smlnj]

Notes on smlnj install process and files
----------------------------------------

Trying to understand the install process in order to trouble-shoot the problem of
adding smlnj-lib/prettyprint without breaking the build process.

------------------------------------------------------------------------------------------
1. Catalog of files (involved in build?):
------------------------------------------------------------------------------------------

Note: all filenames/paths are relative to the SML/NJ ROOT directory
      (e.g. ~/sml/Dev/github/smlnj in my case, which is a GitHub clone of the newpp branch
       of the smlnj/smlnj repository)

build.sh [:shell]
  - the main (top-level) build script

config/ [:dir]
  actions [:txt/config]
  dependencies [:txt/config]
  extrapathconfig [:txt/config]
  targets [:txt/config]
  releasedate [:txt/config]
    - contents is release date (a string), e.g "August 25, 2022\n"

system/ [:dir]
  README [:txt/doc] ("Compiler Hacker's Guide to new CM...")

  cmb-make  [:shell]
  makeml    [:shell]
  installml [:shell]
  cmb-cross [:shell]
  all-cross [:shell]
  iter-make [:shell]
  testml    [:shell]  

  pathconfig [:txt/config]  (CM path definitions)
  preloads.bare [:txt/config] (autoload declarations?)
  preloads.standard [:txt/config] (autoload declarations?)
  root.cm [:CM desc]

  batchcomp.sml [:sml]
  serv.sml  [:sml]
  rserv.sml [:sml]
  tserv.sml [:sml]

  sml.bin.amd64-unix/ [:dir]
  sml.boot.amd64-unix/ [:dir] (compiled code]

system/smlnj/ [:dir]

  smlnj-lib/ [:dir]
     controls-lib.cm [:CM desc]
     pp-lib.cm [:CM desc]
     prettyprint-lib.cm [:CM desc]
     smlnj-lib.cm [:CM desc]

  cm.cm
  cm/ [:dir]
    cm.cm
      - something wierd related to pickling and sequencing
  cmb.cm
  cmb/ [:dir]

  init/ [:dir]
    init.cmi [:CM cmi]
    (24 sml files related to: initialization of (pervasiv environment?), ml-nlffi)

  installer.cm [:CM desc]
  library-install.cm 
  installer/ [:dir]
    util.cm [:CM desc]
    installer-util.sml [:sml}
      - defines "fail" function, which prints "FAILURE:" messages
    patch-file.sml [:sml}
    generic-install.sml [:sml}
      - generates error messages like
          "FAILURE: Built ml-ulex; ml-ulex.amd64-darwin still missing"
      - generates messages like
          "Library <libname> already existed in <file path>"
    library-install.sml [:sml}
    nix-install.sml [:sml}
    win-install.sml [:sml}

  internal/ [:dir]
    cm0.cm
      - appears in ../cm/cm.cm 
    cm-lib.cm [:CM desc]
    cm-sig-lib.cm [:CM desc]
      - appears in ../cm/cm.cm 

    versiontool.cm
    smlnj-version.cm
    version.sml [:sml] (defines buildData, releaseDate, version, banner)
    version.template [:sml]  (template for building version.sml)
    versiontool.sml [:sml]

    srcpath-lib.cm
    
    intsys.cm
    int-sys.sml

  compiler.cm [:CM desc]
  compiler/ [:dir]
    all.cm [:CM desc]
    amd64.cm  [:CM desc]
    amd64.sml [:sml]
    arm64.cm  [:CM desc]
    arm64.sml [:sml]
    compiler.cm [:CM desc]
    compiler.sml [:sml]
    current.cm [:CM desc]
    minimal.cm [:CM desc]
    minimal-only.cm [:CM desc]
    minimal-compiler.sml [:sml]
    
  viscomp/ [:dir]
    amd64.cm [:CM desc]
    arm64.cm [:CM desc]
    core.cm [:CM desc] 
    basics.cm [:CM desc]
    debugprof.cm [:CM desc]
    elabdata.cm [:CM desc]
    elaborate.cm [:CM desc]
    execute.cm [:CM desc]
    parser.cm [:CM desc]

  basis/ [:dir]
    ...
  asdl/ [:dir]
    ...

system/Basis/ [:dir]
  basis.cm [:CM desc]
  basis-common.cm  [:CM desc]

  Exports/ [:dir]
  TypesOnly/ [:dir]
  Implementation/ [:dir]
    - Basis source code

lib/ [:dir]
  pathconfig [:txt/config]
    - how derived? Relation to system/pathconfig and config/extrapathconfig?
    - why repeated lines?
  pp-lib.cm/ [:dir] (e.g.)
    .cm/ [:dir]
      amd64-unix/ [:dir]
        pp-lib.cm [:binary?, 69089 bytes] 
      
bin/ [:dir]
  .arch-n-opsys [:shell]
  .run-sml [:shell]
  .link-sml [:shell]
  .heap/ [:dir]
    sml.amd64-darwin [:heap image]
    ml-yacc.amd64-darwin [:heap image]
    ml-burg.amd64-darwin [:heap image]
    ...
  .run/ [:dir]
    run.amd64-darwin [:x86-64 executable]

  ml-build [:shell]  
    - script for building stand-alone programs (e.g. ml-yacc), (using SMLofNJ.exportFn)
    - documented in CM Manual, Section 15
  ml-makedepend [:shell]  
  heap2exec [:shell]  

  sml [:symlink] ( -> .run-sml) 
  ml-yacc [:symlink] ( -> .run-sml) 
  ml-burg [:symlink] ( -> .run-sml) 
  ...

[Q] Why is .link-sml hidden and ml-build not hidden?
    Is .link-sml ever used independently of ml-build?
    Does ml-build ever use other values of $LINK?

-----------
Note: where do the compiled binary files live?

(1) system/sml.boot.amd64-unix
    (binary files for the compiler itself?)
    [description of contents
     per-library binary files?]

(2) system/sml.bin.amd64-unix
    [description of contents -- redundant?
     per-source file binary files?]

(2) in .cm directories in source directories [for libraries and tools
    These .cm directories contain three subdirectories:
      - GUID/
      - SKEL/
      - amd64-unix/
    The adm64-unix subdirectory contains one binary file per
    source file, with the same names (!) as the source files.

    E.g. smlnj/smlnj-lib/PP/src/.cm
    E.g. smlnj/tools/ml-lpt/ml-ulex/.cm 
    E.g. smlnj/tools/ml-lpt/ml-ulex/BackEnds/.cm 

    Note that code in amd64-unix and GUID info in GUID will be updated
    whenever the source is recompiled, but not necessarily the SKEL
    info, which may remain unchanged (?).

[Q] Why do we need both sml.bin and sml.boot?

[Q] Is sml.bin just used to build sml.boot and is thereafter redundant?
    Note that only a tarball of an sml.boot directory is needed by the
    root build.sh script.


----------- 
NOTE: For the following assume shell variable SMLNJ refers to the root directory of the
SML/NJ source tree. For example, on my iMac,

    SMLNJ = ~/sml/Dev/github/smlnj

which is a clone of the smlnj/smlnj GitHub repository (currently on
branch newpp).
We also define

    ml-ulex = $SMLNJ/tools/ml-lpt/ml-ulex

the source directory for the ml-ulex tool.
-----------


------------------------------------------------------------------------------------------    
2. bin/build.sh  (shell script)
------------------------------------------------------------------------------------------    
What happens in bin/build.sh? (the main, or top-level build script)



---------------------
Comments, bugs, fixes

* Redundancy between complain and arguments of complain. Both printing "$cmd !!!", so
error messages start with, e.g. "./build.sh !!! ./build.sh !!! ...".
[Fixed]


------------------------------------------------------------------------------------------    
3. bin/ml-build  (shell script)
------------------------------------------------------------------------------------------    
What happens in ml-build?

Note: ml-build is "instantiated" (at some point, by build.sh?) with fixed file paths
for BIN_DIR and LIB_DIR that are used if the environment variable $SMLNJ_HOME is empty
or not defined.

a. If shell variable SMLNJ_HOME is undefined or is the empty string,
   
     BIN_DIR = $SMLNJ/bin   (using the actual value of $SMLNJ that was inserted into ml-build)
     LIB_DIR = $SMLNJ/lib

   otherwise, these are defined in terms of the value of $SMLNJ_HOME.

b. If shell variable CM_PATHCONFIG is undefined or empty it is defined by

      CM_PATHCONFIG = $LIB_DIR/pathconfig = $SMLNJ/lib/pathconfig
   
   and is exported to the shell environment.

c. defines variables

     SML = $BIN_DIR/sml
     LINK = $BIN_DIR/.link-sml
     thisscript = $0 = ml-build
     
d. defines several "temporary" file names in terms of the (current) process id (pid)

     pid = $$  (process id for this invocation of ml-build (actually named "xx"))
     smlfile = $pid-export.sml
     cmfile = $pid-export.cm
     listfile = $pid-BOOTLIST
     linkargsfile = $pid-LINKARGS

   These files are "temporary" and will be deleted in the cleanup triggered by the
   trap set up in the next step (e).

e. sets up a trap for signals 0 1 2 3 15  (what are these signals?)
   with a command to delete smlfile, etc, and generated binary files for $smlfile
   This will clean up "at the conclusion" of the script. [It does so even when there
   is a segmentation fault while running ml-build.]

f. The variable "setup" is initialized to be empty, but can be set either by an "-S" command
   line option (and its argument), or by the first arg in the 2nd phase of command line
   argument processing (step h), if there are (at least?) 4 remaining arguments.
   Such a -S setup argument is passed separately from the other sml arguments
   (-D*, -U*, -C* arguments). Why?

g. command line options processing to capture -D*, -U*, -C* options to be passed to sml
   via the "dulist" variable, and also the -S option, if any, to possibly define the setup
   variable in terms of the following (required) argument.

h. further command line options are processed to define variables (successively)

     setup  (only if there was no -S option in the previous phase of options processing)
     root   -- the cm sources file
     main   -- the name (SML qualified identifier) of the function to be exported via
               exportFn, e.g. Main.main for the ml-ulex/build.sh call of ml-build 
     heap   -- name of the heap file generated by exportFn (and passed to exportFn as its
               2nd argument

   depending on how many additional arguments are passed. There should be at least 1 arg,
   used to define root. The variables main and heap are assigned default values if there
   were not enough arguments.  The setup variable (if empty) is defined as the first
   additional argument, but only if there are (at least) 4 arguments remaining.

i. Define a dummy structure name "XYZ_XXX_0123", and use this structure name in the text
   generated for the temporary files $smlfile and $cmfile:

   contents of $smlfile:

      structure XYZ_XXX_0123 = struct val _ = SMLofNJ.exportFn ("${heap}", ${main}) end

   contents of $cmfile:

      Group structure XXY_XXX_0123 is \$/basis.cm ${root} ${smlfile}

j. invoke $SML with arguements

      $dulist     -- the -D*, -U*, -C* arguments passed to ml-build
      @CMbuild    -- the magic word to activate the desired CM (CMB?) compilation
      $setup      -- (empty when invoked from ml-ulex/build.sh)
      "$root"     -- the cm description file for the CM compilation (i.e. ml-ulex/sources.cm)
      "$cmfile"   -- the additional temporary CM file causing the compilation and execution
                     the $smlfile, resulting in the call of exportFn
      "$heap"     -- the name of the heap file generated by exportFn (1st argument)
      "$listfile" -- the BOOTLIST file for the cm compilation
      "$linkargsfile" -- a file possibly generated by the CM compilation with "linking information?"
                         to be passed to bin/.link-sml for processing (if it is created)                 

k. After $SML is run to compile the temporary file $smlfile using $cmfile, we check
   for whether $linkargsfile (= $pid-LINKARGS) is "readable" (does that imply it exists,
   or is non-empty? If it is "readable", then we invoke bin/.link-sml with its contents as
   command-line arguments. Otherwise we return the exit status of the $SML command.

l. at the end, the previously defined trap command is run (why exactly?, in response to
   which signal?), which causes the deletion of the temporary files $smlfile, $cmfile,
   $listfile, $linkargsfile, and also the deletion of files matching ".cm/*/$smlfile".
   But if the $SML command was "successful", there should remain the file $heap.
   

We should be able to preserve the temporary files and compilation result simply by
commenting out the "trap" command in ml-build. Try this for debugging.

Bug why not include the export.sml file permanently in ml-ulex, and add export.sml to the
ml-ulex sources.cm description, with its (dummy) structure exported.  The permanent export
structure could be named "ML_Ulex" or "Export" or "ExportULEX" and would replace Main in the export
list of ml-ulex/sources.cm. Then the temporary cm file $pid-cmfile would not be needed.


------------------------------------------------------------------------------------------ 
bin/sml (shell) -- the script that "runs" sml
------------------------------------------------------------------------------------------ 
What does the $SML command do?

In ml-build,

   SML = $BIN_DIR/sml = $SMLNJ/bin/sml

bin/sml is a link to bin/.run-sml.

What do the arguments do/mean where $SML is called in ml-build?

- What sml command is run when invoking $SML.
  It is the "local" one, defined by

    SML = $BIN_DIR/sml = $SMLNJ/bin/sml

What does the @CMbuild argument to $SML do?


------------------------------------------------------------------------------------------    
2. bin/.link-sml (shell script)
------------------------------------------------------------------------------------------    
What happens in .link-sml?  [and why isn't it just bin/link-sml? or bin/ml-link?]

Why does it need to be a separate script from bin/ml-build? Could bin/ml-build and
bin/.link-sml be merged into a single script?

bin/.link-sml (aka $LINK in ml-build) is run is [-r $linkargsfile] is true, with its
arguments comming from the contents of the $linkargsfile.

Is .link-sml used to move the heap file generated by exportFn in ml-build invoked from
(say) ml-ulex/build.sh to $SMLNJ/bin/.heap?

Note: .link-sml is "instantiated" with a fixed file path for BIN_DIR that is used 
  if $SMLNJ_HOME is not defined (or is the empty string).

.link-sml: runs bin/.run/run.amd64-darwin to execute the ml-ulex.amd64-darwin heap image
that was created by the $SML command in ml-build. This image executes the body of the
dummy/temp XYZ_XXX_0123 structure in the file $smlfile (= $pid-export.sml). The body of
this structure executes a call of SMLofNJ.exportFn to create a heap image (named
ml-ulex.amd64-darwin?) for the Main.main function defined in $ml-ulex/main.sml.

This heap image, $ml-ulex/ml-ulex.amd64-darwin, then needs to be "moved to" the 
$SMLNJ/bin/.heap directory.  (Where is this done?)

Command-line Arguments: some combination of:

  @SMLrun=<runfile>  (default $RUN_DIR/run.amd64-darwin = bin/.run/run.amd64-darwin)
     => RUN = <runfile>

  SMLboot=<bootfile> (default = ?, or required arg?)
     => BOOT = <bootfile>

  SMLheap=<heapfile> (default = ?, or required?)
     => HEAP = <heapfile>

  @SMLversion => prints "$CMD 2022.1" = ".link-sml 2022.1"?

Where called:

  ml-build, called with arguments from the $linkargsfile = $pid-LINKARGS

  $linkargsfile is created by runnning $SML

------------------------------------------------------------------------------------------    
3. tools/ml-lpt/ml-ulex/build.sh (shell script)  -- local build script for ml-ulex
------------------------------------------------------------------------------------------    
What happens in ml-ulex/build.sh?

This build.sh script is typical of the tool-building procedure for other tools.

This script is (assumed to be) executed with current directory:

    cwd = $SMLNJ/tools/ml-lpt/ml-ulex

a. defines variables

     CMD = $0 -- the command name, or "build.sh", used only in an error message

     ROOT = ml-ulex  -- name of current directory, used as default value of HEAP_IMAGE
     SMLNJROOT = $SMLNJ   (path ../../.. relative to current directory)
     BIN = $SMLNJROOT/bin
     LIB = $SMLNJROOT/lib

     BUILD = $BIN/ml-build -- the normal ml-build shell script
     
     (also defines SML = $BIN/sml, but this variable is not referenced)

   If the shell variable INSTALLDIR is defined in the shell environment, this can change
   where bin and lib are found and thus how $BIN and $LIB are defined.

   !!! Do we need or use this flexibility to redefine the $BIN and $LIN directories? !!!

b. processes command-line args to see if HEAP_IMAGE is specified (by option "-o")
   if not, defines

     HEAP_IMAGE = $ROOT = ml-ulex, the ml-ulex source directory
                  (or as defined by a "-o" command-line option)

c. Runs ml-build with arguments:

   -DNO_ML_ANTLR
   -DNO_ML_LEX
   -DNO_ML_YACC
   sources.cm
   Main.main
   $HEAP_IMAGE

   The first three arguments are passed on to sml by ml-build (collected as "dulist").
   ml-build binds the 3 remaining args to variables root, main, and heap, respectively.

   When ml-build is run with these arguments, it runs $SML (the "current", "local" version)
   with the following arguments:

   "-DNO_ML_ANTLR -DNO_ML_LEX -DNO_ML_YACC"  -- the -D options concatenated into $dulist
   @CMbuild        -- a magic argument causing CM (CMB?) to be invoked
   ""              -- empty $setup arg (can therefore be omited?)
   sources.cm      -- value of $root in ml-build
   $pid-export.cm  -- generated cm description file ($cmfile) for compiling the XYZ_XXX_0123
                       structure defined in the $smlfile temporary source file.
   Main.main       -- name of function to be exported by exportFn (its 2nd argument in $smlfile)
   $HEAP_IMAGE     -- name of heap file generated by exportFn (its 1st argument in $smlfile)
   $pid-BOOTLIST   -- filename used by CM (its content to be generated by CM)
   $pid-LINKARGS   -- name of file where CM _may_ write info to be passed as the arguments to
   		      bin/.link-sml.

d. Where (by whom) and with what arguments is this ml-ulex/build.sh script run?
   (Possibly by $SMLNJ/build.sh?) (similarly for the other tools)


------------------------------------------------------------------------------------------    
4. tools/ml-lpt/ml-ulex/build.sh (shell script)  -- local build script for ml-ulex
------------------------------------------------------------------------------------------    

Note that this directly invokes sml as "sml", so it will get the current "installed"
version of sml (i.e. the one found by the command "which sml"). This could cause a problem
if that sml is "broken" or otherwise inappropriate.


==========================================================================================
Summary: The ml-ulex build process


ml-ulex/build.sh + bin/ml-build together amount to defining a bunch of arguments to pass
to sml (invoking CM/CMB). They provide an (unused?) opportunity to affect some parameters
(e.g. the heap file name) through command-line arguments, or shell environment variables
(CM_PATHCONFIG).  The parameters are all strings, some of which are (native) file names.

One can imagine a simpler, more direct, one step process of defining these $SML
parameters (perhaps in ml-ulex/build.sh, or in a combined shell script).  The build.sh
files for the different tools are almost identical, differing only in 

  (1) The name of the tool's CM discription file (source.cm for ml-ulex, ml-burg.cm for ml-burg) 
      This becomes the $root parameter passed to $SML in ml-build.

  (2) The name of the function to be exported by exportFn (Main.main for ml-ulex and
      ml-burg, ExportParseGen.parseGen for ml-yacc), which becomes the second argument
      of SMLofNJ.exportFn in the generated source file ($smlfile) in ml-build.

and in the definition of the ROOT variable (the directory containing the build.sh
script: ml-ulex, ml-burg, ml-yacc, etc.).

The "outputs" of the $SML command run in (e.g.) the ml-ulex directory

  - a heap file: ./$HEAP_IMAGE.amd64-darwin = ./ml-ulex.amd64-darwin

  - a $linkargsfile: $pid-LINKARGS, where $pid is the process id of the ml-build process.

The $linkargsfile contains command-line arguments to be passed to bin/.link-sml.


------------------------------------------------------------------------------------------
scripts involved in building/installing ml-ulex
------------------------------------------------------------------------------------------

let ulex = $SMLNJ/tools/ml-lpt/ml-ulex

1. bin/build.sh ?

2. $ulex/build.sh

3. bin/ml-build

4. bin/sml

5. bin/.link-sml

