Some Questions and Observations about CM and some specific cm files.
DBM, 2023.4.24

1. Can a compiler source file access a component module of an smlnj-lib library if that library
   is not "redirected" into $smlnj/smlnj-lib/?

2. In the interactive REPL, what smlnj-lib libraries can be loaded via a CM.make call?
   And what anchor paths should be used?

3. (a) What internal compiler "components" can be loaded by (1) a user .cm file or
      (2) a call of CM.make at the interactive level, using what anchor paths?
   (b) How are these components/paths "enabled"?

5. Why do component cm files (e.g. elaborate.cm) define Groups rather than Libraries?  

4. Why do component cm files (e.g. elaborate.cm) have to access other components via
   their $smlnj/viscomp "redirects" (e.g. $smlnj/viscomp/basics.cm)?

6. What is the precise interface between the compiler and CM?

7. Would it be possible to build a stand-alone application by loading and linking
   binfiles generated by CM without going through the interactive system and using
   the top-level static/dynamic environments as "scaffolding", followed by exportML?
   If this is possible, what infrastructure would be required, and where would it be
   placed?  (presumably in the runtime) [This would provide a form of "batch" build
   functionality.] ["linkage" would still require execution, in an SML environment, of
   the "build" code generated for a module.] [relation with system/makeml, etc. scripts]

8. *Avoidance of shell scripts*. Why should we need shell scripts at all when "building
   SML"? [e.g. bin/ml-build.sh, bin/.link-sml, in particular]

9. [Project] A complete catalog of the cm files in SML/NJ and smlnj-lib, with connections
   and descriptions specifying roles or purposes and dependencies.
   An architectural map of the system from the point of view of CM.

10. Where is compiler/core.cm used/needed/imported?

      hoy$ grep "core.cm" */*.cm
      compiler/amd64.cm:	$smlnj/viscomp/core.cm
      compiler/arm64.cm:	$smlnj/viscomp/core.cm
      internal/intsys.cm:	$smlnj/viscomp/core.cm
      viscomp/core.cm:(* smlnj/viscomp/core.cm *)
      viscomp/core.cm:	group($compiler/core.cm)
      viscomp/core.cm:	$compiler/core.cm

    The Group core.cm is repackaged as a Library in
    system/smlnj/viscomp/core.cm:

    ----------------
      (*
       * This used to be called all-files.cm, then sources.cm, and even later
       * viscomp-lib.cm (at which point it became "just a library").
       * It is now reduced to the machine-independent core part of the
       * library.  Machine-dependent parts are in viscomp/<arch>.cm.
       *   M.Blume (11/1999)
       *
       * Moved to smlnj/viscomp for better path-anchor organization.
       *   M.Blume (03/2000)
       *)
      (primitive)
      Library
	      group($compiler/core.cm) 
      is
	      (* reference to our only group... *)
	      $compiler/core.cm
    ----------------

    * What is "(primitive)" for?
    * The viscomp/core.cm Library exports everything that the
      compiler/core.cm Group did, as specified by the line:

	      group($compiler/core.cm) 
      
    * Is it important that the core.cm Group be turned into a Library
      (in viscomp/core.cm)? Could the original compiler/core.cm have
      defined a library?

    * In compiler/amd64.cm, viscomp/core.cm is imported along with
      most of the other viscomp component cm files (basics, parser, elabdata,
      elaborate, execute, and viscomp/amd64.cm, which is a Library
      repackaging of backend-amd64.cm). What does core.cm contribute
      beyond these other component CM Libraries/Groups?  Possibly
      structure ConstArith? But ConstArith is not listed among the
      exported structures in core.cm.

11. What is the purpose of the cm files in system/smlnj/internal?
    Or in general, what are the differences between the three
    directories compiler, viscomp, and internal that contain
    collections of cm files?

12. General observation about "imported" CM path names.
    In the body of a .cm file, after the "is" keyword, are listed

      1. SML source files, that either define a module required by the
         files "export list" before the "is" keyword, or used in other source files.
	 (and a given module defined in a source file may be both used in other source
	 files and exported.

      2. .cm files (CM "path names"): these provide their own exported modules, which are
         (a) needed by some of the source files, or provide modules specified in the
         export list (which will be "passed through" or "re-exported"), or possibly both.

    But the CM path names are assumed to be previously compiled, and there are no assumed
    dependencies between them (although there may have been dependencies between them when
    they were being compiled).

    But looking at the body of the CM file specification, we can't easily distinguish
    between CM path names that provide "pass-through" exports, and path names that just
    provide modules needed by the Group/Library's source files.  And, since a given path
    name can provide both (even in the same modules), there can be no clear distinction
    between path names that provide export modules, and path names that provide modules
    referred to in the source files.

    Path name dependencies are "complex".

13. Groups and Libraries defined by CDFs (CM description files, i.e. .cm files) do not
    have names, or rather their names are "path names", which in fact can be reduced to
    file system path names.  So the CM "name space" is the same as the file systems "name
    space". Path anchors add a bit of abstraction? to the underlying file system name
    space.

    What if we wanted to explicity _name_ Groups and Libraries?
    If so, we would presumably refer to "imported" Groups and Libraries by their CM
    _names_ rather than file system path names (or the slightly more abstract CM path
    names starting with anchors.

    In that case, we might have something like a super module system (named collections of
    modules).

14. The Group/Library distinction seems a bit off, and the rationale seems to have shifted
    over time. (Once there were only Groups, then Libraries were introduced and partially
    took the place of Groups, and ...)

15. Why do compiler/amd64.cm and similar files export so many modules?  Who needs them?
    How and where will they be used? [Is it mainly for "visible compiler" exports to the
    top-level environment?]

16. What happens when two "member files" of a Group/Library both define the same module?
    Example: core.cm includes two member files

        CPS/main/cluster.sml
	CodeGen/cps-to-cfg/cluster.sml

    that both define a structure Cluster that is used in various files in CPS and CodeGen.
    Which definition will dominate?

    The Cluster modules have "local" users, but Cluster is not an export of core.sml.

    Shouldn't this kind of definitional ambiguity be detected and reported as an error?

    ANSWER: This is an error that is detected and reported.
    

    
    
      

      

    
    
