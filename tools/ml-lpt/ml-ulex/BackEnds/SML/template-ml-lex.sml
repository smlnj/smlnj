@header@
  = struct

    structure yyInput : sig

        type stream
        val mkStream : (int -> string) -> stream
        val fromStream : TextIO.StreamIO.instream -> stream
        val getc : stream -> (Char.char * stream) option
        val getpos : stream -> int
        val getlineNo : stream -> int
        val subtract : stream * stream -> string
        val eof : stream -> bool
        val lastWasNL : stream -> bool

      end = struct

        structure TIO = TextIO
        structure TSIO = TIO.StreamIO
        structure TPIO = TextPrimIO

        datatype stream = Stream of {
            strm : TSIO.instream,
            id : int,  (* track which streams originated
                        * from the same stream *)
            pos : int,
            lineNo : int,
            lastWasNL : bool
          }

        local
          val next = ref 0
        in
        fun nextId() = !next before (next := !next + 1)
        end

        val initPos = 2 (* ml-lex bug compatibility *)

        fun mkStream inputN = let
              val strm = TSIO.mkInstream
                           (TPIO.RD {
                                name = "lexgen",
                                chunkSize = 4096,
                                readVec = SOME inputN,
                                readArr = NONE,
                                readVecNB = NONE,
                                readArrNB = NONE,
                                block = NONE,
                                canInput = NONE,
                                avail = (fn () => NONE),
                                getPos = NONE,
                                setPos = NONE,
                                endPos = NONE,
                                verifyPos = NONE,
                                close = (fn () => ()),
                                ioDesc = NONE
                              }, "")
              in
                Stream {strm = strm, id = nextId(), pos = initPos, lineNo = 1,
                        lastWasNL = true}
              end

        fun fromStream strm = Stream {
                strm = strm, id = nextId(), pos = initPos, lineNo = 1, lastWasNL = true
              }

        fun getc (Stream {strm, pos, id, lineNo, ...}) = (case TSIO.input1 strm
              of NONE => NONE
               | SOME (c, strm') =>
                   SOME (c, Stream {
                                strm = strm',
                                pos = pos+1,
                                id = id,
                                lineNo = lineNo +
                                         (if c = #"\n" then 1 else 0),
                                lastWasNL = (c = #"\n")
                              })
             (* end case*))

        fun getpos (Stream {pos, ...}) = pos

        fun getlineNo (Stream {lineNo, ...}) = lineNo

        fun subtract (new, old) = let
              val Stream {strm = strm, pos = oldPos, id = oldId, ...} = old
              val Stream {pos = newPos, id = newId, ...} = new
              val (diff, _) = if newId = oldId andalso newPos >= oldPos
                              then TSIO.inputN (strm, newPos - oldPos)
                              else raise Fail
                                "BUG: yyInput: attempted to subtract incompatible streams"
              in
                diff
              end

        fun eof s = not (isSome (getc s))

        fun lastWasNL (Stream {lastWasNL, ...}) = lastWasNL

      end

    datatype yystart_state =
@startstates@

    structure UserDeclarations =
      struct

@userdecls@


      end

    datatype yymatch
      = yyNO_MATCH
      | yyMATCH of yyInput.stream * action * yymatch
    withtype action = yyInput.stream * yymatch -> UserDeclarations.lexresult

    local

    val yytable =
@table@

    fun mk yyins = let
        (* current start state *)
        val yyss = ref INITIAL
        fun YYBEGIN ss = (yyss := ss)
        (* current input stream *)
        val yystrm = ref yyins
        (* get one char of input *)
        val yygetc = yyInput.getc
        (* create yytext *)
        fun yymktext(strm) = yyInput.subtract (strm, !yystrm)
        open UserDeclarations
        fun lex
@args@
 = let
     fun continue() = let
            val yylastwasn = yyInput.lastWasNL (!yystrm)
            fun yystuck (yyNO_MATCH) = raise Fail "stuck state"
              | yystuck (yyMATCH (strm, action, old)) =
                  action (strm, old)
            val yypos = yyInput.getpos (!yystrm)
            val yygetlineNo = yyInput.getlineNo
            fun yyactsToMatches (strm, [],        oldMatches) = oldMatches
              | yyactsToMatches (strm, act::acts, oldMatches) =
                  yyMATCH (strm, act, yyactsToMatches (strm, acts, oldMatches))
            fun yygo actTable =
                (fn (~1, _, oldMatches) => yystuck oldMatches
                  | (curState, strm, oldMatches) => let
                      val (transitions, finals') = Vector.sub (yytable, curState)
                      val finals = List.map (fn i => Vector.sub (actTable, i)) finals'
                      fun tryfinal() =
                            yystuck (yyactsToMatches (strm, finals, oldMatches))
                      fun find (c, []) = NONE
                        | find (c, (c1, c2, s)::ts) =
                            if c1 <= c andalso c <= c2 then SOME s
                            else find (c, ts)
                      in case yygetc strm
                          of SOME(c, strm') =>
                               (case find (c, transitions)
                                 of NONE => tryfinal()
                                  | SOME n =>
                                      yygo actTable
                                        (n, strm',
                                         yyactsToMatches (strm, finals, oldMatches)))
                           | NONE => tryfinal()
                      end)
            in
@lexer@

            end
          in
            continue()
            handle IO.Io{cause, ...} => raise cause
          end
        in
          lex
        end
    in
    fun makeLexer yyinputN = mk (yyInput.mkStream yyinputN)
    end

  end
