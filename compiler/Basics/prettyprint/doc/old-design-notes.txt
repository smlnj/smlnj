File: smlnj/compiler/Basics/newpp/doc/design-notes.txt

Title: A New Prettyprinter Library for SML/NJ
Author: David MacQueen (DBM)

NOTE: This version of design-notes.txt is not up-to-date. The
maintained version is in the newpptr github repo.

Here we are describing the Pettyprinter Version 7, with some additional material about
later versions (Version 8 with multi-line measure, Version 9 with tabs).

========================================================================================== 
1. Basic Assumptions
==========================================================================================

   1 Fixed-width characters. This constraint could be relaxed to allow unicode characters
     later, with a more complicated notion of the measure of a format, and modified notions
     of "current column" and "indentation", say measuring in points rather than characters.
   2 Unbounded number of lines allowed, i.e. unlimited "vertical" space.
   3 Limited horizontal space (line width or right margin), fixed during the rendering of a format.
   4 By default, no implicit or automatic wrapping of lines at the right margin.
   5 Right margin as suggestion or target, not a hard limit, i.e., line overflow allowed.
   6 Functional or "mostly functional" implementation in a strict language (SML).
   7 No "ribbon" percentage constraint (yet; could be reintroduced in a later version).

==========================================================================================
2. Antecedents
==========================================================================================

   O = Oppen, 1980  (implicit formatting markup, inline algorithm w. bounded lookahead)
   PS = Pugh-Sinofsky (1987) (explicit formatting markup (escape sequences) in strings)
   ML = OCaml Format library => smlnj-lib/PP (Reppy)
   WL = (Hughes-) Wadler-Leijen class of pretty printers (going back to Hughes 1995, Wadler 1997)
        and including the current Hackage Prettyprinter package (version 1.7.1).
	formatting via a "Document" structure (instead of markup notation)
   PPML = pretty printing meta language from Centaur system
        Box terminology with "alignment" attributes (H, V, HV, Packed)
   CL = Christopher Lindig's OCaml/SML implementation of a strict
        version of the Wadler prettyprinter.
   NM = Norman Ramsey's prettyprinters based on PS, using "dynamic programming" to
        select the best line break to trigger

==========================================================================================
3. Objective
==========================================================================================

   A new pretty printer library for SML/NJ (to replace smlnj-lib/PP), written in SML.

   * adequate performance (we can afford "off line" algorithms that, for instance,
     might preprocess formats to "measure" them. Avoid "quadratic" behavior that might
     result from a naive translation from a lazy algorithm to a strinct version.

   * adequate expressiveness (e.g. matching WL)

   * simple, relatively predictable model and interface for writing "formatters"

   * try to eliminate "irregularities" (e.g., failure of orthogonality), such as
     an INDENT operator that doesn't apply to all format structures, or "BREAK" as
     a format that does not stand alone (doesn't make sense as an isolated, complete
     format).

==========================================================================================
4. Terminology
==========================================================================================

   "format"  -- the intermediate structure generated by the pretty printer first phase
   	        the format type is indepenent of any particular pretty printer
		(this is called a "document" in the WL family of pretty printers)

   "content" -- list of all printable strings (TEXT strings) in a format (in depth-first,
   	        right-to-left order, thus the "fringe" of the format tree)

   "layout"  -- the prescription for how to print (including newlines and indentation)
   	        produced by "rendering" a format relative to constraints like line width

   "break"   -- the thing that separates formats in a compound block and which can
   	        generated a line break or just spaces

   "trigger" -- the act of generating a newline (and associated indentation) where a
   	        soft line break occurs (in a format) due to line space limitation

   "soft break" -- conditional line break; replaced by spaces if not "triggered'		
   "hard break" -- unconditional line break

   "indentation"
             -- white space at the begining of a line, printed after any line break
                amount of indentation is normally determined by the current block
		left margin

   "block"   -- a compound form of format containing subsidiary formats and separators (breaks)
	        (called a "box" in the OCaml-SML/NJ pretty printers). The concept is
		implicit in the WL pretty printers (corresponding to the CAT/EMPTY monoid).

   "block nesting level" or "bnl"
             -- a block's nesting level is 1 more than its parents nesting level
	        the outermost block has block nesting level 0

   "line width" or "lw" (rendering)
             -- the number of characters in a line, or page width

   "current column" or "cc" (rendering):
             -- the current column = number of characters (to be) printed since the
	     	last newline

   "block left margin" or "blm" (rendering)
             -- the left margin, or indentation, of a block
	        equal to the current column when the block is "entered"

   "line space available" or "lsa" (rendering)
   	     -- the horizontal space on the current line (in characters) at a given
	        point during rendering.  Should equal lw - cc.


==========================================================================================
5. Introduction
==========================================================================================

Pretty printing, as presented here, involves a kind of markup "language" that enriches
content with information that directs the "layout" of that content on a page or screen.

In this sense it is related to markup languages like markup, HTML, and LaTeX, but whereas
those languages embed markup notations into an underlying textual content, our pretty
printing markup takes the form of a particular data structure (type format) into which
the underlying content, typically a data structure of a given type, is translated.

The content data structure is typically something like a type, a signature, a phrase in
some abstract syntax type (expression, declaration), or a phrase in a compiler intermediate
representain (IR). The process of "formatting" values of such a type involves translating
the value into a "format" data structure that is a mixture of bits of text (e.g. variable
or function or type names) and formatting structure that specifies, e.g., blocks,
conditional line breaks, indentation.

Some key ideas:

* (unformated) content = ordered sequence of strings (where the strings represent, e.g.,
  punctuation, names, operations).

  This raw sequence should, in principle, be enough to convey the inherant syntactic
  structure of the content, i.e. the formatting does not add to the meaning, and is not
  essential to the parsing the content to reveal its inherent structure. This rules out,
  e.g., languages that assign syntactic or semantic meaning to line breaks and indentation
  (such as Python and Haskell). Syntactically significant formatting is here regarded as a
  bad idea. The formatting is intended to make the structure or organization of the
  content more easily discernable (or "readable").

* grouping: some collections of contents belong together (blocks)

* breaking the presentation into multiple lines when necessary or desired helps expose
  structure (line breaks)

* indenting parts of the content to represent hierarchy or subordination also helps
  expose structure (indentation, margins)

* the formatting of the content should be consistent with the inherant syntax of
  the content, and should serve to make this structure easily discernable.


==========================================================================================
6. high-level strategy/architecture
==========================================================================================

   1.0. historically, many pretty printers were inspired by Oppen's algorithm [O, PS, ML],
   	which is very stateful and impertive, with lots of state variables and stateful
	data structures (buffers, stacks, queues).

        When doing a more functional implementation, much of this state can be converted
	into function parameters that are maintained by (sometimes) recursive function
	calls. For instance, a stack of indentation values can be replaced by
	an indentation parameter passed by a recursive function, being "saved" and
	"restored" by the normal variable binding discipline.

        Initially, for simplicity, we assume we are useing a fixed-width character set
	and we measure things in characters (e.g. line length, string length, current
	column).


   1.1. given a structure (e.g. a type representation, signature representation,
        piece of abstract syntax), say of type ty, we write a "formatter" for
	data structures of type ty:

	    formatter: ty -> format

        There will be a formatter function for each type that we want to format, and
	these can be composed, e.g. the type formatter is called from within the
	signature formatter.

	More completely

	   ty ==> format   (formatter)
	      ==> layout   (renderer (with respect to, e.g., line width constraint))
	      ==> (output) (printLayout, a trivial print function)


   1.2. Formats

        A "format" is a data structure (type) consisting of

	  (a) basic strings, which could be variable names, keywords, punctuation strings

	  (b) formatting "instructions" or "commands" or "suggestions" (i.e. markup information):
	      (1) nested "blocks" representing the hierarchical structure of the value to be
	          prettyprinted
	      (2) conditional line breaks, indicating where line-breaks could be generated when
	      	  needed to prevent print-line overflow
              (3) indentation specifications (normally applying to a block)

        Blocks have two variants
          (a) atomic blocks that consist of a single printable string ("atomic" formats)
	  (b) compound blocks consist of a sequence of (sub)blocks and markup items
	      (e.g. a list of blocks and (other) markup)

        One could also include "spacing" atomic blocks:

	  (c) atomic blocks consisting of a given number of spaces

	Blocks can have formatting "attributes" (e.g. alignment, text style?).

        The _content_ of a format is the list (in depth-first, left-to-right order) of
	the strings contained in atomic text blocks within the format.

        * Formats correspond with what Hughes and Wadler call "documents".
	  I consider the word "format" to be more descriptive of what these
	  structures are and what they are used for.

	* Terminology:
	    The "block" term was introduced by Oppen.
	    In PPML and ML, blocks are called "boxes".
	    Here we will use "block" instead of "box" for the basic structuring notion.
	    The WL pretty printers do not have a concept of block, but instead use
	    a CAT/EMPTY monoid for this purpose.

        * Block Nesting Level (bnl/BNL)
	  Since blocks can be nested, any block or subblock has an integer _block nesting level_
	  which is the count of ancestor blocks (BLOCK constructors on the path to this block).
	  This the outermost block has bln = 0, and the subformats of a block have bnl 1
	  greater than the block itself.  bln is not an intrinsic property of the block
	  itself, it is determined by the context of the block, but it is a "static",
	  i.e. structural, property of the components of a compound format.

	  Block nesting levels can be used to assign priorities to breaks (trigger the
	  break with the lowest nesting level when there are multiple breaks "available"
	  to deal with running out of line space [PS].  But this should happen _automatically_
	  with the right measuring and look-ahead policies.

       Formats have "static" properties that can be deduced solely from their structure,
       and also dynamic behaviors that are manafested during the rendering of the format.
       


   1.3 Layouts

       A physical layout of the formatted text, represented as a list of physical "lines"
       consisting of an indentation and a text (string).

           type line = {indent: int, text: string}

           type layout = line list

       where the indent component gives the number of spaces in the indenation, and the text
       component is the text occupying "rest of the line".  The text may itself contain spaces,
       but not newlines. Tabs are not allowed: the indentation and white space within the text
       should consist only of space characters.

       It is absolutely standard and obvious how to print a layout. Printing a layout is
       performed using the functions:

           printLayout : layout -> unit     -- using stdout as the target for printing
	   printLayoutToStream : layout * outstream -> unit

       In some variants of layouts, the text part of a line may be a list of
       strings (some of which are spaces), or a list of strings (or string "tokens")
       and "spacing" tokens. This may be done in order to fully preserve the strings
       (pieces of text) found in the format from which layouts are derived by rendering.
       This makes it possible to say that the format and its renderings have the same
       content. This would not be true if layouts combine text (and separator spaces)
       in forming lines.  Here is an example of this more precise notion of layout:

           datatype token
	     = Text of string
	     | Spacing of int

	   type line = {indent: int, text: token list}

	   type layout = line list

        Here a "normalized" line might be one where the token list does not begin or end
	with a Spacing. Of course, nothing prevents a Text string from containing, or
	consisting entirely of, spaces. But normally the text token list contains at least
	one string with non-whitespace characters.

	Single-line vs multi-line layouts.
	
	Layout combinations (not relevant, since rendering generates complete layouts from formats)
	  horizontal concatentation  (WL CAT operation)
	  vertical concatenation (= List append?)
	  -- correspondence or relation with format constructions

        For a given content: single-line layout is "longer" than any multi-line layout
	  for that content. [This seems obvious.]


   1.4 Format rendering

       (1)  render : format * int -> layout

       (2)  render : format * (string -> unit) * int -> unit

       Here the format is the formatted content to be physically printed (or "layed out").
       The int argument is the line width of the printing device (e.g. 80 characters, or
       the character width of a text window). Additional size constraints, like a "ribbon
       percentage", could be added later.

       The rendering process is where constraints are used to control conditional factors
       like optional line breaks.

       * Semantics of a format as a set of layouts (WL)
         Different layouts of the same format derive from different space constraints.
         All these layouts, and the format from which they derive, share the same
	 basic "content" (i.e. the strings).

	 A format and all its possible layouts have a common "content", that is,
	 the content of the format.

       * spacially, "sub-layout" associated with a block element format.
       	 composing layouts?
	 can we compose the layout of a block in terms of layouts of subblocks?
	     subblocks would need to be adjusted, or "relative" to line length constraint

         In fact, the rendering of a format is not a composition of renderings of
	 its component formats: rendering is not "compositional".

       * the rendering process generally preserves the strings in the format
       	   the strings may be combined (with spacing), e.g. to form the text part of a line
	   the strings are never subdivided or broken up

     1.4.1 Conditional rendering

        There are (at least) 3 ways that rendering is conditional on line space
	available.

	(1) soft line breaks  (BREAK (SoftLine n))

	(2) HV blocks (horizontal or vertical blocks)

	(3) TRYFLAT formats: first try flat rendering if it fits, otherwise normal
	    formatting.

        The conditional rendering behavior is controlled by space available
	just on the current line (local). It is also limited by a simple and
	conservative approach to measuring formats, i.e. flat measure.

	One could make the measure more nuanced by extending to multi-line
	renders, for instance by taking the measure of the 1st line of a
	multi-line render. But this is not easy to do, since whether a format
	renders multi-line or not is already conditional not always inherent in
	the format itself.


   1.5 Spacial assumptions: the bounding space (or "rectangle") of a block

       There is a current line (cl), and during the rendering process there is a
       _current column_ in that line (cc). The current column has range 0 <= cc < lw,
       where lw is the line width, also known as the right margin. We don't actually
       need to keep a line count, so the cl is a virtual quantity.

       The current column at the point that a block is entered becomes the block's
       left margin (blm) (wrt that rendering -- this is not a fixed attribute of
       a block).

       * All the content (printable characters) of a block occur spacially within the
       rectangle specified by the blm and the cl.  This rectangle is open-ended downward,
       in the sense that there is no fixed limit on how many lines the block may contain.
       Horizontally, the rectangle is bounded on the left by the blm, and on the right
       by the lw (line width). This policy excludes "outdents" outside of the block
       space (i.e. to the left of the blm).

       The line width constraint is not absolute (*), because text may overflow the line
       width in certain circumstances.

         (a) if the next item in a compound block is a string that does not fit on the current
	     line (i.e. within [cc, lw), then it may still be printed, resulting in printed
	     characters overflowing to the right of the right margin. [This is one
	     possible policy for handling strings that are too long, the "soft" or "flexible"
	     line width constraint. Another policy would be to truncate the string to force
	     it to fit. Another would be to "wrap" the string around to the "next"
	     physical (but not logical?) line.

       * Only the content (printable characters) of a block can appear within that block's
       space. That content includes subblocks, but the content of "sibling" blocks is excluded.


   1.6 "size/measure", look ahead, and the control of conditional breaks

       measure applies to a block
       measure in terms of single line render
       measure in terms of multi-line render
       	 e.g. size of "first line" of a multi-line render

       hierarchy: measure of a block "subsumes" measures of its subblocks
       
       measure is "flat measure", the space taken up when rendered on a single, unbounded
       line (lw = "infinity", a very large number).

       there could be other, contingent measures, such as first line measure,
       where "first line" depends on lw constraint.

       A possible additional "size constraint" could be "ribbon" percentage, where
       the ribbon percentage is the maximum percentage of a line taken up by printed text.

       One can measure a format by rendering the format (say flat rendering) and measuring
       the resulting layout.  This can be extended to measure a layout relative to a las
       figure, where the layout measure would be the "length" of the layout's first line.

       NOTE: the "group" function of WL does nothing in the measured
       format context if there are only conditional (not forced) line breaks!
       In group f = Union (flatten f, f), if the flatten f choice fits, then 
       when rendering f (even in "normal" mode), it will be rendered flat.
       In the case where f is inherently multi-line (contains forced
       line breaks), then f _should be_ rendered multi-line, but it
       could be rendered "semi-flat" by suppressing all conditional
       line breaks but still executing unconditional (hard) line breaks.  The
       flat measure of such a format would be the measure up to the
       first hard line break. If the flat measure exceeds lsa, then we
       do indeed need to render f normally, thus triggering, if possible,
       an earlier conditional break.

       So should the (flat-)measure of a format f containing a hard
       line break be the measure "up to" that line break (treating
       earlier conditional breaks as non-triggered?  In this case, we
       are measuring the maximal _first line_ of the format.
       

   1.7 alignment and indentation

       High-Level Issues:

       (1) Should "indentation" be a first-class element of a format, or
       should it be "attached to" or "an attribute of" some more basic or essential
       feature, such as a BREAK or a BLOCK. Since BLOCKS "coordinate" or "manage" line
       breaks (alignment), it seems most natural to think of indentation as a property
       (possibly null) of BLOCKS.  [We attach indentation to blocks.]

       (2) Indenting a block/doc/format means indenting the whole thing! Not just indenting
       after newlines _within_ the block. [Then lines within a block will align along
       the block left margin.]

       (3) Alignment involves the sizes of indentations and how "lines" are related
       (parallel or subsidiary). Parallel items should be at the same indentation.
       A subsidiary (child) format should be at greater indentation than the format
       (e.g. block) that it belongs to.

       * Indentation is not a _state_ variable that gets updated to increase and decrease
       	 the indentation level of certain lines. It is a _parameter_ of a recursive
	 rendering process. The current column (cc) should also be a parameter,
	 not a state variable.

       Some ideas originating in the Centaur PPML pretty printing specification language:

	 * default single line rendering

	 * multi-line rendering

	 * horizontal (H)
	     "packed" multi-line blocks (like paragraphs)

	 * vertical (V)

	 * conditional vertical (HOV)
	   horizontal if it fits, otherwise aligned vertical stacking

       General conditional rendering (WL Union and FlatAlt)

         Choosing between multiple ways of rendering the same content.

         * "flattening" [WL]

         * "measuring" multi-line layouts
	   e.g. length of text of first line?

         * see the "group" and "FlatAlt"/"flatAlt" operations of Haskell Prettyprinter [WL]
	   see also Union, which seems similar to "OR"

       Considering alignment issues as more appropriately connected with blocks, rather
       than being

       When do lines "line up" in multi-line renders?

       Manual indent, outdent as in PH
         indentation is a state variable: "device_left_margin"
       	   specifying size of indent or outdent
	 coordination of indents and outdents (cancellation of indents) is to be maintained
	   by explicit indent (\t) and outdent (b) commands in the formated text
	 indentation stack?
	   in some pretty printers, indentations are maintained in a stack, where the
	   current indentation is pushed onto the stack on entering a block, and popped
	   off and restored on leaving the block

       What happens to indentation of f2 when it is combined, horizontally
       (or horizontally concatenated) with another format f1: BLOCK[H][f1,f2]?

       Indentation is not an "inherent" attribute of a block, it is an "external"
       property imposed by an operation on the block (as for INDENT in [WL]).

       *********

       [OBS] Since an indentation command has no effect unless it occurs immediately after a
       newline, indentation could be attached to (and be the responsibility of) line
       breaks (e.g., the "offset" attribute, which should be called "indent")).

       Alternatively, indentations should be attached to a block (indented vs nonindented blocks).
       The problem is that a line break is not the right construct to take responsibility
       for managing indentation according to a policy (like vertical alignment) that might
       involve multiple line breaks and perhaps other elements (texts or blocks).

       If we have indented blocks, is indentation _always_ applied, or are the
       contexts that "suppress" or "cancel" the indentation (e.g. if there is no
       hard line break before the indented block.  Indentation in inherently something
       that only takes place immediately following an actual line break!

       What it an indentation relative to?

       Simplest idea would be to have them relative to the "current" left margin, which
       is actually the "block left margin" of the "current" (or parent) block.


       The Argument: Why indent should not be a doc/format all by itself.

         * Indent by itself is not "meaningful" as a format.

         * It should be either a "modifier" of formats or a "attribute" of certain formats
           (blocks).

         * Indentation implies a newline. Indentation in the middle of a line makes no
           sense.

         * indentations need to be coordinated or managed, e.g. to achieve vertical
       	   allignments.
	 
       Normal alignment of multiple lines in a block.
         They all align on the block left margin (= the cc of the first character).

       "Horizontal" concatentation of multi-line layouts.
         Concatentation of first lines onto last lines.       		    
         Example: H-mode rendering of three multi-line blocks

             xxxxx xxx xxx
	     xxx xxxxyyy
	             yyyy yy
		     yyyyyzzzz zzz
		          zzz zzzzz
			  zzz

           V-mode rendering of these same three multi-line blocks (aligned on the
	   parent block's blm)

             xxxxx xxx xxx
	     xxx xxxx  <HardLine>
             yyy
	     yyyy yy
	     yyyyy     <HardLine>
             zzzz zzz
	     zzz zzzzz
	     zzz
       
       The vertical mode is probably more desirable for grouping multi-line blocks.
       Of course, when aligned vertically, there is less "right-margin" pressure,
       so the x, y, and z blocks might be rendered with fewer or no line breaks.


   1.8 (line) breaks -- multi-line and single-line layouts

       High Level Issue:
       (1) Where are the (potential) line breaks? What represents them in the format structure?
       (2) Should there be a "hard" (unconditional) line break? (yes)
       (3) Should line breaks be subsidiary to some other element, like blocks? (No)

       Principle: the triggering decision for a soft break does _not_ depend on
         performing rendering. In other words, we decide whether to trigger based on
	 formats, not layouts.

       Implicit (as in Oppen) or explicit.
         * implicit separators between adjacent text strings
	 * explicit (LINE in WL, or BREAK)

       Mandatory line breaks vs conditional line breaks.
         LINE in WL considered to be the primitive form
	    suppressed (replaced by spaces) by "flattening" (post processing)

       "Triggering" of soft line breaks (when forced by space constraints)
         i.e. the "measure" of the next (following) format element to be rendered

       Attributes of conditional line breaks
         (a) number of spaces to insert at break if _not_ triggered  ("spaces")
	 (b) incremental indentation of next line if triggered  ("offset")
	 (c) "alignment" attribute, as in PS

       Indentation and blocks
         Indentation as an _attribute_ on blocks
	 Indentation as an _operation_ on blocks (NEST in [WL])

       Break "priorities"
       	 Prefer breaks at a lower bnl (block nesting level)  [PS]
	 This can happen automatically based on look-ahead and measure policies?

       Flattening: recursively blocking breaks from triggering at all bnl.
         (1) Flattening by rewriting (e.g. replacing LINE with SPACE/TEXT).
	 (2) Flattening by rendering in a "flattening mode".

       A format can be intrinsically (i.e. unconditionally) multi-line if it
       contains
         (1) (unconditioned) hard line breaks, or 
         (2) indented blocks 

       Even such an intrinsically multi-line format can be rendered as a single-line
       layout when rendering in "flattening" mode.

       Triggering criteria:
       We are at a soft break in a block, with a following format element. The decision
       about whether this soft break should be triggered could be based on:

          (1) flat layout of next format does not fit
       	  (2) 1st-line of render of next format does not fit

       Criterion (2) implies (1), but not the other way around.
       If 1st line of next format fits, but the flat next format does not fit,
       and we therefore don't trigger the current soft line break, then a break
       will definitely occur within the next format, and that break will either
       be soft or hard. If it is soft, then it is a triggered soft break at a
       greater BNL (and hence lower "priority") than the one we are considering now.

       "Block integrity" or keeping blocks together
       If a block is going to be split over multiple lines (rendered multi-line),
       we prefer to split a higher level (lower BNL) block rather than a lower-level
       or inner block. This is consistent with the triggering preference for breaks
       at lower BLN. This will normally happen automatically if we use the flat
       measure of the following block as the line fit criterion. Effectively, we
       are trying to prevent the breaking of the embedded block by breaking before it.
       
       Note: a block can begin with a newline (or immediately after a newline, since
       the newline is not regarded as a part of the block) in the case where (1) the
       1st format in the block is hard indented, or (2) the 1st format of the block is
       soft indented and the block follows a newline. [There is also the possibility of
       an sblock that begins with a HardLine separator (but this might be considered
       an "illegal" or "ill-formed" sblock).]

       Some edge cases:

       (1) a block ends with a HardLine separator followed by an empty format (EMPTY or
       TEXT ""). In this case, the next format is _not_ considered to (logically) follow a newline,
       even though it will immediately follow a newline "physically" (or "textually"?).
       This could be could occur with a vblock [..., empty], or an sblock.  There could
       also be special cases in rendering that would detect this sort of situation and
       propagate the "following newline" property past the empty format to agree with the
       actual textual layout. On the other hand, it might be useful to have as an
       invariant that no block _ends_ with a newline. This could be enforced by not
       allowing any block (including an sblock) to end in a separator.

       (2) What is the difference, in formatting behavior, between a HardLine separator
       and a hard indented block containing no formats, or just a single empty format?
	

   1.9 Composing or cascading formatters

       High Level Issue: it seems obvious that "formatters" need to be composed

       When we are formatting a compound structure, like an SML signature that includes
       subsidiary structures like types, the formatter for the compound structure will
       necessarily call formatters for constituent structures (e.g. the formatter for
       signatures will call the formatter for types).  The formats for subsidiary structures
       will be rendered as part of the rendering of the containing structure. For instance,
       the types in a signature will be translated into formats that will be part of the
       signature format, and they will not be rendered until the whole signature format
       is rendered.  So composition takes place as the level of constructing formats, not
       at the level of rendering or printing.

       When rendering the subsidiary structure, the "global" line width (or the line
       width for the parent structure), will be replaced by a local effective line width
       determined by the LSA. 


   1.10 "contextual" formats

       WL prettyprinters provide some basic constructs (COLUMN, NEST, ...) that support
       computing formats that depend on "rendering-time" factors like the current collumn
       (cc), the current indentation (ci), or the current "line space available"
       (lsa). These take a function that maps from the contextual parameters (e.g. cc) to
       a context-dependent format, which is then rendered at the point where the
       contectual format occurs. We could provide a single such construct using a function
       of all of the context numbers (cc, ci, lsa?).  lsa is probably redundant, since it
       is a function of cc and the "fixed" linewidth (lw).
       
           CONTEXT of int * int -> format

       In WL, these are used to implement other "contextual"
       formatting operations such as "align" and "hang".

       The idea is that in the middle of a format we can produce/insert a
       format that depends on the render-time context (where cc and ci are
       available).

       Another variant on contextual, or render-time formatting, are
       conditional formats where the condition is expressed in terms of
       render-time variables like cc and ci.

       In the WL Prettyprinter library, operations like "align" and "hang"
       use render-time conditions or expressions to control the "late" production
       of formats, which then immediately need to be rendered (in the same
       context, one presumes).

       How does "contextual" formatting work?
       A function that takes "rendering-time" variables like cc and ci as argument
       is used to produce a new format, which is then rendered in place of the
       CONTEXT format.
       
       These could also be called "render-time computed formats".
       The problem would be that it would not be possible to precompute their
       measure (but maybe one could give an "estimated measure"?


   1.11 Annotations or styles

       These would address display issues like character sets (e.g. Unicode), fonts,
       colors for text elements.

       For the time being, this is left as a (mostly) orthogonal concern. They would,
       however, be expected to affect rendering (e.g. calculating the length of a string).

       Initially we assume a simple fixed-width character set, so measurements are in
       units of characters (line width, current column).


==========================================================================================
7. Implementation Notes
==========================================================================================

Source files:

    layout.sml  -- defines tokens, lines, and layouts
    format.sml  -- defines formats
    render.sml  -- defines the render function
    [pp-util.sml?]

Some basic quantities (variables, parameters)

     cl : int  -- current line, a global count of lines used?

     lw : int  -- line width, aka right margin (assumed fixed for a given render)
                  passed as an initial parameter to the render function

     cc : int  -- current collumn, maintained during the rendering process

     ci : int  -- current indentation (indentation at the current block)

     lsa : int -- line space available, normally equal to lw - cc, determined at
     	          entry to a new block (becomes the local "line width")

     blm : int -- block left margin = the cc when the block is entered

     The pair (cl, cc) could be considered the discrete, two-dimentional
     "origin" or "root" of a block (where cl is the "current line number" when
     the block starts or is entered).

     ci is always equal to the blm of the current, innermost block, since
     "indentation" is an attribute belonging to blocks. ci would not change
     until one entered a new (indented or not) block, where a new blm is defined
     for that block. So ci is in fact redundant.

1. Flat rendering: rendering a format on a single line, without line breaks

   One can "flatten" a fmt, replacing hard and soft line breaks with spaces
   and removing the indenting property of indented blocks. Then the ordinary
   rendering function will render the resulting flat format on a single line.

      flatten : fmt -> fmt

   Alternatively, we could

     (a) recursively set block mode values to H throughout the format structure
     (b) pass the rendering function a "flat-mode" boolean parameter that can suppress
         triggering all breaks, or alternatively define a flat_render function that
	 does this:

	 flat_render : fmt -> layout

   The measure function measures the "span" of a fmt as though it was rendered
   flat.

2. pre-measuring formats (memoizing block measure)

   Translate from the basic format type to a "measured format" type that includes
   a "size" for each block.

   Assign the spaces field of a BREAK as the size of the break, which assumes that
   breaks will not be triggered.

   It is possible that the formatting function itself could produce measured formats,
   avoiding the need for a "post-processing" translation from a base format to a
   measured format.

3. "first-line" measuring.

   In the context of line available space, predict the length of just the first line of
   the layout produced by rendering a (next) block. This would be the measure of the
   whole block if the lsa allows it to be rendered flat, or the measure up to whichever
   break is triggered by the lsa.  Does this mean we need to perform rendering to determine
   where the first line break occurs?  Looks like it does. Hence (4).

   The first-line measure of a format depends on the context constraints (lsa), and is not
   an intrinsic property of the format.

       flm : format * int -> int    -- "first-line measure of format wrt space

       flm (f, s) = let val layout = render (f, s)
                     in length (hd layout)
		    end

   There is a shortcut way of calculating flm: scan for breaks while maintaining the
   measure "so far" up to each break, and stop when the partial measure exceeds(???)
   the space s -- or really back up to the last break _before_ the space is exceeded!
   But what happens if the space is exceeded before the first break is reached? This
   would mean that even the first line is too big to fit, so we have line overflow.

4. _predicting_ which break will be triggered in advance
   Allows predicting the first line of a layout
   Interaction with current indentation? Or using cc?

5. premeasuring "fit"
   We could say a render "fails", by running out of space and then backtrack to
   render differently or render a different format.  But instead, we use measuring
   and "look-ahead" (on element?) to predetermine whether a render will succeed.

   We can always calculate the (flat) measure of a format, or we can memoize the
   measure in the format data structure, yielding an "mformat" (measured format).

6. fits predicate  -- this is trivial, since we can measure formats

       fits: format * int -> bool

       fits (f, s) = measure f <= s

   By default we use "flat" measure, the length of the 1-line layout with no line
   breaks allowed, but other more complicated ways of "statically" (pre-render)
   measuring formats are possible (e.g. 1st-line measure for multi-line layouts).

7. Conditional formatting

   The idea of trying one format if it "works", and otherwise trying another.

   * Simple variant: OR  (alternatively IFFITS?)

         OR (f1, f2)

     Rendering this OR format first tries to fit f1, and if that does not fit, it does
     f2 (whether or not it fits?).

     (1) it is assumed that f1 and f2 have the _same_ content
	 so the same content will be rendered whether f1 or f2 is chosen =>
 	 the flat renders of f1 and f2 will be the "same" one-line layout
	 
     (2) it is assumed that f1 is "flatter" or "bigger" (has a larger measure) than f2,
	 so that f2 has a better chance of fitting than f1

	 But it may just be that we render f1 in "flatten" mode, while f2 is allowed
	 to trigger line breaks.  f1 and f2 may be the same format!

         Or f1 may be the "flattened" version of f2 (as in Wadler's group operator).

   * FlatAlt operation from current Haskell Prettyprinter (WL variant) -- see below.

8. determinism of rendering

   given the lw/lsa constraint, rendering should be deterministic: only one possible layout could
   be returned as the result of rendering (f, lsa).

9. Which parameters?  current column (cc) vs line space available (lsa)

   The current column (cc) and line space available are defineable in terms of each other
   using the fixed (per render) line width (lw):

       lsa = lw - cc

       cc = lw - lsa

   Which is the most effective parameter, or does it matter?

==========================================================================================
Function of Union, FlatAlt, group in Haskell Prettyprinter (and variants)
==========================================================================================

This relates to the way WL family prettyprinters handle conditional rendering.

* A main difference is that unconditional line breaks (LINE) are the default case.
These then must be "selectively" suppressed by functions like "group" and by the
use (in 1.7.1) of FlatAlt.

    group f = Union (flatten f, f)    -- 1.2.1 and original Wadler version

If flatten f fits, render it, otherwise render f (presumably with triggered line breaks)

where a Union (f1, f2) format is rendered as f1 if it fits, and otherwise as f2. f1 and f2
must have the same content, and it is "assumed" that f2 is "narrower" than f1, i.e.
if f1 fits, the f2 would also fit.

On problem with Union is that there is no way to enforce the implied requirement that
f1 and f2 have the same content (presumably with different formatting of that content).
This requirement must be satisfied by the format (document in WL) builder.

In the WL Prettyprinter 1.7.1, a second "conditional" format constructor, FlatAlt is
introduced that seems to "overlap" with Union, but in the case of FlatAlt (f1, f2),
f1 is assumed to be the "narrower" format. Then the group function is defined in terms
of a complicated interaction between FlatAlt, Union, and the flatten operation.


==========================================================================================
8. Interface
==========================================================================================

What should be exposed? Which types should be abstract?

Note that we are primarily concerned with constructing formats, and it is not clear
when we might need to "destruct" formats or "test" them, except that we do need to
"measure" formats (but perhaps only internally).

signature NEW_PP
structure NewPP : NEW_PP

Types:

   format (abstract?) 
   mode (concrete; H, V, P, HV)  [dropped]
   separator (concrete: SoftLine, HardLine, Spaces) 
   element (block elements; concrete; BREAK, FMT)
   [block record? -- no, maintain abstraction wrt format representation]

* basic format building operations

  val text : string -> fmt

  val mkBlock : mode * int option * element list -> fmt

  val mkHBlock : fmt list -> fmt   (* Space 1 separators implicit *)
  val mkVBlock : fmt list -> fmt   (* HardLine separators implicit *)
  val mkPBlock : fmt list -> fmt   (* SoftLine 1 separators implicit *)
  
  val separate : separator * fmt list -> fmt  (* or element list? *)
      (* interleave the separator between fmt elements in order to build
       * an elements list for a block. *)

* conditional formats

  val measure : fmt -> int  (* flat measure *)

  val tryFlat : fmt -> fmt
      (* if the fmt fits flat, then render it flat, otherwise normal render *)

  (* val alt : fmt * fmt -> fmt    (* args have same content *) *)

* rendering and printing

  val render : int -> fmt -> layout (* int arg is line width *)

  (* val flatRender : fmt -> layout]  (* render with no line breaks *) *)

  val printFmt : fmt -> unit        (* printing to stdOut *) 
  
* some basic formats

  val comma : fmt
  val colon : fmt
  val semicolon : fmt
------------------------------------------------------------------------------------------

signature NEW_PPUTIL
structure NewPPUtil : NEW_PPUTIL

==========================================================================================
9. NewPP revision 2
==========================================================================================
Files: pp/new/newpp2.{sig, sml} 

Changes:

(1) drop the mode type and let separators control the different modes, along with
    specialized block constructors. Thus mode is expressed through the choice of standard,
    implicit subformat separators.

      SBLOCK - special blocks with explicit separators between subformats
      	       allowing for ad hoc use of possibly heterogeneous separators (type element)
      HBLOCK - horizontal block with Space 1 separators
      VBLOCK - with HardLine separators
      PBLOCK - with SoftLine 1 separators
      HVBLOCK - H mode or V mode depending on flat fit of the block

(2) Indentation remains an orthogonal attribute of blocks

(3) Implicit HardLine break at the beginning of an indented block is suppressed
    if the block follows a newline+indent (in which case it is superfluous).

--------------------------------------------------------------------------------
(* newpp2.sig *)

(* The signature for the new pretty printer, Version 2. *)

signature NEW_PP =
sig

(* Types: *)

   type fmt 
   type layout

  (* separator: used to explicitly (SEP elements in SBLOCKs) or implicitly (the
   * other styles of blocks) separate the fmt elements of a block and control where
   * line breaks can occur. separators are _not_, and do not contain, content. *)

  datatype separator
    = HardLine  (* hard line break, rendered as newline + (default, blm) indentation *)
    | SoftLine of int  (* soft line break; rendered to n >= 0 spaces (S n) when not triggered *)
    | Space of int  (* rendered as n >= 0 spaces *)

  (* element: elements of a compound block, consisting of "sub-formats" (FMT), usually 
   * interleaved with separators (SEP).
   * In a "normal" block the separators would occur only _between_ the FMT elements, and only
   * one separator would be used between any two FMT elements. *)

  datatype element
    = SEP of separator
    | FMT of fmt

(* Basic format building operations: *)

  val text : string -> fmt

  val mkSBlock : element list * int option -> fmt
  val mkHBlock : fmt list * int option -> fmt   (* implicit Space 1 separators *)
  val mkVBlock : fmt list * int option -> fmt   (* implicit HardLine separators *)
  val mkPBlock : fmt list * int option -> fmt   (* implicit SoftLine 1 implicit *)
  
(* Conditional formats: *)

  val measure : fmt -> int  (* flat measure, by default *)

  val tryFlat : fmt -> fmt
      (* if the fmt fits flat, then render it flat, otherwise render it normally *)

  val alt : fmt * fmt -> fmt    (* args may not have the same content! *)

(* Rendering and printing:  *)

  val render : fmt * int -> layout (* int arg is line width *)

  val printFmt : int -> fmt -> unit   (* printing to stdOut *) 
  val printFmt' : fmt -> int -> unit

(* Some basic formats: *)

  val comma : fmt
  val colon : fmt
  val semicolon : fmt

  val cat : fmt * fmt -> fmt
  (* combinds formats in a P (packed) block *)

end (* signature NEWPP *)
--------------------------------------------------------------------------------

==========================================================================================
10. Additional raw notes on the (revised) Lindig pretty printer
==========================================================================================

Old File:  (~/sml/Dev/pp/Ramsey/Wadler-Lindig/lindig0.sml)

Paper:
  Christian Lindig, "Strictly Pretty", unpublished, March, 2000
  [includes partial OCaml source code]

Lindig's strict variant of the Wadler prettyprinter (from Norman Ramsey):

* What should indentation be attached to? What does it do?

Indentation affects what happens at a break.  A break element
of a block should, when triggered, cause a newline to be emitted
and the associated indentation should be to the "block left margin"
of the current block.

How do we determine the BLM of a block?

(1) by default, it is the cc where the block begins.
(2) it can be increased by an amount specified <where?>. But how
does this physically affect the (origin) position of the block?
In particular, does a specified indentation bump (always positive)
affect the 1st line of the block (if multi-line), or the
position of the block if rendered on a single line. Or does it
only affect triggered line breaks within the block?

And what can we do if we want an entire block to be indented?
Make sure that it is immediately preceded by a line break.

So should the incremental indentation be an attribute of the block?
Which would be applied at the block entrance following the immediately
preceding line break?  E.g.

    LO1:
    ...xxxxxx<LB>
       ..aaaa
       ..bbb
       ..ccccc

where the enclosing block as BLM 3, and the block after the <LB>
has indentation 2, and the new block has BLM 5

If there wasn't any line break preceding the block it would layout
as

    LO2:
    ...xxxxxxaaaa
	     ..bbb
	     ..cccccc

where the block entry would a the first "a", and the block's BLM would
be (3 (inherited BLM) + 6 (size "xxxxxx") + 2 (block indent)) = 11.
The first character of the block would be at cc = 9, which is less
than a BLM of 11.

Another approach would be to say that if a block has a positive
indentation, then there is an implicit <LB> introduced just
before the break, producing layout LO1. This could be dependent
of the block's break mode, e.g. may not make sense if break mode is H.

Or perhaps there should be a rule that all blocks must be preceded
by a (conditional) break. Or this just for "indented" blocks.

* Principle: the BLM of an "indented" block includes its indentation
(relative to its parent BLM (after a line break), or its initial cc.

Indentation of block => a line break precedes the block?

* Principle: indentation is a property of a block, not of any
  particular line break, and not a separate specification operation
  on any generic format element (i.e. something that could be
  applied inappropriately to a TEXT item, or that could be applied
  repeatedly, like INDENT(x, INDENT(y, d)) ). 

[There should always be a current block, even if supplied by default].


* block "separators" (i.e. breaks separating doc elements)

Commonly, the essential elements of a block are its subblocs (doc
elements), which may be either atomic (TEXT) or compound (BLOCK).
To support formatting, these doc elements are separated by breaks
(hard or soft) that provide opportunities for rendering to produce
multi-line layouts (if necessary, or desired). There could be another
form of break or separator representing white space (a number of
spaces) that could be used when newlines are not expected or wanted
between the subblocks.

There may be cases where we want multiple adjacent doc elements
without separators (though multiple adjacent TEXT docs can be
amalgamated into one). Similarly, there may be cases where we want
multiple adjacent separators (e.g. to produce blank lines in a
layout). Is is not clear why we would ever want multiple adjacent
soft breaks, but in horizontal mode these would translate to spaces
and could also be amalgamated into single ones.

For H aligned blocks, the default semantics of the break separators
is as spaces, while for V aligned blocks, the default semantics of
separators (BREAKS) is as hard line breaks.

We could therefore leave out the explicit separators for H and V
aligned BLOCKS, and have them be "implied" between the DOC elements.
Again, having them be explicit elements allows for producing blank
layouts in the V mode.

Q: What happens when a block has alignment mode H and also contains
hard line break separators.

* multi- and single-line layouts

Single-line layouts may the the desired defaults for small layouts,
but multi-line layouts may also be the preferred layout in many cases,
so producing a multi-line layout is not a failure or suboptimal outcome.



==========================================================================================
11. NewPP, Version 7 (memoized block measures)
==========================================================================================

BLOCK and SBLOCK include a measure field that is calculated when the
block is constructed.

--------------- 
datatype format (* aka "format" *)
  = TEXT  of string
      (* unique form of atomic doc *)
  | SBLOCK of {elements: element list, bindent: bindent, measure: int}
      (* "special" or "ad hoc" block with explicit separator (SEP) elements mixed with format (FMT) elements *)
  | BLOCK of {formats: format list, separator: separator, bindent: bindent, measure: int}
      (* "normal" blocks, where alignment (H, V, P) is determined by the choice of the separator *)
  | TRYFLAT of format
      (* conditional rendering as flat if the format "fits", otherwise render normally *)
  | ALT of format * format
      (* format1 if it fits, otherwise format2. formats not constrained to have same content! *)
---------------

1. What should the measure of indented blocks be (since they follow or
   start with a hard newline)?

2. What should the measure of an SBLOCK be if it includes HardLine
   separators?

3. What should be the measure of a vblock, with implicit HardLine separators?

In all of these cases, we have two choices:

1. Ignore the HardLine separators and calculate the measure (as usual)
   on the flattened version of the format, where HardLine separators
   are treated as (Space 1) separators.

2. Calculate the measure based on the "first line" of the multi-line
   format/layout (recursively).  This would mean that a SoftLine
   separator preceding the format would not be triggered, since the
   1st line of the following format may fit, even though the flattened
   following format would not. This in turn would violate the "least
   BNL" priority rule for SoftLines, unless we modify that rule to relate
   only to SoftLine separators, and assume it does not apply when the
   following separator is a HardLine.

Another way of putting it is that in the presence of HardLine
separators in SBLOCKs, and their implicit occurrences in vblocks and indented
blocks, we could truncate the measurement of the following block at
the end of its 1st line when it was (statically) known to be a
multiline block.

A renderer using this "stricter" measure of format span would be more
"liberal" with line space, allowing it to be filled with 1st lines of
explicitly (statically) multi-line formats.

This policy might be implemented in an experimental Version 8. (8X)
   
Examples illustrating utility are needed.

   
==========================================================================================
12. NewPP, Speculative Feature: Tabs
==========================================================================================

Tab stops and tabbing might provide some of the functionality that WL
provides via render-time constructed documents (formats).

1 First version: single tabs

You could have two new format constructors:

    SETTAB
    TAB

When the SETTAB is rendered, the cc becomes the current unique tab
stop (variable ts). This tab stop value would be propagated forward through
subsequent rendering. Subsequent SETTAB constructors would "override"
any previous SETTABS (i.e. would reset the ts variable).

When the TAB is rendered, (sp - cc) spaces would be emitted, but
only if sp - cc > 0.

SETTAB and TAB formats would be treated as pseudo-separators.

Note that a tab could be "performed" only when the cc is left of (less
than) the current ts.  We could only tab forward.

The ts variable could be of type int option, where NONE means no tab
stop has been set.

Unlike cc which is reset after any newline (hard or soft), the ts
variable would retain its value across newlines, since the only whay
tabbing could have an effect is when GOTAB occurs on a line subsequent
to the SETTAB.

SETTAB would have no impact on format measuring, and GOTAB might be
treated as (Space 1) for measuring, since GOTAB would always emit at
least one space.

NOTE: the tab setting, if any, is local to a block, and is not
"accessible" to ancestor or descendent blocks (though they may have
their own tab stop set.  So a TAB in a block will go to _the_ tab stop
previously set by SETTAB in the same block.

EXAMPLES: Need examples of the use of single tabbing in formats.


2. Second version: multiple tabs?
   
One could possibly have a "queue" of tab stops set by successive
SETTABS, again within a given block and "private" to that block. Then
successive TABs would go to successive _accessible_ tab stops kept in
that tab stop "queue" (not really a queue, but a list/sequence with oldest
first elements. [DEFN: A tab stop is "accessible" if it is to the right of
the cc (a render-time property).] When rendering a TAB, to target tab
stop would be the first one in this "queue" that was "accessible".

Another possibility would be to allow multiple explicit tab settings,
say a tab every 8 characters. These settings then would be static with
respect to rendering, and a TAB would go to the next accessible tab
stop in this fixed sequence. One problem with this, is that it might
be difficult to tell which tab stop a given TAB will go to when
rendered, since that would depend on the value of cc when the TAB is
rendered.

EXAMPLES: need examples for these features as well.


==========================================================================================
13. Multi-line formats, layouts, and measure.
==========================================================================================

Defn: A format is _single-line_ if it would be rendered without line
breaks on an infinite line (i.e. with lineWidth (lw) = infinity).

A format that contains only SoftLine separators or softIndents (and
hence no vblocks) at any level of nesting will be a single-line
format.

Defn: A format that would be rendered on multiple lines (or rendered
to a multi-line layout) even on an infinite line, is a (static)
_multi-line_ format.

A format that contains a HardLine separator (including nontrivial vblocks) or a hard
indented block (bindent = HI) will be a multi-line format.

Note that a single-line format (that contains at least one SoftLine
separator) can sometimes be rendered to a multi-line layout because of
line-space pressure (limited line space, or lw - cc).

A flattened format is one where HardLine and SoftLine separators are
rendered unconditionally as single spaces, and newlines for indented blocks
are also ignored (all blocks are treated as though they had bindent = NI).
This flattening can be achieved either as

   (1) a transformation of the format data structure that replaces
   HardLine and SoftLine separators and sets bindent = NI in all
   blocks, or

   (2) a flat rendering mode, where the effect of flattening is
   implemented on the fly during rendering (a flatRender function,
   as in NewPP).
   
NOTE: for indented blocks, flat measure does not allow for associated newlines,
but it might nevertheless take the associated indentation (n for SI n, HI n) into
account, but perhaps only for hard indented blocks.

Our basic measure function treats a format as though it has been
flattened and returns its span when rendered on one infinite line,
suppressing all line breaks. This is called flat measure.


* Multi-line measure

A "Static" property of a format is one that can be determined without
rendering the format, and hence based simply on the format data structure.

If a format is statically multi-line, and hence contains HardLine
separators and/or hard-indented blocks, we can statically break down
the format into "static" lines, where such a line starts after each
HardLine separator or at the beginning of each hard-indented block.

These static lines can each be measured using the usual flat measure.
A static single-line format would consist of only one static line,
whose measure would be the same as the flat measure of the format.

The number of static lines in a static multi-line format is fixed
and is a static property.

Defn: The (static) multi-line measure of a format is the _maximum_ of
the measures of its static lines.

Question: How does this effect the result of rendering formats?

  (1) The line-space pressure will be lowered, leading to:

  (2) In general, fewer SoftLine separators (and hence
      soft-indentations) may be triggered.
  
  (3) In general, layout lines may be longer.

These effects might be countered by introducing a ribbon percentage
constraint that would have the effect of limiting the length of lines.

When calculating the "measure" of a static line (delineated by
HardLine separators or hard indented blocks (at the end)), we count
an indented block at the beginning of a line as its measure plus its
(incremental) indentation. In other words, the measure of a static
line includes any indentation associated with its initial format, if
that initial format is an indented block.

A multi-line measure must be "context-insensitive", for instance independent
of whether a format follows a newline (which can affect soft indentation).
This is because formats may be defined in relative isolation and later
combined into larger formats that determine their "context". But if we
want to memoize the measure when the format is constructed, we do not
have access to later contexts, and there may also be multiple contexts into
which a format is inserted. So the context (e.g. preceding newline) is not
intrinsic to the format, but the measure should be. Similarly, we don't have
access to render-time values like the line space available, so we can't
make any assumption about whether soft line breaks will be triggered. The
safe policy is therefore to assume during measurement that soft line breaks are
not triggered. [see new8/multimeasure.sml]


* Horizontal concatenation of multi-line formats

  When multi-line formats are horizontally concatentated, each successive
  layout starts at the end of the last line of the previous layout (with possible
  spacing).

  Example: 4 multi-line format layouts (la, lb, lc, ld). We assume here that they are statically
    multi-line and do not involve any triggered soft line breaks.

     la: aaaaaa aaa
	 aaaaa
	 aaaaaaa aaaa aaaa

     lb: bbb bbbbb
	 bbbb bbb bbbbb bb
	 bb bbb

     lc: ccccc ccccc ccccc cc
	 ccc ccccc cc
	 cccccccccccc ccc cc

     ld: dddd
	 ddd ddd ddd
	 dddd dd d
	 ddd ddd


     Combining these formats in an _echelon_ formation produces:

	 aaaaaa aaa
	 aaaaa
	 aaaaaaa aaaa aaaa
	                   bbb bbbbb
			   bbbb bbb bbbbb bb
			   bb bbb            
                                             ccccc ccccc ccccc cc
					     ccc ccccc cc
					     cccccccccccc ccc cc  
                                                                  dddd
								  ddd ddd ddd
								  dddd dd d
								  ddd ddd

     Here each of the component layouts is indented on its own line so that it lays fully
     to the right of the previous layout (with 1 space or column separating them).

     Horizontally concatenating these layouts, hblock style, with 1 space between layouts,
     yields a kind of "tight" echelon, or "staggered" combined layout:

	 aaaaaa aaa
	 aaaaa
	 aaaaaaa aaaa aaaa bbb bbbbb
			   bbbb bbb bbbbb bb
			   bb bbb ccccc ccccc ccccc cc
				  ccc ccccc cc
				  cccccccccccc ccc cc dddd
						      ddd ddd ddd
						      dddd dd d
						      ddd ddd

     This staggered, step-like layout is a consequence of the fact that once a newline has
     occurred, we cannot get back to the previous line(s) to continue printing on them.
     The first line of the next layout starts (with spacing) at the end of the last line
     of the previous layout, even if it is not the longest line of the layout.
     
     Another possible formation would be the following "overlapping" echelon layout, where
     the last line of one layout and the first line of the following layout are on the
     same line.

	 aaaaaa aaa
	 aaaaa
	 aaaaaaa aaaa aaaa bbb bbbbb
			   bbbb bbb bbbbb bb
			   bb bbb            ccccc ccccc ccccc cc
					     ccc ccccc cc
					     cccccccccccc ccc cc  dddd
								  ddd ddd ddd
								  dddd dd d
								  ddd ddd

     Here the starting position of the next layout is determined by the _longest_ line of
     the previous layouts rather than the last lines of those layouts. To produce this we
     would have to keep track of a layouts "maximum width" (column of right-most printed
     character) or the length of its longest line, presumably with both soft and hard line
     breaks. This looks like "indenting" successive layouts, but to a position on the
     current line, without inserting a new line.

     The multi-line measure function actually gives the width of this layout (or the
     echelon layout above) as the width estimate (measure) of the hblock concatenation.
     Note that this estimate is conservative, in that it will always exceed the actual
     width of the (hblock-style) combined layout.
     
     A flattened (or non-echelon) concatenated layout like the following does not seem feasible,
     and would probably not be desirable.

	 aaaaaa aaa        bbb bbbbb         ccccc ccccc ccccc cc dddd
	 aaaaa             bbbb bbb bbbbb bb ccc ccccc cc         ddd ddd ddd
	 aaaaaaa aaaa aaaa bb bbb            cccccccccccc ccc cc  dddd dd d
								  ddd ddd

     But in general, it seems that horizontal concatenation of multi-line layouts is
     something to be avoided. The rendered length of lines in a multi-line layout is
     another quantity that would only be available at render time. It is not a static
     attribute of a format.

 
==========================================================================================
14. Functorization of Render and NewPP wrt measure
==========================================================================================

We can pass the desired measure as a parameter structure to functorized versions of Render
(RenderFn) and NewPP (NewPPFn). This makes it easier to experiment with alternative
format measures, like multi-line measure.

But there is a problem. Some constructs, like FLAT, need to use the flat measure, even
if we are using multi-line measure as the default. To solve this problem, (1) we could
also provide the flat measure as a "resource" feature available where needed, or (2) we
could change the semantics of FLAT (e.g. "try whatever is the default measure").  We
run into problems if we want to use memoization to speed up the computation of a format's
measure.  Do we need to memoize _both_ the flat measure and the "default" measure, which
might be different or might be the same as the flat measure. It looks like we do.

There is also a problem when more than one measure are used together, such as flat measure
and multi-line measure, and we want to memoize the measures (as we must do for
efficiency). We could memoize both flat measure and a second measure, which would be
either flat measure again, or a different measure like multi-line measure. This would
be a bit cumbersome. Flat measure seems must be available to support the FLAT format
constructor and the tryFlat function that is based on it.



==========================================================================================
15. Edge cases in the design, and related issues
==========================================================================================

1. FLAT is idempotent: FLAT (FLAT fmt) == fmt.

2. What happens when we nest indentations, as in

     hardIndent 2 (hardIndent 3 fmt)

   This should be quasi-idempotent, in the sense that the newlines
   coalesce and the indentation (deltas) accumulate. So this should be
   the same as

     hardIndent (5, fmt)

   Thus

     hardIndent m (hardIndent n fmt) = hardIndent (m+n) fmt

   But what about various combinations of hard and soft indentations?

     hardIndent 2 (softIndent 3 fmt) =?= hardIndent 5 fmt

     softIndent 2 (hardIndent 3 fmt) =?= softIndent 5 fmt

     softIndent 2 (softIndent 3 fmt) =?= softIndent 5 fmt

3, alt (fmt, fmt) = fmt

4. The various xcat binary combinators are all associative.

5. Indentation is not "algebraic", but softIndent is "conditional".


==========================================================================================
16. Older design notes
==========================================================================================

Old file: ~/Dropbox/smlnj/pp/design.txt

Notes on Prettyprinter design

* The purpose of a (this new) prettyprinter is to print (or serialize) a datastructure, such as
  a type or an abstract syntax phrase, with _formatting_, i.e. use of newlines and indentation
  so that the printed layout reflects the structure of the data, making its print representation
  more readable.

* The pretty printer should be as "declarative" as possible, given that formats have to be
  _designed_ in general.  There is no canonical homomorphism from given data structures to "formats".
  (This is the goal of a prettyprinting "algebra").

* actual layout (the end product) is determined by the interaction of a format specification with
  constraints, such as line width, and possibly a ribbon percentage.

* prettyprinting (in this case) is performed in two/three steps:

  (1) translate the datastructure to be prettyprinted into a prettyprint "format" structure (WL "document").
  (2) render the document into a "layout" under constraints (e.g. line width, "ribbon" width)
  (3) print (output) the layout on a character-base output "device" (e.g stdout)

  Defn: a _layout_ is a concrete specification of a formated text in terms of separate lines,
  	where a line consists of indentation followed by text items (e.g. strings) with separators
	(e.g. white space, "punctuation").
    
    data structure  ==>    (prettyprinting, or "formatting")
       pp document  ==>    (rendering)
          layout    ==>    (printing, analagous to "layoutToString" in wadler4.sml)
	     formatted text  (or simply a string that contains the formatting characters)

* Formatting consists of

  (1) line breaks (newline characters) to break up the layout when it does not fit on a line
      - line breaks can be conditional. They can be "triggered" by space constraints imposed by
        a finite line width (right margin).
      - a conditional line break that is not needed (not triggered by space constraint) can be
      	rendered as a number of spaces, typically used as separators between pieces of printed text.
      - conditional line breaks may also carry a "local" indentation specifcation that is applied
      	as additional indentation on the following line if and only if the break is triggered.
      - unconditional ("forced") line breaks may also be included. But how do these "disrupt" to
        behaviour of the more conditional formatting?
 
  (2) indentation occurs at the beginning of "new" lines.
      - indentation has no meaning or effect within a given line, i.e. _between_ items that are
        printed on the same line.
      - indentations can be specifed as an attribute of 
      - "structural" indentation rather than "ad hoc" indentation, say by modifying an indentation state
        variable. (example: WL INDENT term constructor).

  (3) alignment
      - by default, structures are formatted on a single line, with items "concatenated" horizontally
      - when line breaks must occur, formatting of items requiring multiple lines may be in 
        one of two modes:
          -- "packed" (inconsistent breaks), or
          -- (vertically) "aligned" (consistent breaks).
      - the choice between horizontal layout and vertical may be conditioned on (horizontal)
        space available.

  (4) alternative treatment of indentation as part of a "print device" state that can be manipulated,
      e.g. by assignment (Pugh-Sinofsky).

  (5) two approaches to new breaks
      - hard line breaks that can be "suppressed" by a flatten operaion (WL)
      - soft line breaks that are only triggered by lack of (horizontal) space (Oppen, etc.)
      - in either case, when line breaks are suppressed or not triggered, they are normally
        replaced by spaces (0, 1 or more) (could also be replaced by text, e.g. ", ")
        If a block does not fit, one of _its_ line breaks is triggered, not a line break
	belonging to one of its subblocks [block look ahead]


* Space constraints

  (1) horizontal space available is limited by the maximum width of a line (line width)
  (2) vertical space, i.e. the number of separate lines used, is considered unlimited
  (3) policy needed for cases where line width is not adequate to print a structure and
      there are no explicit line break opportunities
      (a) truncate printing at end of line
      (b) allow unlimited or limited (e.g. by percentage) line overflow beyound the "right margin"
      (c) allow unspecified line breaks to be inserted
      (d) reduce indentation(s)
      (e) allow lines to "wrap"

* Blocks or "algebraic" prettyprinting structures

  - hierarchical "block" structure is natural and convenient (with text and "separators" as atomic blocks)
  - blocks are useful entities for carrying certain attributes, such as indentation and alignment
    (PPML and successors)
  - hierarchically nested blocks also provide a way to "prioritize" line breaks (e.g. higher-level breaks
    over lower level)

* look-ahead and measuring techniques and policies

  - older algorithms are "online", meaning look ahead is very limited and in terms of a shallow
    look ahead at arriving characters or "tokens" (roughly lexical units)
  - new algorithms can "measure" the entire prettyprint structure (format or document)
  - can maintain a "current column" (cc) in the current print line that we are trying to fill in
  - maintaining a current column parameter makes it easy to compute the remaining space on
    the current line: space = lineWidth - cc.
  - "granularity" of measuring: character, token, block, ...
  - more look ahead makes it possible to make earlier decisions about break triggering

  - "altFlat" lookahead in Haskell Prettyprinter (a refinement of WL flatten and group operations)

  - Oppen uses lookahead to the end of the "following block" at a potential break (i.e. a block-separating
    space). The following block may be quite large, but we can get away with limiting look-ahead to
    a range of printable items that will exceed the current line's space available (i.e. at most
    a line-width of stuff) -- the point at which we have "seen enough" to learn that it won't fit.

  - in Oppen and Pugh-Sinofsky, the stuff seen during look-ahead are saved in a "queue" or buffer.
    Some of that stuff will be printed before a triggered break, while the rest will become part of
    the look-ahead for the next line. Question: is the triggered break the last break incountered, or
    possibly an earlier break (previously buffered).

* line breaks
  - if alignment (connected/unconnected, consistent/inconsistent) is an attribute of individual breaks
    we have the problem of having heterogenious breaks within a block, i.e. a mixture of
    consistent and inconsistent breaks. How do they interact?  E.g. in Pugh-Sinofsky, consistent
    breaks have priority and "suppress" inconsistent breaks.

  - if conditional breaks have a "spaces" attribute that determines how many spaces replace the
    break if it is not triggered, we can achieve the effect of an unconditional line break by
    setting the spaces attribute to "infinity".  So there might as well be an unconditional
    break primitive (like LINE in the WL algebra).

* strong or weak (vertical) alignment specifications

  - weak: align if any breaks are triggered (in which case, all breaks are triggered)
  - strong: align and trigger all block breaks (assuming only one kind of break)
  - do we want indentations to be consistent in weak and string vertically aligned blocks
    If so, what to do then about inconsistent "offsets" assigned to breaks.

  - perhaps breaks should not be involved in determining indentation? That is, there should
    not be a per-break "offset" specification that determines an extra, local, indentation
    occurring just after a break has been triggered.


* How far is it possible to make the translation from structure to format be "structure-driven".
  A "natural" formatting algorithm would map substructure to subformat in kind of "homomorphic"
  style.

  Formatting (translationg from structure to pp "document") involves deciding how various
  components of a structure will be "set out" and separated from or related to one another.
  Formatting deals with grouping and hierarchy. Which parts are subsidiary to other parts.
  Which parts form natural, related groups that should be spacially kept together.


* Need for "conditional formatting"

  - OR or IFFITS (or TRY) formatting constructors
    OR(f1,f2) : use format f1 _if it fits_, otherwise use f2

  - analogous to WL group and altFlat operators

  - problem: how to extend measurement to conditional formats?
    measure = the max of alternative formats?

  - the property of "fits" is of course relative to space available (room on the line), or
    width - cc.
    
  - the expectation is that in OR (f1, f2), f1 will be (or will render) "wider" or "flatter" than f2
    generally f1 will be (render) flat, while f2 will typically be (render) multiline

  - the "measure" of a format is its maximum or "flat" width
    (assuming no conditional breaks triggered)


* "Semantics" of formats: a format "denotes" a set of layouts (a la WL)

  - the semantics of a format consists of the set of all layouts it can be rendered to with
    all possible lineWidth constraints -- assuming this is well-defined!

      Defn: layout \in [[ format ]] iff for some w, render w format = layout

* is there an analog of the WL flatten function

    [[foo format]] contains a single, single-line (flat) layout


============================================================================================
17. Derived prettyprinting constructs 
============================================================================================

- list, tuple, option

- labeled

============================================================================================
18. Further enhancements for Version 7.3
============================================================================================

- Add EMPTY as a first-class block constructor (to support reduction)

- Add C for "compact" to the alignment constructors
  -- redefine ccat in terms of alignedblock C
  -- concat --> cblock
  -- add cblock and ciblock block-building functions
  
- Add 

    printFormat without lineWidth (implicitly uses Control.Print.lineWidth)
    printFormat --> printFormatLW (renaming)

    appendNewline : format -> format

    labeled : string * format -> format 

    optionFormat : format option -> format
    formatOption : ('a -> format) -> 'a option -> format

    Rename:
    listFormat -> list
    tupleFormat -> tuple
    optionFormat -> option

    closedSequence : {alignment:alignment, front: format, back: format, sep: format}  
                     -> format list -> format

    aligned sequence functions:
      Xsequence: (sep:format) -> format list -> format
      for X in {c, h, p, v}

- formatTuple treatment of null list argument; PP.tuple nil ==> text "()"


============================================================================================
19. block reduction (Version 7.3)
============================================================================================

A bit of "algebraic" influence.

The basic idea for reducing/simplifying blocks is to treat empty/EMPTY as an identity that
gets absorbed in block construction.

  - block nil ==> EMPTY

  - aligned blocks containing only EMPTY formats reduce to EMPTY (ignoring separators)

  - EMPTY gets "absorbed" in block element lists, including separators between EMPTY and
    other elements  
    
  - EMPTY/empty is an identity for binary format concatenation operations. E.g.

      hcat (fmt, empty) = hcat (empty, fmt) = fmt

Thus 

    hblock [text "abc", empty, text "def"] ==> hblock [text "abc", text "def"]

(only one space rather than two between "abc" and "def").

Reduction should be "bottom-up", so when constructing a block the element blocks should be
reduced.  This will happen if all block constructor functions reduce their argument lists.

Q: Does this apply to (manually constructed) special blocks, where separator/format
interleaving is not enforced?  Could still eliminate EMPTY elements while leaving
separators alone.

Enclose, parens, brackets, braces: applied to EMPTY, should produce "()", "[]", "{}", etc.

Also see Section "15. Edge cases ..." above, where composition of
indentations is discussed, along with idempotence of "alt".


