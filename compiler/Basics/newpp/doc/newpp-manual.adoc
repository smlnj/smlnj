= A New Prettyprinter Library for Standard ML
David MacQueen <dmacqueen@mac.com>
:description: A manual for the new SML/NJ prettyprinter library.
:version: 1.0, 2022.8.3

This document describes a new prettyprinter library written in Standard ML and intended for use in
Standard ML programs.

== Introduction

The motivation for designing a new prettyprinter was a dissatisfaction with the existing
prettyprinter library for SML/NJ (found in smlnj-lib/PP), which was adapted from the
Format library for OCaml, which in turn is based on ideas from Derek Oppen's original 1980
TOPLAS paper combined with ideas from the PPML tool of the Centaur system developed at
INRIA Sophia-Antipolis.

Other work that contributed to the current design were the Haskell line of prettyprinters
(Hughes 1995, Wadler 1997, Leijen) that we will call the Wadler-Leijen (WL) family of
prettyprinters. This family includes the current Hackage Prettyprinter package (v. 1.7.1)
with its source code and documentation.

Other sources of ideas include a pretty printer designed by Bill Pugh and Steven Sinofsky at
Cornell for use in the Cornell Programm Synthesizer, a strict (OCaml) version of the Wadler
prettyprinter by Christian Lindig, and prettyprinters by Norman Ramsey based on the Lindig
implementation.

This prettyprinter is based on a 2-phase, off-line algorithm. A formatter function maps the
value to be prettyprinted to a _format_ data structure, and then the format is rendered to a
_layout_ (_e.g._, formatted text on a page or a display) by a render function.

Rendering is conditional on a line-length constraint, which controls optional line breaks
and indentation. A format has a "static" measure (its horizontal span when rendered on a
single, unbounded line) that depends only on the structure of the format, and conditional
rendering of the format is based on this static measure.

The fundamental structuring notion for formats is the "block", which can be an atomic text item
(a string), or a compound block containing subformats. Indentation is an attribute associated
with compound blocks.


== Synopsis

[source,sml]
   structure NewPrettyPrint : NEW_PRETTYPRINT


== Key Concepts and Terminology

Pretty Printing::
     Pretty printing is the process of presenting a datastructure in text in a "readable" fashion,
     using layout, that is newlines, spacing, and indentation, to make the inherent structure more
     obvious. It involves a kind of "markup", meaning that additional information
     is overlayed onto the underlying "content" to produce the physical layout when printed.

Content::
    The _content_ of a format is the list of text strings appearing in the format,
    presented as a list in depth-first, left-to-right order. Usually the content of a format,
    stripped of all extraneous white space, should stand on its own, e.g. as a syntactic phrase
    in a programming language or data description language. We are ignoring the special cases of
    languages where white space (for instance, indentation) has syntactic significance.
    A prettyprinter may produce different layouts of the same content, but these layouts are
    expected to convey the same "meaning" or "information".

Format::
    A format is a data structure that embeds the "contents" (i.e. the strings or tokens that
    convey meaning) in additional structure that specifies _formatting_ information for printing
    the contents, where white-space will be added to help convey its "logical structure".

Formatter::
    A _formatter_ is a function that maps values of a given type (or having a certain data structure)
    to a format structure. A formatter has the type "t -> format" where t is the type of the values
    being formatted.

Layout::
    A _layout_ is the physical arrangement of the content (strings) and white space produced by
    "interpreting" a format in the context of constraints such as the width of the page or display.
    A layout can also be a low-level description of what is printed, say as a list of elementary
    printing commands (e.g. print a string, print n spaces, print a newline character) or simply
    a list of strings to be printed.

Rendering::
    _Rendering_ is the process of translating a format into a layout. This process is controlled by
    physical or "aesthetic" constraints such as the width of a print line or a _ribbon_ percentage that
    limits how much of a line is occupied by text.

Blocks::
* varieties of blocks: empty, text, "basic", aligned "aligned"
* compound (basic or aligned) blocks contain a sequence of (sub)formats and breaks
** _breaks_ in blocks: Space, SoftLine, HardLine, and NullBreak
** block alignment (H, V, P, C) determin the implicit break in aligned blocks
   Aligned blocks are referred to using the terms _hblock_, _vblock_, _pblock_, and _cblock_,
   according to their alignment property.
* block "extent"
** block left margin (blm)
   the content of a block (its text and white space) is bounded on top by its initial line
   and on the left by its block left margin (the current column when the block is "entered"),
   and on the right (softly) by the line width.
* block nesting level (BNL)

Indentation::
* Indented formats are produced using the `indent` and function, where the
  first argument is the number of spaces to indent.

Measurement::
* The flat measure of a format.
* Conditional rendering via soft line breaks (SoftLine n)
** Look-ahead: the format immediately following a soft line break.
* Static and dynamic (render-time) properties of formats, blocks, etc.

== Principles and Assumptions

=== Preconditions
* We assume a fixed-width character set, so measurements of format span and indentation can
  be given in terms of character counts.

=== Nesting of blocks

* blocks contain formats and explicit or virtual breaks, and their format elements
  can also be blocks or can contain blocks.
* Relative to the the context of a "root" format containing a given format or element,
  that format or element has a _block nesting level_ (BNL) that represents the depth of
  block nesting of that element. The root format has BNL 0, and in general represents the
  number of nested blocks containing a format or element.

=== Text formats

* Text formats considered to be "atomic blocks" consisting of a single string, and contain no subformats or breaks. The string contents of a text block may contain white space, but generally should not as a matter of style.

* Text formats lack the alignment and indentation attributes of compound blocks.

=== Block "alignment" modes

* _Basic_ blocks lack an alignment property, and treat alignment in an _ad hoc_ way using
  user-specified breaks between subformats. The breaks of a basic block can be heterogeneous.

* _Aligned_ blocks can be either horizontal (hblock), vertical (vblock) or packed (pblock), these
  are

* The alignment mode of an aligned block is represented by the value of the alignment field
  of the block (H for horizontal alignment, V for vertical alignment, P for packed alignment,
  and C for compact alignment). An aligned block has homogeneous (virtual) breaks that separate
  its constituent subformats. Those virtual breaks are Space 1 for horizontal alignment (H),
  SoftLine 1 for packed alignment (P), HardLine for vertical alignment (V) and NullBreak for
  compact alignment (C).

=== Block indentation and "block left margin" or `blm`

* Indentation is an attribute of formats that are created using the `hardIndent` and `softIndent`
functions.

* For indented formats, there are two modes of indentation: _hard_ and _soft_, depending on which
indentation function is used to create them. Technically, a soft indented format is only _potentially_ indented,
with actual indentation depending on whether it immediatly follows a newline caused by a HardLine
or triggered SoftLine break.

* The indentation of an indented format applies to the complete format, in comparison with other
pretty printing schemes where the indentation only applies after newlines occuring within the block, and
thus does not affect the first line of the block. This is why an indented format (hard indentation
or triggered soft indentation) always starts on a fresh line.

* The indentation level of a compound block is called the _block left margin_, or `blm` for short. The `blm` is
not a "static" or "structural" property of a block -- it is determined dynamically during rendering.
All characters printed during the rendering of a block will be at or to the right of that block's `blm`,
and thus the block occupies the "south-east" quadrant determined by the location of its first character.
Thus there in no way to achieve "outdents" or negative incremental indentation, i.e., lines whose
indentation is less than the containing block's blm.

* Thus Indentation is always associated with a preceding newline, because it makes no sense to indent
other than at the beginning of a line. An indented format will always start on an indented new line.
+
If a hard indented block is not preceeded by a newline (produced by a HardLine break or a triggered
SoftLine break), then it generates its own newline and adds its indentation to the parent blm to
get its indentation or blm. But if such a block is preceeded by a newline, then it produces only the incremental
indentation n (new blm = parent blm + n). This applies to a hard indented block occurring as the first
component format of a hard indented block or "triggered" soft indented block; an indented block at
the beginning of an indented block does not introduce an additional newline+indent.
+
If a soft indented block (SI n) is preceeded by a newline,
then it increments the parent's blm to determine its indentation (new blm = parent blm + n).
If a soft indented block is not preceeded by a newline, then there will be no indentation, and hence
no newline, and the new block's blm will be the current column, as usual.
+
Thus a change in indentation is always associated with entering a new indented block, starting on a new line,
with a new, incremented, blm. There is no _ad hoc_ indentation, such as an indentation associated with
a particular line break that applies only to the following line.

* The indentation (`blm`) of a nonindented block is set to the current column when we begin to render the block.

=== Well-formedness of blocks

* For basic blocks, breaks typically come between format elements, but it is possible to intermix
  subformats (FMT elements) and breaks (BRK elements) arbitrarily, including having no formats or no
  breaks at all.

* For aligned blocks, the (virtual) break for that block is properly interleaved between the subformats
  of the block.

=== Rendering a format (against lthe line width constraint)

We assume that the right margin determined by the line width parameter is _soft_, and can
be exceeded if necessary: for instance, if a format consists of a very long string that does not
fit within the specified line width.

==== Conditional rendering

* Rendering is dependent on a _static_ format measure that depends only on the structure of the format.
+
_flat measure_ assumes that all newlines are suppressed, with HardLine breaks treated as Space 1
and `SoftLine n` breaks treated as `Space n`. The flat measure is essentially the length of the rendered
format if it were rendered on a single, unbounded line.
+
Alternate measures, such as a _multi-line_ measure, are possible, but are not used in this version
(Version 7).

* We say that a format _fits_ if its flat measure is less than the space remaining on the current line;
this is a dynamic (render-time) property of a format based on its static measure compared with the
dynamic value of the line space available, which will be the difference between the current column
and the line width (`lsp = lw - cc`).

* There are three constructs that introduce conditional rendering:

. Soft line breaks, represented by breaks of the form `SoftLine n`.
. _alt_ formats, formed by application of the function `alt`, as in `alt (fmt1, fmt2)`.
. Soft indented blocks, for example as produced by `hiblock (SI n) fmt`.

* A soft line break (break `SoftLine n`) is _triggered_ (i.e. rendered as a newline) if the format following it _fits_. (Note: a `SoftLine` break that is not followed by a format is anomalous and will be ignored; this situation could only occur in a basic block.)

* When rendering the format returned by `alt (fmt1, fmt2)`, the first format `fmt1` is rendered if
it _fits_ (_i.e._, its measure is less than the line space available), and otherwise the alternate
format `fmt2` is rendered.

* A soft indented block with incremental indentation `n` actually performs
the indentation `n` (relative to its parent's `blm`) only if it immediately follows a newline+indent,
and otherwise is rendered as an ordinary nonindented block with the same contents.

* The function `flat : format -> format`, forces flat rendering and measuring of its argument format.
This function can be used in conjunction with the `alt` function to define a function like:

 fun tryFlat (fmt: format) = alt (flat fmt, fmt)

* A priority ordering for soft line breaks
+
When there is a choice, we prefer to trigger a higher-level (lower BNL) soft line break rather than
a later, lower-level one. The enforcement of this preference is a natural consequence of conditioning
the triggering of soft line breaks on the measure of the immediately following format, because we
use that format's flat measure to decide whether to trigger the break. That measure does not take
into account the possibility of internal line breaks when it is rendered.

=== The "semantics" of a format should be independent of the layout produced by its rendering

Removing the "formatting" from a format, leaving only the list of strings (or atomic text
formats) contained in the format, in depth-first, left-to-right order, yields the
_content_ of the format. This content, viewed, for instance, as a sequence of lexical tokens,
should by itself be an adequate representation of the data stucture from which the format
is derived. This should not be surprising, since in almost all "languages" or "serialized
representations" used in computing, the "white space" does not carry meaning -- it is
only used to delineate the meaningful "tokens" of the language or representation.

There are exceptions, such as languages whose syntax uses Landin's "offside rule", where
newlines and indentation determine syntactic structure, but we are excluding such
languages (e.g. Python, Haskell, YAML).
footnote:[Sometimes such languages also have
alternative "linear" syntaxes that use explicit lexical notations to convey structure
and hence do not depend on white space (i.e. dependence on white space is optional).]
In any case, this prettyprinter library is not designed to support notations that use such
layout-dependent syntaxes. If the prettyprinted layout is supposed to faithfully represent
layout-based syntax, that is up to the writer of the prettyprinter to achieve that.

== Interface (NEWPP/src/newprettyprint.sig)

=== signature NEW_PRETTYPRINT

[discrete]
==== Types

* type `format` -- abstract
* datatype `break` -- Used in basic blocks

 datatype break       (* breaks are not, and do not contain, content *)
   = HardLine         (* hard line break; rendered as a newline + indent to current blm *)
   | SoftLine of int  (* soft line break (n >= 0); rendered as n spaces, if the line break
                       * is not triggered; if it is triggered, renders as newline + indent
                       * to current blm *)
   | Space of int     (* spaces (n >= 0); rendered as n spaces *)
   | NullBreak        (* does nothing when rendered: no spaces, no line break *)

* datatype `alignment` -- used to determine the alignment of aligned blocks, etc.

 datatype alignment
   = H   (* Horizontal, implicit break = Space 1 *)
   | V   (* Vertical, implicit break = HardLine *)
   | P   (* Packed, implicit break = SoftLine 1 *)
   | C   (* Compact, no implicit break *)

* datatype `element` -- the components of basic blocks

 datatype element
   = BRK of break
   | FMT of format

[discrete]
==== Format construction functions

* `empty : format`

 The empty format that prints nothing when rendered, equivalent to (text ""). Empty formats are
 absorbed by adjacent nonempty formats, so that no "separation" whitespace will be printed between and
 empty format and adjacent nonempty formats. Empty serves as an identity element for binary
 format concatenation operators. For instance, hcat (fmt, empty) == fmt.

* `text : string -> format`

 Create an atomic "text" block consisting of a string, which renders as that string. Note that the string may contain, indeed may consist only of, white space.  As a mater of style, however, whitespace should usually be produced by formatting rather than being built into text strings.
 

_General block constructor functions:_

* `basicBlock : element list -> format`

 build a block with ad hoc alignment determined by explicit breaks among the elements.

* `alignedBlock : alignment -> format list -> format`

 build an aligned block with the specified alignment.

_Basic (nonindented) block constructor functions:_

* `block : element list -> format`

 block elems : Create a basic block with elems as components.

* `hblock : format list -> format`

 hblock fmts : Create a horizontally aligned block (with implicit (Space 1) breaks) with fmts as components.

* `vblock : format list -> format`

 vblock fmts : Create a vertically aligned block (with implicit HardLine breaks) with fmts as components.

* `pblock : format list -> format`

 pblock fmts : Create a "packed" aligned block (with implicit (SoftLine 1) breaks) with fmts as components.

* `cblock : format list -> format`

 cblock fmts : Create a "compact" aligned block with fmts as components, with no breaks between components.


[discrete]
==== Conditional rendering

* `flat : format -> format`

 flat fmt : returns a version of the argument fmt that will be rendered as flat (on a single line) and will have the same flat measure.

* `alt : format * format -> format`

 alt (fmt1, fmt2) : the resulting format renders as fmt1 if fmt1 fits, otherwise it renders as fmt2.

* `tryFlat : format -> format`

 tryFlat fmt : the result format renders as (flat fmt) if that fits, and otherwise renders as fmt.

* `hvblock : format list -> format`

 hvblock fmts : renders as (hblock fmts) if that fits, and otherwise renders as (vblock fmts).

[discrete]
==== Indented formats

* `indent : int -> format -> format`

 indent n fmt : indent fmt n additional spaces (relative to parent block's blm) only if immediately
 following a line break (newline+indent); otherwise render fmt normally.

* `breakIndent : int -> format -> format`

 breakIndent n fmt : unconditionally produce a line break (newline + indent (blm+n)) followed by fmt.

[discrete]
==== Basic formats

* `comma, colon, semicolon, period, lparen, rparen, lbracket, rbracket, lbrace, rbrace, equal : format`

 Punctuation characters as formats (plus the equal symbol).

* `integer : int -> format`

 integer n : Returns the string representation of n (Int.toString n) as a text format.

* `string : string -> format`

 string s : Formats the string s enclosed in double quotation marks.

* `char : char -> format`

 char c : Formats c as "#" ^ (string (Char.toString c)).

* `bool : string -> format`

 bool b : Formats the boolean value b as `text "true"` or `text "false"`.

[discrete]
==== Utility format construction functions

_Binary format combinators_

* `hcat : format * format -> format`

 hcat (fmt1, fmt2) = hblock [fmt1, fmt2] : Concatenates fmt1 and fmt2 with a (Space 1) break.

* `vcat : format * format -> format`

 vcat (fmt1, fmt2) = vblock [fmt1, fmt2] : Concatenates fmt1 and fmt2 with a HardLine break.

* `pcat : format * format -> format`

 pcat (fmt1, fmt2) = pblock [fmt1, fmt2] : Concatenates fmt1 and fmt2 with a (SoftLine 1) break.

* `ccat : format * format -> format`

 ccat (fmt1, fmt2) = cblock [fmt1, fmt2] : Concatenates fmt1 and fmt2 without a break.
 
Note that the empty format is an identity element for all of these binary concatenation operators.

[discrete]
==== Enclosing a format

* `enclose : {front: format, back: format} -> format -> format`

 enclose {front, back} fmt : concatenate front, fmt, and back.

* `parens: format -> format`

 parens fmt = enclose {front=lparen, back=rparen} fmt
   Enclose fmt with left and right parentheses.

* `brackets: format -> format`

 brackets fmt = enclose {front=lbracket, back=rbracket} fmt
   Enclose fmt with left and right square brackets. 

* `braces: format -> format`

 braces fmt = enclose {front=lbrace, back=rbrace} fmt
   Enclose fmt with left and right curly braces. 

[discrete]
==== Modifying a format

* `label : string -> format -> format

 label str fmt = hcat (ccat (text str, colon), fmt)

* `appendNewLine : format -> format

 append a hard newline after the format

[discrete]
==== Formatting lists of formats

* `sequence : alignment -> format -> format list -> format`

 sequence a sep fmts: inserts sep between the elements of fmts, aligning according to a.

* `hsequence : format -> format list -> format`

 hsequence = sequence H

* `psequence : format -> format list -> format`

 psequence = sequence P

* `vsequence : format -> format list -> format`

 vsequence = sequence V

* `csequence : format -> format list -> format`

 csequence = sequence C

* `tupleFormats : format list -> format`

 formats the members of the format list as a tuple (parenthesized, with elements
 separated by commas) with default packed (P) alignment of the element formats.

* `listFormats : format list -> format`

 formats the members of the format list as a list (bracketed, with elements
 separated by commas) with default packed (P) alignment of the element formats.

* `optionFormat : format option -> format`

 formats `fmtOp: format option` as `text "NONE"` or `ccat (text "SOME", parens (valof fmtOp)).

[discrete]
==== Formatting sequences of values of arbitrary types

* `formatSeq : {alignment: alignment, sep: format, formatter: 'a -> format} -> 'a list -> format`

 formatSeq {alignment, sep, formatter} xs : format the elements of xs using formatter, then 
 insert sep between these formats, and align the sequence elements according to the alignment
 parameter. E.g.
     formatSeq {alignment=H, sep=comma, formatter=integer} [1,2] =>
       block [FMT(integer 1), FMT comma, BRK(Space 1), FMT(integer 2)],
 which renders as:
     1, 2

* `formatClosedSeq :
     {alignment: alignment, front: format, sep: format, back: format, formatter: 'a -> format}
     -> 'a list
     -> format`

 `formatClosedSeq {alignment, front, sep, back, formatter} xs = 
    enclose {front=front, back=back} (formatSeq {alignment, sep, formatter} xs)`

* `list : ('a -> format) -> 'a list -> format`

 list formatter xs = brackets (psequence comma (map formatter xs))

* `alignedList : alignment -> ('a -> format) -> 'a list -> format`

 alignedList alignment formatter xs : format the members of xs using formatter and then format
 those formats as a list (bracketed, with comma separator), aligned according to the alignment parameter.

* `option : ('a -> format) -> 'a option -> format`

 option values are treated as honorary sequences with 0 or 1 element. `NONE` is rendered as
 `text "NONE"`, and `SOME v` is rendered as `SOME(formatter v)`.

* `val vHeaders : {header1: string, header2: string, formatter: 'a -> format} -> 'a list -> format`

 Vertically align the formats produced by mapping formatter over the list with header1 as header
 for the first format and header2 as header for subsequent format. If header1 and header2 are of
 unequal sizes, the shorter one is padded with spaces on the left to make its size equal to the
 longer.

* `val vHeaderFormats : {header1: string, header2: string} -> format list -> format`

 Vertically align the formats in the format list with header1 as header for the first format
 and header2 as header for subsequent format. If header1 and header2 are of unequal sizes,
 the shorter one is padded with spaces on the left to make its size equal to the longer.


[discrete]
==== Setting and accessing the line width

* `setLineWidthFun : (unit -> int) -> unit`

 Defines the function that returns the current lineWidth value.

* `resetLineWidthFun : unit -> unit`

 Reset the lineWidthFun to the default lineWidthFun (which returns 90).

* `getLineWidth : unit -> int`

 Returns the current line width, obtained by calling the current lineWidthFun function.


[discrete]
==== Render and print functions

* `render : format * (string -> unit) * int -> unit`

 render (fmt, output, lineWidth): render fmt to output given lineWidth as the right margin.
 This prints directly using output without building a "layout" data structure.

* `printFormatLW : int -> format -> unit`

 Printing with an explicit lineWidth argument:
 printFormat lineWidth fmt = render (fmt, print, lineWidth)
 
* `printFormat : format -> unit`

 printFormat' fmt = printFormatLW (getLineWidth ()) fmt

* `printFormatNL : format -> unit`

 printFormat' fmt = printFormatLW (getLineWidth ()) (appendNewLine fmt)


== Usage and Examples

* How to produce a blank line in a layout?

 val doubleNewline : format = sblock [BRK Hardline, BRK HardLine]

.String to "paragraph"
====
----
fun formatPara (s: string) : format =
    let val tokens = String.tokens Char.isSpace s
     in pblock (map text tokens)
    end
----
====

.Tree Example from Wadler
====
----
datatype tree = Node of string * tree list

fun formatTree (Node (s, trees)) = 
    ccat (text s, formatTrees trees)

and formatTrees nil = empty
  | formatTrees trees = brackets (vsequence comma (map formatTree trees)

val tree1 =
    Node ("aaa",
	  [Node ("bbbbb",
		 [Node ("ccc", nil),
		  Node ("dd", nil)]),
	   Node ("eee", nil),
	   Node ("ffff",
		 [Node ("gg", nil),
		  Node ("hhh", nil),
		  Node ("ii", nil)])]);
----
====
Note that in this example, there are no SoftLine breaks or soft indented blocks, so
the rendering of a tree value will not be sensitive to line width.
====
----
- printFormat 80 (formatTree tree1);
aaa[bbbbb[ccc,
          dd],
    eee,
    ffff[gg,
         hhh,
         ii]]
----
====

.Wadler's second style of formatting trees
====
----
fun formatTree' (Node (s, trees)) = 
    case trees
      of nil => text s
       | _ =>
          vblock [ccat (text s, lbracket),
                  indent 2  (vsequence comma (map formatTree' trees))
                  rbracket];
----
====
Yielding:
====
----
- printFormat 80 (formatTree' tree1);
aaa[
  bbbbb[
    ccc,
    dd
  ],
  eee,
  ffff[
    gg,
    hhh,
    ii
  ]
]
----
====

* Simplified SML abstract syntax examples (let expressions, structure decls)

.Simple let expressions
====
----
datatype exp
  = Let of dcl list * exp list
  | Var of string
  | Num of int

and dcl
  = Val of string * exp

fun formatExp (Var s) = text s
  | formatExp (Num n) = integer n
  | formatExp (Let (dcls, exps)) =
      vblock
	[hcat (text "let", fmtDcls dcls),
         hcat (text "in", formatExps exps),
         text "end"]

and formatExps (exps) = vblock (map formatExp exps)

and fmtDcl (Val (name, exp)) =
    hblock [text "val", text name, equal, formatExp exp]

and fmtDcls dcls = vblock (map fmtDcl dcls)

(* example *)

val exp1 = Let ([Val ("x", Num 1), Val ("y", Num 2)], [Var "x"]);

val exp1Format = tryFlat (formatExp exp1);
----
====
Outputs:
====
----
- printFormat 15 exp1Format;
let val x = 1
    val y = 2
in x
end

- printFmt 80 exp1Format;
let val x = 1 val y = 2 in x end
----
====

.simplified SML structure expressions and declarations
====
----
datatype str
  = SVAR of string
  | STRUCT of decl list

and decl
  = VALd of string * string
  | TYPd of string * string
  | STRd of string * str

fun ident (format: format) = format

(* formatDecl : (format -> format) -> decl -> format *)
fun formatDecl strdef decl =
    (case decl
       of VALd (name, def) => hblock [text "val", text name, text "=", text def]
	| TYPd (name, def) => hblock [text "type", text name, text "=", text def]
	| STRd (name, str) =>
	    hblock [text "structure", text name, text "=", strdef (formatStr strdef str)])

(* formatStr : str -> format *)
and formatStr _ (SVAR name) = text name
  | formatStr strdef (STRUCT decls) = 
    let val body = vblock (map (formatDecl strdef) decls)
    in tryFlat (vblock [text "struct", indent 2 body, text "end"])
    end

(* formatDecl? : decl -> format *)
val formatDecl1 = formatDecl ident
val formatDecl2 = formatDecl (breakIndent 0)

fun formatDecl3 (STRd (name, SVAR svar)) =
      hblock [text "structure", text name, text "=", text svar]
  | formatDecl3 (STRd (name, STRUCT decls)) =
      vblock
        [hblock [text "structure", text name, text "=", text "struct"],
	 indent 2 (vblock (map formatDecl3 decls)),
	 text "end"]
  | formatDecl3 decl = formatDecl ident decl  (* decl is VALd or TYPd *)

(* examples *)

val str1 = STRUCT [TYPd ("t", "int list"), VALd ("x", "3")]

val str2 = STRUCT [TYPd ("s", "bool"), VALd ("y", "true"), STRd ("S", str1)]

val strd1 = STRd ("A", str1)
val strd2 = STRd ("B", str2)
----
====

Outputs:
====
----
(* using formatDecl1: *)

- printFormat 80 (formatDecl1 strd1);
structure A = struct type t = int list val x = 3 end

- printFormat 10 (formatDecl1 strd1);
structure A = struct
                type t = int list
                val x = 3
              end

(* using formatDecl2: *)

- printFormat 80 (formatDecl2 strd1);
structure A = struct type t = int list val x = 3 end

- printFormat 10 (formatDecl2 strd1);
structure A = 
struct
  type t = int list
  val x = 3
end

(* using formatDecl3: *)

- printFormat 80 (formatDecl3 strd1);
structure A = struct
  type t = int list
  val x = 3
end
----
====

* Correspondences with Haskell Prettyprinter interface

Rough analogs of Haskell Prettyprinter types and functions: 
----
      Haskell Prettyprinter     New Prettyprinter
      ---------------------     -----------------

      type doc                  type format

      <+>                       hcat

      hsep                      hblock

      vsep                      vblock

      fillsep                   pblock

      sep                       hvblock

      hcat                      ccat

      vcat xs                   alt (vblock xs, hblock xs); hvblock

      enclose, surround         enclose

      Union, group              alt, tryFlat

      flatten                   FLAT (format data constructor, hidden)

      nest                      indent
----

== Implementation

* The datatype constructors for formats
 ** `EMPTY` is the empty format that prints nothing and acts as an identity element with respect to
    concatenation of formats or composition of blocks.
 ** `TEXT` constructs atomic text blocks.
 ** `BLOCK` constructs "basic" blocks with explicit break (`BRK`) elements mixed with format (`FMT`) elements.
 ** `ABLOCK` constructs "aligned" blocks, where alignment is determined by the choice of the alignment,
which in turn determines the virtual break between component formats:
Horizontal: `Space 1`; Vertical: `HardLine`; Packed: `SoftLine 1`.
 ** `FLAT` converts an arbitrary format to one which is rendered as flat.
 ** `ALT` takes a pair of formats, `(fmt1, fmt2)` and constructs a format that is
rendered as `fmt1` if it fits, and otherwise is rendered as `fmt2`. Note that the two formats are not
constrained to have the same content; for instance, `fmt2` might be an abbreviated version of `fmt2`.

.The format and element datatypes:
----
datatype format
  = TEXT  of string
  | BLOCK of {elements: element list, measure: int}
  | ABLOCK of {formats: format list, alignment: alignment, measure: int}
  | INDENT of int * format
  | FLAT of format
  | ALT of format * format

and element  (* of a BLOCK *)
  = BRK of break  (* breaks are _not_, and do not contain, content *)
  | FMT of format
----

* Format measure, memoization

The measure of a `TEXT` block is just the length of its string contents.

The measure of a `FLAT` format is just the (default, flat) measure of its component format.
The measure of a `ALT (fmt1, fmt2)` format is the (flat) measure of `fmt1`, which is normally
expected to be the "wider" of the two formats.

The measure of a compound block format is the length of the format as rendered on a single, unbounded line.
This is the sum of the flat measures of its component formats plus `breakMeasure b` for each explicit or
implicit break `b`, where `breakMeasure` is defined as follows:
----
fun breakMeasure (Space n) = n
  | breakMeasure (SoftLine n) = n
  | breakMeasure HardLine = 1
  | breakMeasure NullBreak = 0
----

The _measure_ fields of the `BLOCK` and `ABLOCK` constructors are used to _memoize_ the measure function
over formats to avoid having to recompute the measures of nested blocks. 

* Rendering

`FLAT` formats (used in `tryFlat`, for instance) are rendered _flat_, meaning that all breaks `s`
are rendered as though they were `Space (sepMeasure s)`, and no newline+indent are generated when
rendering indented blocks.

== Discussion

. How is an indented block rendered?
+
* The indentation of an indented block is conditional, and is _triggered_ when the indented
  block comes immediately after a line break.
* The subformats of a vblock (vertically aligned block) are separated by unconditional line breaks,
  so any indented subformat in a vblock, other than the first, will be triggered. If the first
  subformat of a vblock is indented, it will be triggered only if the whole vblock occurs immediately
  after a (triggered) line break.
+
. The importance of the blm boundary (and no "outdent").
+
We claim that is simplifies the "semantics" of the prettyprinting system if the content of a block
is bounded by a left margin, the `blm`, determined by the column in which the block starts. This goes
along with the indentation principle: a block is indented as a whole, and the indentation applies to
the entire content of the block. Other systems, where indentation only applies after newlines in a
block's multi-line layout, make it harder to keep track of the indentation structure and what it
represents in terms of the data structure being presented.

== Future Work (possible new features or improvements)

* Multi-line measurement of formats (this has been implemented in Version 8 of this library).

* Tabs. Setting tabs would be related to breaks and would only be accessible at a block's
"top level".

* Tabular formatting (i.e. tables).

* Rendering to a layout type (instead of printing directly in the render function).

* Ribbon percentage as a second constraint controling rendering. This should be easy to
add to this scheme.

* _styles_ (similar to WL _annotations_).

** non-fixed character widths (fonts and type faces).
** color and emphasis (italics and boldface).

* Alternate rendering targets (e.g. HTML); _devices_.

* _Holophrastic_ formatting or rendering, _i.e._, truncating or abbreviating to conserve space.
+
This is probably not something that should be supported in a generic way by the prettyprinting
library. It is normally implemented as part of a particular prettyprinter (as is done, for
instance, in the SML/NJ prettyprinters for abstract syntax and for various IRs by passing a
"printdepth" parameter through the prettyprinter and decrementing it for each level of structure.
