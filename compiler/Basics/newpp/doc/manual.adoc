= A New Prettyprinter Library for Standard ML
David MacQueen <dmacqueen@mac.com>
:description: A manual for the new SML/NJ prettyprinter library.
:version: 1.0, 2022.8.3

This document describes a new prettyprinter library written in Standard ML and intended for use in
Standard ML programs.

== Introduction

The motivation for designing a new prettyprinter was a dissatisfaction with the existing
prettyprinter library for SML/NJ (found in smlnj-lib/PP), which was adapted from the
Format library for OCaml, which in turn is based on ideas from Derek Oppen's original 1980
TOPLAS paper combined with ideas from the PPML tool of the Centaur system developed at
INRIA Sophia-Antipolis.

Other work that contributed to the current design were the Haskell line of prettyprinters
(Hughes 1995, Wadler 1997, Leijen) that we will call the Wadler-Leijen (WL) family of
prettyprinters. This family includes the current Hackage Prettyprinter package (v. 1.7.1)
with its source code and documentation.

Other sources of ideas include a pretty printer designed by Bill Pugh and Steven Sinofsky at
Cornell for use in the Cornell Programm Synthesizer, a strict (OCaml) version of the Wadler
prettyprinter by Christian Lindig, and prettyprinters by Norman Ramsey based on the Lindig
implementation.

This prettyprinter is based on a 2-phase, off-line algorithm. A formatter function maps the
value to be prettyprinted to a _format_ data structure, and then the format is rendered to a
_layout_ (_e.g._, formatted text on a page or a display) by a render function.

Rendering is conditional on a line-length constraint, which controls optional line breaks
and indentation. A format has a "static" measure (its horizontal span when rendered on a
single, unbounded line) that depends only on the structure of the format, and conditional
rendering of the format is based on this static measure.

The fundamental structuring notion for formats is the "block", which can be an atomic text item
(a string), or a compound block containing subformats. Indentation is an attribute associated
with compound blocks.


== Synopsis

[source,sml]
   structure NewPP : NEW_PP


== Key Concepts and Terminology

Pretty Printing::
     Pretty printing is the process of presenting a datastructure in text in a "readable" fashion,
     using layout, that is newlines, spacing, and indentation, to make the inherent structure more
     obvious. It involves a kind of "markup", meaning that additional information
     is overlayed onto the underlying "content" to produce the physical layout when printed.

Content::
    The _content_ of a format is the list of text strings appearing in the format,
    presented as a list in depth-first, left-to-right order. Usually the content of a format,
    stripped of all extraneous white space, should stand on its own, e.g. as a syntactic phrase
    in a programming language or data description language. We are ignoring the special cases of
    languages where white space (for instance, indentation) has syntactic significance.
    A prettyprinter may produce different layouts of the same content, but these layouts are
    expected to convey the same "meaning" or "information".

Format::
    A format is a data structure that embeds the "contents" (i.e. the strings or tokens that
    convey meaning) in additional structure that specifies _formatting_ information for printing
    the contents, where white-space will be added to help convey its "logical structure".

Formatter::
    A _formatter_ is a function that maps values of a given type (or having a certain data structure)
    to a format structure. A formatter has the type "t -> format" where t is the type of the values
    being formatted.

Layout::
    A _layout_ is the physical arrangement of the content (strings) and white space produced by
    "interpreting" a format in the context of constraints such as the width of the page or display.
    A layout can also be a low-level description of what is printed, say as a list of elementary
    printing commands (e.g. print a string, print n spaces, print a newline character) or simply
    a list of strings to be printed.

Rendering::
    _Rendering_ is the process of translating a format into a layout. This process is controlled by
    physical or "aesthetic" constraints such as the width of a print line or a _ribbon_ percentage that
    limits how much of a line is occupied by text.

Blocks::
* varieties of blocks: text, "aligned", "special", and empty.
* compound (aligned or special) blocks contain a sequence of (sub)formats and separators
** _separators_ in blocks: Space, SoftLine, and HardLine
** block alignment (H, V, P, C) determined by implicit separator
* block "extent"
** block left margin (blm)
   the content of a block (its text and white space) is bounded on top by its initial line
   and on the left by its block left margin (the current column when the block is "entered"),
   and on the right (softly) by the line width.
* block nesting level (BNL)

Indentation::
* Indented blocks, specified by block indentation (type bindent).
** Soft indentation (SI n)
** Hard indentation (HI n)
** No indentation (NI)
* Only compound blocks can have indentation

Measurement::
* The flat measure of a format.
* Conditional rendering via soft line breaks (SoftLine n)
** Look-ahead: the format immediately following a soft line break.
* Static and dynamic (render-time) properties of formats, blocks, etc.

== Principles and Assumptions

=== Preconditions
* We assume a fixed-width character set, so measurements of format span and indentation can
  be given in terms of character counts.

=== Nesting of blocks

* blocks contain formats and explicit or virtual separators, and their format elements
  can also be blocks or can contain blocks.
* Relative to the the context of a "root" format containing a given format or element,
  that format or element has a _block nesting level_ (BNL) that represents the depth of
  block nesting of that element. The root format has BNL 0, and in general represents the
  number of nested blocks containing a format or element.

=== Text formats

* Text formats considered to be "atomic blocks" consisting of a single string, and contain no subformats or separators. The string contents of a text block may contain white space, but generally should not as a matter of style.

* Text formats lack the alignment and indentation attributes of compound blocks.

=== Block "alignment" modes

* _Aligned_ blocks can be either horizontal (hblock), vertical (vblock) or packed (pblock), these
  are

* _Special_ blocks lack an alignment property, and treat alignment in an _ad hoc_ way using
  user-specified separators between subformats. The separators of a special block can be heterogeneous.

* The alignment mode of an aligned block is represented
  by the value of the alignment field of the block (H for horizontal alignment, V
  for vertical alignment, and P for packed alignment). An aligned block has homogeneous
  (virtual) separators that separate its constituent subformats. Those virtual separators
  are Space 1 for horizontal alignment (H), SoftLine 1 for packed alignment (P), and
  HardLine for vertical alignment (V).

=== Block indentation and "block left margin" or `blm`

* Indentation is regarded as an attribute of blocks, rather than an independent format element or form.
The block indentation attribute has type `bindent`, which has three variants: `NI`, `HI n`, and `SI n`.

* Blocks can be _indented_ (`bindent = HI n` or `SI n`) or _nonindented_ (`bindent = NI`).
For indented blocks, there are two modes of indentation: _hard_ and _soft_ (`bindent = HI n`
or `SI n`, respectively). Technically, a soft indented block is only _potentially_ indented,
with actual indentation depending on whether it immediatly follows a newline caused by a HardLine
or triggered SoftLine separator or by being at the beginning of an enclosing indented block.

* The indentation of an indented block applies to the complete block, in comparison with other
pretty printing schemes where the indentation only applies after newlines within the block, and
thus does not affect the first line of the block. This is why an indented block (hard indent
or triggered soft indent) always starts on a fresh line.

* The indentation level of a block is called the _block left margin_, or `blm` for short. The `blm` is
not a "static" or "structural" property of a block -- it is determined dynamically during rendering.
All characters printed during the rendering of a block will be at or to the right of that block's `blm`,
and thus the block occupies the "south-east" quadrant determined by the location of its first character.
Thus there in no way to achieve "outdents" or negative incremental indentation, i.e., lines whose
indentation is less than the containing block's blm.

* Thus Indentation is always associated with a preceding newline, because it makes no sense to indent
other than at the beginning of a line. An indented block will always start on an indented new line.
+
If a hard indented block is not preceeded by a newline (produced by a HardLine separator or a triggered
SoftLine separator), then it generates its own newline and adds its indentation to the parent blm to
get its indentation or blm. If such a block is preceeded by a newline, then it produces only the incremental
indentation n (new blm = parent blm + n). This applies to a hard indented block occurring as the first
component format of a hard indented block or "triggered" soft indented block; an indented block at
the beginning of an indented block does not introduce an additional newline+indent.
+
If a soft indented block (SI n) is preceeded by a newline,
then it increments the parent's blm to determine its indentation (new blm = parent blm + n).
If a soft indented block is not preceeded by a newline, then there will be no indentation, and hence
no newline, and the new block's blm will be the current column, as usual.
+
Thus a change in indentation is always associated with entering a new indented block, starting on a new line,
with a new, incremented, blm. There is no _ad hoc_ indentation, such as an indentation associated with
a particular line break that applies only to the following line.

* The indentation (`blm`) of a nonindented block is set to the current column when we begin to render the block.

=== Well-formedness of blocks

* For aligned blocks, the separator for that block is properly interleaved between the subformats of the block.
* For special blocks, separators would typically come between format elements, but it is possible to intermix
  subformats (FMT elements) and separators (SEP elements) arbitrarily, including having no formats or no
  separators at all.

=== Rendering a format (against lthe line width constraint)

We assume that the right margin determined by the line width parameter is _soft_, and can
be exceeded if necessary: for instance, if a format consists of a very long string that does not
fit within the specified line width.

==== Conditional rendering

* Rendering is dependent on a _static_ format measure that depends only on the structure of the format.
+
_flat measure_ assumes that all newlines are suppressed, with HardLine separators treated as Space 1
and `SoftLine n` separators treated as `Space n`. The flat measure is essentially the length of the rendered
format if it were rendered on a single, unbounded line.
+
Alternate measures, such as a _multi-line_ measure, are possible, but are not used in this version
(Version 7).

* We say that a format _fits_ if its flat measure is less than the space remaining on the current line;
this is a dynamic (render-time) property of a format based on its static measure compared with the
dynamic value of the line space available, which will be the difference between the current column
and the line width (`lsp = lw - cc`).

* There are three constructs that introduce conditional rendering:

. Soft line breaks, represented by separators of the form `SoftLine n`.
. _alt_ formats, formed by application of the function `alt`, as in `alt (fmt1, fmt2)`.
. Soft indented blocks, for example as produced by `hiblock (SI n) fmt`.

* A soft line break (separator `SoftLine n`) is _triggered_ (i.e. rendered as a newline) if the format following it _fits_. (Note: a `SoftLine` separator that is not followed by a format is anomalous and will be ignored; this situation could only occur in a special block.)

* When rendering the format returned by `alt (fmt1, fmt2)`, the first format `fmt1` is rendered if
it _fits_ (_i.e._, its measure is less than the line space available), and otherwise the alternate
format `fmt2` is rendered.

* A soft indented block (with block indentation `bindent = SI n` for some `n`) actually performs
the indentation `n` (relative to its parent's `blm`) if it immediately follows a newline+indent,
and otherwise is rendered as an ordinary nonindented block with the same contents.

* The function `flat : format -> format`, forces flat rendering and measuring of its argument format.
This function can be used in conjunction with the `alt` function to define a function like:

 fun tryFlat (fmt: format) = alt (flat fmt, fmt)

* A priority ordering for soft line breaks
+
When there is a choice, we prefer to trigger a higher-level (lower BNL) soft line break rather than
a later, lower-level one. The enforcement of this preference is a natural consequence of conditioning
the triggering of soft line breaks on the measure of the immediately following format, because we
use that format's flat measure to decide whether to trigger the break. That measure does not take
into account the possibility of internal line breaks when it is rendered.

=== The "semantics" of a format should be independent of the layout produced by its rendering

Removing the "formatting" from a format, leaving only the list of strings (or atomic text
formats) contained in the format, in depth-first, left-to-right order, yields the
_content_ of the format. This content, viewed, for instance, as a sequence of lexical tokens,
should by itself be an adequate representation of the data stucture from which the format
is derived. This should not be surprising, since in almost all "languages" or "serialized
representations" used in computing, the "white space" does not carry meaning -- it is
only used to delineate the meaningful "tokens" of the language or representation.

There are exceptions, such as languages whose syntax uses Landin's "offside rule", where
newlines and indentation determine syntactic structure, but we are excluding such
languages (e.g. Python, Haskell, YAML).
footnote:[Sometimes such languages also have
alternative "linear" syntaxes that use explicit lexical notations to convey structure
and hence do not depend on white space (i.e. dependence on white space is optional).]
In any case, this prettyprinter library is not designed to support notations that use such
layout-dependent syntaxes. If the prettyprinted layout is supposed to faithfully represent
layout-based syntax, that is up to the writer of the prettyprinter to achieve that.

== Interface

=== signature NEW_PP

[discrete]
==== Types

* type `format` -- abstract
* datatype `separator` -- Used in special blocks

 datatype separator   (* separators are not, and do not contain, content *)
   = HardLine         (* hard line break; rendered as a newline + indent to current blm *)
   | SoftLine of int  (* soft line break (n >= 0); rendered as n spaces, if the line break
                       * is not triggered; if it is triggered, renders as newline + indent
                       * to current blm *)
   | Space of int     (* spaces (n >= 0); rendered as n spaces *)

* datatype `alignment` -- used to determine the alignment of aligned blocks, etc.

 datatype alignment
   = H   (* Horizontal, implicit separator = Space 1 *)
   | V   (* Vertical, implicit separator = HardLine *)
   | P   (* Packed, implicit separator = SoftLine 1 *)

* datatype `element` -- the components of special blocks

 datatype element
   = SEP of separator
   | FMT of format

* datatype `bindent` -- block indentation

 datatype bindent
   = NI        (* No Indent: the block begins at the current column on the current line *)
   | HI of int (* Hard Indent: unconditional, adding a newline+indent if necessary; n >= 0 *)
   | SI of int (* Soft Indent: triggered if preceded by a newline+indent; n >= 0 *)


[discrete]
==== Format construction functions

* `empty : format`

 The empty format that prints nothing when rendered, equivalent to (text ""). Empty formats are
 absorbed by adjacent nonempty formats, so that no "separation" whitespace will be printed between and
 empty format and adjacent nonempty formats. Empty serves as an identity element for binary
 format concatenation operators. For instance, hcat (fmt, empty) == fmt.

* `text : string -> format`

 Create an atomic "text" block consisting of a string, which renders as that string. Note that the string may contain, indeed may consist only of, white space.  As a mater of style, however, whitespace should usually be produced by formatting rather than being built into text strings.
 

_General block constructor functions:_

* `specialBlock : bindent -> element list -> format`

 build a block with ad hoc alignment determined by explicit separators among the elements and indentation specified by the bindent parameter.

* `alignedBlock : alignment -> bindent -> format list -> format`

 build an aligned block with the specified alignment and indentation.

_Basic (nonindented) block constructor functions:_

* `hblock : format list -> format`

 hblock fmts : Create a horizontally aligned block (with implicit (Space 1) separators) with fmts as components.

* `vblock : format list -> format`

 vblock fmts : Create a vertically aligned block (with implicit HardLine separators) with fmts as components.

* `pblock : format list -> format`

 pblock fmts : Create a "packed" aligned block (with implicit (SoftLine 1) separators) with fmts as components.

* `cblock : format list -> format`

 cblock fmts : Create a "compact" aligned block with fmts as components, with no separators between components.

* `sblock : element list -> format`

 sblock elems : Create a special block with elems as components (possibly mixing formats and separators).

_Indented block constructor functions:_

* `hiblock : bindent -> format list -> format`

 hiblock bindent fmts : Create a horizontally aligned block (with implicit (Space 1) separators) with fmts as components and the indentation specified by bindent.

* `viblock : bindent -> format list -> format`

 viblock bindent fmts : Create a vertically aligned block (with implicit HardLine separators) with fmts as components and the indentation specified by bindent.

* `piblock : bindent -> format list -> format`

 piblock binent fmts : Create a horizontally aligned block (with implicit (Space 1) separators) with fmts as components and the indentation specified by bindent.

* `ciblock : bindent -> format list -> format`

 ciblock binent fmts : Create a horizontally aligned block with no separators, with fmts as components and the indentation specified by bindent.

* `siblock : bindent -> element list -> format`

 sblock bindent elems : Create a special block with elems as components (mixing formats and separators) and the indentation specified by bindent.


[discrete]
==== Conditional rendering

* `flat : format -> format`

 flat fmt : returns a version of the argument fmt that will be rendered as flat (on a single line) and will have the same flat measure.

* `alt : format * format -> format`

 alt (fmt1, fmt2) : the resulting format renders as fmt1 if fmt1 fits, otherwise it renders as fmt2.

* `tryFlat : format -> format`

 tryFlat fmt : the result format renders as (flat fmt) if that fits, and otherwise renders as fmt.

* `hvblock : format list -> format`

 hvblock fmts : renders as (hblock fmts) if that fits, and otherwise renders as (vblock fmts).

[discrete]
==== Indented formats

* `softIndent : int -> format -> format`

 softIndent (fmt, n) : indent fmt n additional spaces (relative to parent block's blm) only if following a newline+indent.
 Otherwise render fmt normally.

* `hardIndent : int -> format -> format`

 hardIndent (fmt, n) : indent fmt n additional spaces (relative to parent block's blm) unconditionally.
 This will produce a newline + incremented indent (blm+n) if it does not follow a newline+indent, otherwise it just increases the indentation.

[discrete]
==== Basic formats

* `comma, colon, semicolon, period, lparen, rparen, lbracket, rbracket, lbrace, rbrace, equal : format`

 Punctuation characters as formats (plus the equal symbol).

* `integer : int -> format`

 integer n : Returns the string representation of n (Int.toString n) as a text format.

* `string : string -> format`

 string s : Formats the string s enclosed in double quotation marks.

* `char : char -> format`

 char c : Formats c as "#" ^ (string (Char.toString c)).

* `bool : string -> format`

 bool b : Formats the boolean value b as `text "true"` or `text "false"`.

[discrete]
==== Utility format construction functions

_Binary format combinators_

* `hcat : format * format -> format`

 hcat (fmt1, fmt2) = hblock [fmt1, fmt2] : Concatenates fmt1 and fmt2 with a (Space 1) separator.

* `vcat : format * format -> format`

 vcat (fmt1, fmt2) = vblock [fmt1, fmt2] : Concatenates fmt1 and fmt2 with a HardLine separator.

* `pcat : format * format -> format`

 pcat (fmt1, fmt2) = pblock [fmt1, fmt2] : Concatenates fmt1 and fmt2 with a (SoftLine 1) separator.

* `ccat : format * format -> format`

 ccat (fmt1, fmt2) = cblock [fmt1, fmt2] : Concatenates fmt1 and fmt2 without a separator.
 
Note that the empty format is an identity element for all of these binary concatenation operators.

[discrete]
==== Enclosing a format

* `enclose : {front: format, back: format} -> format -> format`

 enclose {front, back} fmt : concatenate front, fmt, and back.

* `parens: format -> format`

 parens fmt = enclose {front=lparen, back=rparen} fmt
   Enclose fmt with left and right parentheses.

* `brackets: format -> format`

 brackets fmt = enclose {front=lbracket, back=rbracket} fmt
   Enclose fmt with left and right square brackets. 

* `braces: format -> format`

 braces fmt = enclose {front=lbrace, back=rbrace} fmt
   Enclose fmt with left and right curly braces. 

[discrete]
==== Modifying a format

* `label : string -> format -> format

 label str fmt = hcat (ccat (text str, colon), fmt)

* `appendNewLine : format -> format

 append a hard newline after the format

[discrete]
==== Formatting lists of formats

* `sequence : alignment -> format -> format list -> format`

 sequence a sep fmts: inserts sep between the elements of fmts, aligning according to a.

* `hsequence : format -> format list -> format`

 hsequence = sequence H

* `psequence : format -> format list -> format`

 psequence = sequence P

* `vsequence : format -> format list -> format`

 vsequence = sequence V

* `csequence : format -> format list -> format`

 csequence = sequence C

* `tupleFormats : format list -> format`

 formats the members of the format list as a tuple (parenthesized, with elements
 separated by commas) with default packed (P) alignment of the element formats.

* `listFormats : format list -> format`

 formats the members of the format list as a list (bracketed, with elements
 separated by commas) with default packed (P) alignment of the element formats.

* `optionFormat : format option -> format`

 formats `fmtOp: format option` as `text "NONE"` or `ccat (text "SOME", parens (valof fmtOp)).

[discrete]
==== Formatting sequences of values of arbitrary types

* `formatSeq : {alignment: alignment, sep: format, formatter: 'a -> format} -> 'a list -> format`

 formatSeq {alignment, sep, formatter} xs : format the elements of xs using formatter, then 
 insert sep between these formats, and align the sequence elements according to the alignment
 parameter. E.g.
     formatSeq {alignment=H, sep=comma, formatter=integer} [1,2] =>
       sblock [FMT(integer 1), FMT comma, SEP(Space 1), FMT(integer 2)],
 which renders as:
     1, 2

* `formatClosedSeq :
     {alignment: alignment, front: format, sep: format, back: format, formatter: 'a -> format}
     -> 'a list
     -> format`

 formatClosedSeq {alignment, front, sep, back, formatter} xs = 
   enclose {front=front, back=back} (formatSeq {alignment, sep, formatter} xs).

* `tuple : ('a -> format) -> 'a list -> format`

 tuple formatter xs = parens (psequence comma (map formatter xs))

* `list : ('a -> format) -> 'a list -> format`

 list formatter xs = brackets (psequence comma (map formatter xs))

* `alignedList : alignment -> ('a -> format) -> 'a list -> format`

 alignedList alignment formatter xs : format the members of xs using formatter and then format
 those formats as a list (bracketed, with comma separator), aligned according to the alignment parameter.

* `option : ('a -> format) -> 'a option -> format`

 option values are treated as honorary sequences with 0 or 1 element. NONE is rendered as
 text "NONE", and SOME v is rendered as "SOME(formatter v)".

[discrete]
==== Setting and accessing the line width

* `setLineWidthFun : (unit -> int) -> unit`

 Defines the function that returns the current lineWidth value.

* `resetLineWidthFun : unit -> unit`

 Reset the lineWidthFun to the default lineWidthFun (which returns 90).

* `getLineWidth : unit -> int`

 Returns the current line width, obtained by calling the current lineWidthFun function.


[discrete]
==== Render and print functions

* `render : format * (string -> unit) * int -> unit`

 render (fmt, output, lineWidth): render fmt to output given lineWidth as the right margin.
 This prints directly using output without building a "layout" data structure.

* `printFormatLW : int -> format -> unit`

 Printing with an explicit lineWidth argument:
 printFormat lineWidth fmt = render (fmt, print, lineWidth)
 
* `printFormat : format -> unit`

 printFormat' fmt = printFormatLW (getLineWidth ()) fmt

* `printFormatNL : format -> unit`

 printFormat' fmt = printFormatLW (getLineWidth ()) (appendNewLine fmt)


== Usage and Examples

* How to produce a blank line in a layout?

 val doubleNewline : format = sblock [SEP Hardline, SEP HardLine]

.String to "paragraph"
====
----
fun formatPara (s: string) : format =
    let val tokens = String.tokens Char.isSpace s
     in pblock (map text tokens)
    end
----
====

.Tree Example from Wadler
====
----
datatype tree = Node of string * tree list

fun formatTree (Node (s, trees)) = 
    ccat (text s, formatTrees trees)

and formatTrees nil = empty
  | formatTrees trees =
      formatClosedSeq HardLine
        {front=lbracket, sep=comma, back=rbracket, formatter=formatTree}
	trees;

val tree1 =
    Node ("aaa",
	  [Node ("bbbbb",
		 [Node ("ccc", nil),
		  Node ("dd", nil)]),
	   Node ("eee", nil),
	   Node ("ffff",
		 [Node ("gg", nil),
		  Node ("hhh", nil),
		  Node ("ii", nil)])]);
----
====
Note that in this example, there are no SoftLine separators or soft indented blocks, so
the rendering of a tree value will not be sensitive to line width.
====
----
- printFormat 80 (formatTree tree1);
aaa[bbbbb[ccc,
          dd],
    eee,
    ffff[gg,
         hhh,
         ii]]
----
====

.Wadler's second style of formatting trees
====
----
fun formatTree' (Node (s, trees)) = 
    case trees
      of nil => text s
       | _ =>
          vblock [ccat (text s, lbracket),
                  hardIndent (2,
                    formatSeq HardLine
                      {sep=comma, formatter=formatTree'} trees),
                  rbracket];
----
====
Yielding:
====
----
- printFormat 80 (formatTree' tree1);
aaa[
  bbbbb[
    ccc,
    dd
  ],
  eee,
  ffff[
    gg,
    hhh,
    ii
  ]
]
----
====

* Simplified SML abstract syntax examples (let expressions, structure decls)

.Simple let expressions
====
----
datatype exp
  = Let of dcl list * exp list
  | Var of string
  | Num of int

and dcl
  = Val of string * exp

fun formatExp (Var s) = text s
  | formatExp (Num n) = integer n
  | formatExp (Let (dcls, exps)) =
      vblock
	[hcat (text "let", fmtDcls dcls),
         hcat (text "in", formatExps exps),
         text "end"]

and formatExps (exps) = vblock (map formatExp exps)

and fmtDcl (Val (name, exp)) =
    hblock [text "val", text name, text "=", formatExp exp]

and fmtDcls dcls = vblock (map fmtDcl dcls)

(* example *)

val exp1 = Let ([Val ("x", Num 1), Val ("y", Num 2)], [Var "x"]);

val exp1Format = tryFlat (formatExp exp1);
----
====
Outputs:
====
----
- printFormat 15 exp1Format;
let val x = 1
    val y = 2
in x
end

- printFmt 80 exp1Format;
let val x = 1 val y = 2 in x end
----
====

.simplified SML structure expressions and declarations
====
----
datatype str
  = SVAR of string
  | STRUCT of decl list

and decl
  = VALd of string * string
  | TYPd of string * string
  | STRd of string * str

(* formatDecl : (str -> format) -> decl -> format *)
fun formatDecl formatStr decl =
    (case decl
       of VALd (name, def) => hblock [text "val", text name, text "=", text def]
	| TYPd (name, def) => hblock [text "type", text name, text "=", text def]
	| STRd (name, str) => hblock [text "structure", text name, text "=", formatStr str])

(* formatStr1 : str -> format *)
fun formatStr1 (SVAR name) = text name
  | formatStr1 (STRUCT decls) = 
    let val body = viblock (HI 2) (map (formatDecl formatStr1) decls)
    in tryFlat (vblock [text "struct", body, text "end"])
    end

(* formatStr2 : str -> format *)
fun formatStr2 (SVAR name) = text name
  | formatStr2 (STRUCT decls) = 
    let val body = viblock (HI 2) (map (formatDecl formatStr2) decls)
    in tryFlat (viblock (HI 0) [text "struct", body, text "end"])
    end

(* formatDecl? : decl -> format *)
val formatDecl1 = formatDecl formatStr1
val formatDecl2 = formatDecl formatStr2

fun formatDecl3 (STRd (name, SVAR svar)) =
      hblock [text "structure", text name, text "=", text svar]
  | formatDecl3 (STRd (name, STRUCT decls)) =
      vblock
        [hblock [text "structure", text name, text "=", text "struct"],
	 viblock (HI 2) (map formatDecl3 decls),
	 text "end"]
  | formatDecl3 decl = formatDecl formatStr1 decl

(* examples *)

val str1 = STRUCT [TYPd ("t", "int list"), VALd ("x", "3")]

val str2 = STRUCT [TYPd ("s", "bool"), VALd ("y", "true"), STRd ("S", str1)]

val strd1 = STRd ("A", str1)
val strd2 = STRd ("B", str2)
----
====

Outputs:
====
----
(* using formatDecl1: *)

- printFormat 80 (formatDecl1 strd1);
structure A = struct type t = int list val x = 3 end

- printFormat 10 (formatDecl1 strd1);
structure A = struct
                type t = int list
                val x = 3
              end

(* using formatDecl2: *)

- printFormat 80 (formatDecl2 strd1);
structure A = struct type t = int list val x = 3 end

- printFormat 10 (formatDecl2 strd1);
structure A = 
struct
  type t = int list
  val x = 3
end

(* using formatDecl3: *)

- printFormat 80 (formatDecl3 strd1);
structure A = struct
  type t = int list
  val x = 3
end
----
====

* Correspondences with Haskell Prettyprinter interface

Rough analogs of Haskell Prettyprinter types and functions: 
----
      Haskell Prettyprinter     New Prettyprinter
      ---------------------     -----------------

      type doc                  type format

      <+>                       hcat

      hsep                      hblock

      vsep                      vblock

      fillsep                   pblock

      sep                       hvblock

      hcat                      ccat

      vcat xs                   alt (vblock xs, hblock xs); hvblock

      enclose, surround         enclose

      Union, group              alt, tryFlat

      flatten                   FLAT (format data constructor, hidden)

      nest                      hiblock, viblock, piblock, ciblock
                                softIndent, hardIndent
----

== Implementation

* The basic datatypes for formats
 ** `EMPTY` is the empty format that prints nothing and acts as an identity element with respect to
    concatenation of formats or composition of blocks.
 ** `TEXT` constructs atomic text blocks.
 ** `SBLOCK` constructs "special" blocks with explicit separator (`SEP`) elements mixed with format (`FMT`) elements.
 ** `ABLOCK` constructs "aligned" blocks, where alignment is determined by the choice of the alignment,
 which in turn determines the virtual separator between component formats:
Horizontal: `Space 1`; Vertical: `HardLine`; Packed: `SoftLine 1`.
 ** `FLAT` converts an arbitrary format to one which is rendered as flat.
 ** `ALT` takes a pair of formats, `(fmt1, fmt2)` and constructs a format that is
rendered as `fmt1` if it fits, and otherwise is rendered as `fmt2`. Note that the two formats are not
constrained to have the same content; for instance, `fmt2` might be an abbreviated version of `fmt2`.

.The format and element datatypes:
----
datatype format
  = TEXT  of string
  | SBLOCK of {elements: element list, bindent: bindent, measure: int}
  | ABLOCK of {formats: format list, alignment: alignment, bindent: bindent, measure: int}
  | FLAT of format
  | ALT of format * format

and element  (* of SBLOCKs *)
  = SEP of separator  (* separators are _not_, and do not contain, content *)
  | FMT of format
----

* Format measure, memoization

The measure of a `TEXT` block is just the length of its string contents.

The measure of a `FLAT` format is just the (default, flat) measure of its component format.
The measure of a `ALT (fmt1, fmt2)` format is the (flat) measure of `fmt1`, which is normally
expected to be the "wider" of the two formats.

The measure of a compound block format is the length of the format as rendered on a single, unbounded line.
This is the sum of the flat measures of its component formats plus `sepMeasure s` for each explicit or
implicit separator `s`, where `sepMeasure` is defined as follows:
----
fun sepMeasure (Space n) = n
  | sepMeasure (SoftLine n) = n
  | sepMeasure HardLine = 1
----

The _measure_ fields of the `SBLOCK` and `ABLOCK` constructors are used to _memoize_ the measure function
over formats to avoid having to recompute the measures of nested blocks. 

* Rendering

`FLAT` formats (used in `tryFlat`, for instance) are rendered _flat_, meaning that all separators `s`
are rendered as though they were `Space (sepMeasure s)`, and no newline+indent are generated when
rendering indented blocks.

== Discussion

. Why have both hard and soft line breaks?
+
* Having a vblock vertical alignment mode implies unconditional line breaks anyway.
* Having a choice of hard and soft (conditional) line breaks provides more control of the layout.
+
. An indented block produces its own preceding newline+indent only if the block does not follow a newline+indent, and only if the indentation is hard.
+
. The importance of the blm boundary (and no "outdent").
+
We claim that is simplifies the "semantics" of the prettyprinting system if the content of a block
is bounded by a left margin, the `blm`, determined by the column in which the block starts. This goes
along with the indentation principle: a block is indented as a whole, and the indentation applies to
the entire content of the block. Other systems, where indentation only applies after newlines in a
block's multi-line layout, make it harder to keep track of the indentation structure and what it
represents in terms of the data structure being presented.

== Future Work (possible new features or improvements)

* Multi-line measurement of formats (this has been implemented in Version 8 of this library).

* Tabs. Setting tabs would be related to separators and would only be accessible at a block's
"top level".

* Tabular formatting (i.e. tables).

* Rendering to a layout type (instead of printing directly in the render function).

* Ribbon percentage as a second constraint controling rendering. This should be easy to
add to this scheme.

* _styles_ (similar to WL _annotations_).

** non-fixed character widths (fonts and type faces).
** color and emphasis (italics and boldface).

* Alternate rendering targets (e.g. HTML); _devices_.

* _Holophrastic_ formatting or rendering, _i.e._, truncating or abbreviating to conserve space.
+
This is probably not something that should be supported in a generic way by the prettyprinting
library. It is normally implemented as part of a particular prettyprinter (as is done, for
instance, in the SML/NJ prettyprinters for abstract syntax and for various IRs by passing a
"printdepth" parameter through the prettyprinter and decrementing it for each level of structure.
