functor SMLLrValsFun(structure Token : TOKEN)
 : sig structure ParserData : PARSER_DATA
       structure Tokens : SML_TOKENS
   end
 = 
struct
structure ParserData=
struct
structure Header = 
struct
(* sml.grm
 *
 * COPYRIGHT (c) 2018 The Fellowship of SML/NJ (http://www.smlnj.org)
 * All rights reserved.
 *
 * This version of the parser supports the following Successor ML syntactic extensions.
 *
 *	optional "|" at the beginning of a match
 *
 *	optional ";" at the end of a sequence of statements (TODO)
 *
 *	"do" exp syntax where "val" bindings are allowed.
 *)

open Ast ErrorMsg Symbol FastSymbol AstUtil Fixity

type raw_symbol = FastSymbol.raw_symbol

fun markexp (e as MarkExp _, _, _) = e
  | markexp(e,a,b) = MarkExp(e,(a,b))
fun markpat (p as MarkPat _, _, _) = p
  | markpat(p,a,b) = MarkPat(p,(a,b))
fun markdec(d as MarkDec _, _,_) = d
  | markdec(d,a,b) = MarkDec(d,(a,b))

val asteriskHash = HashString.hashString "*"
val asteriskString = "*"
val equalHash = HashString.hashString "="
val equalString = "="
val bogusHash = HashString.hashString "BOGUS"
val bogusString = "BOGUS"
val quotedBogusHash = HashString.hashString "'BOGUS"
val quotedBogusString = "'BOGUS"
val quotedBogusHash = HashString.hashString "'BOGUS"
val quotedBogusString = "'BOGUS"

(* ID (identifiers) is split into IDA (alphanumeric) and IDS (symbolic) *)
  
end
structure LrTable = Token.LrTable
structure Token = Token
local open LrTable in 
val table=let val actionRows =
"\
\\001\000\001\000\000\000\002\000\000\000\000\000\
\\001\000\003\000\053\000\004\000\052\000\006\000\051\000\007\000\050\000\
\\008\000\049\000\009\000\048\000\010\000\047\000\011\000\046\000\
\\012\000\045\000\017\000\044\000\018\000\043\000\022\000\042\000\
\\024\000\041\000\025\000\040\000\028\000\039\000\029\000\038\000\
\\030\000\037\000\032\000\036\000\033\000\035\000\036\000\034\000\
\\037\000\033\000\039\000\032\000\040\000\031\000\041\000\030\000\
\\043\000\029\000\044\000\028\000\045\000\027\000\046\000\026\000\
\\050\000\025\000\052\000\024\000\054\000\023\000\055\000\022\000\
\\057\000\021\000\061\000\020\000\065\000\019\000\066\000\018\000\
\\067\000\017\000\073\000\016\000\074\000\015\000\075\000\014\000\
\\078\000\013\000\000\000\
\\001\000\003\000\053\000\004\000\052\000\006\000\051\000\007\000\050\000\
\\008\000\049\000\009\000\048\000\010\000\047\000\011\000\046\000\
\\017\000\044\000\022\000\042\000\028\000\039\000\032\000\036\000\
\\033\000\035\000\039\000\032\000\043\000\029\000\046\000\026\000\
\\057\000\021\000\061\000\020\000\065\000\019\000\066\000\018\000\
\\067\000\017\000\069\000\069\000\074\000\015\000\075\000\014\000\
\\078\000\013\000\000\000\
\\001\000\003\000\053\000\004\000\052\000\006\000\051\000\007\000\050\000\
\\008\000\049\000\009\000\048\000\010\000\047\000\011\000\046\000\
\\017\000\044\000\022\000\042\000\028\000\039\000\032\000\036\000\
\\033\000\035\000\039\000\032\000\043\000\029\000\046\000\026\000\
\\057\000\021\000\061\000\020\000\065\000\019\000\066\000\018\000\
\\067\000\017\000\069\000\077\000\074\000\015\000\075\000\014\000\
\\078\000\013\000\000\000\
\\001\000\003\000\053\000\004\000\052\000\006\000\051\000\007\000\050\000\
\\008\000\049\000\009\000\048\000\010\000\047\000\011\000\046\000\
\\017\000\044\000\022\000\042\000\028\000\039\000\032\000\036\000\
\\033\000\035\000\039\000\032\000\043\000\029\000\046\000\026\000\
\\057\000\021\000\061\000\020\000\065\000\019\000\066\000\018\000\
\\067\000\017\000\070\000\075\000\074\000\015\000\075\000\014\000\
\\078\000\013\000\000\000\
\\001\000\003\000\053\000\004\000\052\000\006\000\051\000\007\000\050\000\
\\008\000\049\000\009\000\048\000\010\000\047\000\011\000\046\000\
\\017\000\044\000\022\000\042\000\028\000\039\000\032\000\036\000\
\\033\000\035\000\039\000\032\000\043\000\029\000\046\000\026\000\
\\057\000\021\000\061\000\020\000\065\000\019\000\066\000\018\000\
\\067\000\017\000\074\000\015\000\075\000\014\000\078\000\013\000\000\000\
\\001\000\003\000\057\000\004\000\052\000\022\000\042\000\061\000\020\000\000\000\
\\001\000\003\000\071\000\000\000\
\\001\000\003\000\086\000\004\000\085\000\006\000\084\000\019\000\219\000\
\\061\000\083\000\000\000\
\\001\000\003\000\086\000\004\000\085\000\006\000\084\000\019\000\219\000\
\\061\000\083\000\068\000\218\000\000\000\
\\001\000\003\000\086\000\004\000\085\000\006\000\084\000\061\000\083\000\000\000\
\\001\000\003\000\086\000\004\000\085\000\006\000\084\000\061\000\083\000\
\\068\000\082\000\000\000\
\\001\000\003\000\086\000\004\000\085\000\006\000\084\000\061\000\083\000\
\\068\000\032\001\000\000\
\\001\000\003\000\086\000\004\000\085\000\038\000\225\000\043\000\224\000\
\\061\000\083\000\067\000\223\000\000\000\
\\001\000\003\000\086\000\004\000\085\000\043\000\224\000\061\000\083\000\
\\067\000\223\000\000\000\
\\001\000\003\000\086\000\004\000\085\000\061\000\083\000\000\000\
\\001\000\003\000\108\000\004\000\085\000\005\000\107\000\006\000\051\000\
\\007\000\050\000\008\000\106\000\010\000\105\000\011\000\104\000\
\\038\000\103\000\043\000\102\000\047\000\101\000\058\000\100\000\
\\061\000\083\000\065\000\099\000\066\000\098\000\067\000\097\000\
\\074\000\096\000\000\000\
\\001\000\003\000\108\000\004\000\085\000\005\000\107\000\006\000\051\000\
\\007\000\050\000\008\000\106\000\010\000\105\000\011\000\104\000\
\\038\000\144\000\043\000\102\000\058\000\100\000\061\000\083\000\
\\065\000\099\000\066\000\098\000\067\000\097\000\074\000\096\000\000\000\
\\001\000\003\000\108\000\004\000\085\000\005\000\211\000\006\000\051\000\
\\007\000\050\000\008\000\106\000\010\000\105\000\011\000\104\000\
\\043\000\102\000\058\000\100\000\061\000\083\000\065\000\099\000\
\\066\000\098\000\067\000\149\000\070\000\210\000\074\000\096\000\000\000\
\\001\000\003\000\108\000\004\000\085\000\006\000\051\000\007\000\050\000\
\\008\000\106\000\010\000\105\000\011\000\104\000\016\000\150\000\
\\043\000\102\000\058\000\100\000\061\000\083\000\065\000\099\000\
\\066\000\098\000\067\000\149\000\074\000\096\000\000\000\
\\001\000\003\000\108\000\004\000\085\000\006\000\051\000\007\000\050\000\
\\008\000\106\000\010\000\105\000\011\000\104\000\038\000\103\000\
\\043\000\102\000\047\000\199\000\058\000\100\000\061\000\083\000\
\\065\000\099\000\066\000\098\000\067\000\149\000\074\000\096\000\000\000\
\\001\000\003\000\108\000\004\000\085\000\006\000\051\000\007\000\050\000\
\\008\000\106\000\010\000\105\000\011\000\104\000\038\000\103\000\
\\043\000\102\000\058\000\100\000\061\000\083\000\065\000\099\000\
\\066\000\098\000\067\000\149\000\074\000\096\000\000\000\
\\001\000\003\000\108\000\004\000\085\000\006\000\051\000\007\000\050\000\
\\008\000\106\000\010\000\105\000\011\000\104\000\038\000\144\000\
\\043\000\102\000\058\000\100\000\061\000\083\000\065\000\099\000\
\\066\000\098\000\067\000\149\000\074\000\096\000\000\000\
\\001\000\003\000\108\000\004\000\085\000\006\000\051\000\007\000\050\000\
\\008\000\106\000\010\000\105\000\011\000\104\000\043\000\102\000\
\\058\000\100\000\061\000\083\000\065\000\099\000\066\000\098\000\
\\067\000\149\000\069\000\207\000\074\000\096\000\000\000\
\\001\000\003\000\108\000\004\000\085\000\006\000\051\000\007\000\050\000\
\\008\000\106\000\010\000\105\000\011\000\104\000\043\000\102\000\
\\058\000\100\000\061\000\083\000\065\000\099\000\066\000\098\000\
\\067\000\149\000\069\000\213\000\074\000\096\000\000\000\
\\001\000\003\000\108\000\004\000\085\000\006\000\051\000\007\000\050\000\
\\008\000\106\000\010\000\105\000\011\000\104\000\043\000\102\000\
\\058\000\100\000\061\000\083\000\065\000\099\000\066\000\098\000\
\\067\000\149\000\070\000\210\000\074\000\096\000\000\000\
\\001\000\003\000\108\000\004\000\085\000\006\000\051\000\007\000\050\000\
\\008\000\106\000\010\000\105\000\011\000\104\000\043\000\102\000\
\\058\000\100\000\061\000\083\000\065\000\099\000\066\000\098\000\
\\067\000\149\000\074\000\096\000\000\000\
\\001\000\003\000\114\000\000\000\
\\001\000\003\000\116\000\000\000\
\\001\000\003\000\122\000\004\000\085\000\039\000\189\001\051\000\188\001\
\\061\000\083\000\000\000\
\\001\000\003\000\122\000\004\000\085\000\039\000\201\001\061\000\083\000\000\000\
\\001\000\003\000\122\000\004\000\085\000\054\000\157\001\061\000\083\000\000\000\
\\001\000\003\000\122\000\004\000\085\000\054\000\003\002\061\000\083\000\000\000\
\\001\000\003\000\122\000\004\000\085\000\061\000\083\000\000\000\
\\001\000\003\000\124\000\004\000\052\000\022\000\042\000\061\000\020\000\000\000\
\\001\000\003\000\138\000\000\000\
\\001\000\003\000\163\000\004\000\162\000\000\000\
\\001\000\003\000\163\000\004\000\162\000\005\000\107\000\038\000\161\000\
\\067\000\160\000\000\000\
\\001\000\003\000\179\000\004\000\162\000\000\000\
\\001\000\003\000\179\000\004\000\162\000\005\000\178\000\065\000\177\000\
\\067\000\176\000\000\000\
\\001\000\003\000\183\000\006\000\051\000\007\000\050\000\008\000\049\000\
\\009\000\048\000\010\000\047\000\011\000\046\000\032\000\036\000\
\\039\000\032\000\043\000\029\000\065\000\019\000\066\000\018\000\
\\067\000\017\000\074\000\015\000\075\000\014\000\078\000\013\000\000\000\
\\001\000\003\000\227\000\004\000\085\000\061\000\083\000\000\000\
\\001\000\003\000\023\001\004\000\052\000\022\000\042\000\061\000\020\000\000\000\
\\001\000\003\000\093\001\049\000\092\001\000\000\
\\001\000\003\000\109\001\000\000\
\\001\000\003\000\110\001\000\000\
\\001\000\003\000\153\001\000\000\
\\001\000\003\000\159\001\049\000\092\001\000\000\
\\001\000\003\000\161\001\000\000\
\\001\000\003\000\028\002\000\000\
\\001\000\005\000\211\000\000\000\
\\001\000\013\000\231\000\059\000\212\001\000\000\
\\001\000\014\000\024\001\015\000\192\001\000\000\
\\001\000\014\000\024\001\064\000\140\001\070\000\139\001\000\000\
\\001\000\015\000\204\000\016\000\069\001\062\000\202\000\064\000\068\001\
\\070\000\067\001\000\000\
\\001\000\015\000\204\000\022\000\203\000\062\000\202\000\000\000\
\\001\000\015\000\204\000\022\000\084\001\062\000\202\000\000\000\
\\001\000\015\000\204\000\027\000\007\001\062\000\202\000\000\000\
\\001\000\015\000\240\000\062\000\239\000\000\000\
\\001\000\015\000\076\001\022\000\091\002\062\000\075\001\064\000\190\002\
\\068\000\190\002\000\000\
\\001\000\020\000\197\001\031\000\062\000\062\000\061\000\071\000\060\000\
\\072\000\059\000\000\000\
\\001\000\021\000\194\001\000\000\
\\001\000\021\000\195\001\000\000\
\\001\000\021\000\213\001\000\000\
\\001\000\021\000\004\002\000\000\
\\001\000\021\000\007\002\000\000\
\\001\000\021\000\038\002\000\000\
\\001\000\021\000\051\002\000\000\
\\001\000\021\000\068\002\062\000\246\001\063\000\245\001\000\000\
\\001\000\021\000\070\002\000\000\
\\001\000\021\000\071\002\000\000\
\\001\000\022\000\091\002\064\000\118\002\068\000\118\002\000\000\
\\001\000\022\000\196\000\000\000\
\\001\000\022\000\238\000\000\000\
\\001\000\022\000\015\001\000\000\
\\001\000\022\000\020\001\000\000\
\\001\000\022\000\037\001\000\000\
\\001\000\022\000\074\001\000\000\
\\001\000\022\000\077\001\000\000\
\\001\000\022\000\086\001\000\000\
\\001\000\022\000\090\001\000\000\
\\001\000\022\000\108\001\000\000\
\\001\000\022\000\112\001\000\000\
\\001\000\022\000\123\001\000\000\
\\001\000\022\000\182\001\000\000\
\\001\000\022\000\198\001\000\000\
\\001\000\022\000\211\001\000\000\
\\001\000\022\000\228\001\000\000\
\\001\000\022\000\046\002\000\000\
\\001\000\022\000\069\002\000\000\
\\001\000\025\000\197\000\031\000\062\000\062\000\061\000\071\000\060\000\
\\072\000\059\000\000\000\
\\001\000\026\000\167\000\000\000\
\\001\000\031\000\062\000\042\000\017\001\062\000\061\000\071\000\060\000\
\\072\000\059\000\000\000\
\\001\000\031\000\062\000\053\000\251\000\062\000\061\000\071\000\060\000\
\\072\000\059\000\000\000\
\\001\000\034\000\244\000\000\000\
\\001\000\034\000\247\000\000\000\
\\001\000\034\000\104\001\000\000\
\\001\000\034\000\044\002\000\000\
\\001\000\034\000\049\002\000\000\
\\001\000\034\000\058\002\000\000\
\\001\000\059\000\019\001\060\000\018\001\000\000\
\\001\000\062\000\143\001\000\000\
\\001\000\062\000\167\001\000\000\
\\001\000\062\000\226\001\000\000\
\\001\000\062\000\235\001\067\000\188\000\000\000\
\\001\000\062\000\246\001\063\000\245\001\070\000\057\002\000\000\
\\001\000\062\000\017\002\000\000\
\\001\000\062\000\027\002\000\000\
\\001\000\067\000\188\000\000\000\
\\001\000\068\000\194\000\000\000\
\\001\000\068\000\072\001\000\000\
\\001\000\068\000\141\001\000\000\
\\001\000\069\000\184\000\000\000\
\\001\000\069\000\193\000\000\000\
\\001\000\069\000\064\001\000\000\
\\001\000\069\000\071\001\000\000\
\\001\000\070\000\189\000\000\000\
\\001\000\070\000\192\000\000\000\
\\001\000\070\000\066\001\000\000\
\\001\000\070\000\088\001\000\000\
\\001\000\070\000\138\001\000\000\
\\001\000\070\000\146\001\000\000\
\\001\000\070\000\180\001\000\000\
\\001\000\070\000\240\001\000\000\
\\001\000\070\000\241\001\000\000\
\\001\000\070\000\056\002\000\000\
\\001\000\076\000\066\000\077\000\065\000\000\000\
\\001\000\076\000\181\000\000\000\
\\074\002\000\000\
\\075\002\000\000\
\\076\002\000\000\
\\076\002\026\000\229\000\000\000\
\\076\002\026\000\242\000\000\000\
\\076\002\026\000\083\001\000\000\
\\077\002\000\000\
\\078\002\000\000\
\\079\002\000\000\
\\079\002\026\000\033\001\000\000\
\\080\002\000\000\
\\081\002\000\000\
\\081\002\026\000\167\000\000\000\
\\081\002\026\000\243\000\000\000\
\\081\002\026\000\134\001\000\000\
\\082\002\000\000\
\\083\002\000\000\
\\084\002\000\000\
\\085\002\000\000\
\\086\002\016\000\129\001\018\000\128\001\043\000\154\000\000\000\
\\086\002\016\000\129\001\043\000\154\000\000\000\
\\086\002\043\000\154\000\000\000\
\\087\002\000\000\
\\088\002\000\000\
\\089\002\000\000\
\\090\002\000\000\
\\091\002\000\000\
\\092\002\000\000\
\\093\002\000\000\
\\094\002\000\000\
\\095\002\014\000\024\001\000\000\
\\096\002\000\000\
\\097\002\064\000\142\001\000\000\
\\098\002\000\000\
\\099\002\000\000\
\\100\002\000\000\
\\101\002\000\000\
\\102\002\000\000\
\\103\002\000\000\
\\104\002\000\000\
\\105\002\000\000\
\\106\002\003\000\179\000\004\000\162\000\061\000\026\001\000\000\
\\107\002\000\000\
\\108\002\014\000\024\001\000\000\
\\109\002\003\000\179\000\004\000\162\000\061\000\026\001\000\000\
\\110\002\014\000\024\001\064\000\140\001\000\000\
\\111\002\000\000\
\\112\002\000\000\
\\113\002\000\000\
\\114\002\016\000\008\001\000\000\
\\115\002\000\000\
\\116\002\031\000\062\000\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\\117\002\031\000\062\000\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\\119\002\000\000\
\\120\002\064\000\195\000\000\000\
\\121\002\002\000\191\000\031\000\062\000\062\000\061\000\064\000\190\000\
\\071\000\060\000\072\000\059\000\000\000\
\\121\002\002\000\191\000\031\000\062\000\062\000\061\000\071\000\060\000\
\\072\000\059\000\000\000\
\\122\002\000\000\
\\123\002\000\000\
\\124\002\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\\125\002\062\000\061\000\072\000\059\000\000\000\
\\126\002\014\000\024\001\000\000\
\\127\002\000\000\
\\128\002\000\000\
\\129\002\000\000\
\\130\002\031\000\062\000\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\\131\002\031\000\062\000\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\\132\002\031\000\062\000\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\\133\002\003\000\053\000\004\000\052\000\006\000\051\000\007\000\050\000\
\\008\000\049\000\009\000\048\000\010\000\047\000\011\000\046\000\
\\022\000\042\000\032\000\036\000\039\000\032\000\043\000\029\000\
\\061\000\020\000\065\000\019\000\066\000\018\000\067\000\017\000\
\\074\000\015\000\075\000\014\000\078\000\013\000\000\000\
\\134\002\003\000\053\000\004\000\052\000\006\000\051\000\007\000\050\000\
\\008\000\049\000\009\000\048\000\010\000\047\000\011\000\046\000\
\\022\000\042\000\032\000\036\000\039\000\032\000\043\000\029\000\
\\061\000\020\000\065\000\019\000\066\000\018\000\067\000\017\000\
\\074\000\015\000\075\000\014\000\078\000\013\000\000\000\
\\135\002\000\000\
\\136\002\000\000\
\\137\002\000\000\
\\138\002\000\000\
\\139\002\000\000\
\\140\002\000\000\
\\141\002\000\000\
\\142\002\000\000\
\\143\002\000\000\
\\144\002\000\000\
\\145\002\000\000\
\\146\002\000\000\
\\147\002\000\000\
\\148\002\000\000\
\\149\002\000\000\
\\150\002\000\000\
\\151\002\000\000\
\\152\002\000\000\
\\153\002\000\000\
\\154\002\000\000\
\\155\002\000\000\
\\156\002\000\000\
\\157\002\000\000\
\\158\002\000\000\
\\159\002\000\000\
\\160\002\077\000\065\000\000\000\
\\161\002\000\000\
\\162\002\000\000\
\\163\002\031\000\062\000\062\000\061\000\064\000\190\000\071\000\060\000\
\\072\000\059\000\000\000\
\\164\002\031\000\062\000\062\000\061\000\064\000\185\000\071\000\060\000\
\\072\000\059\000\000\000\
\\165\002\000\000\
\\166\002\015\000\204\000\062\000\202\000\000\000\
\\167\002\014\000\024\001\000\000\
\\168\002\000\000\
\\169\002\000\000\
\\170\002\000\000\
\\171\002\000\000\
\\172\002\000\000\
\\173\002\000\000\
\\174\002\000\000\
\\175\002\000\000\
\\176\002\000\000\
\\177\002\000\000\
\\178\002\000\000\
\\179\002\000\000\
\\180\002\000\000\
\\181\002\000\000\
\\182\002\000\000\
\\183\002\000\000\
\\184\002\000\000\
\\185\002\000\000\
\\186\002\000\000\
\\187\002\000\000\
\\188\002\000\000\
\\189\002\015\000\204\000\062\000\202\000\000\000\
\\191\002\015\000\204\000\062\000\202\000\000\000\
\\192\002\014\000\024\001\015\000\243\001\000\000\
\\193\002\015\000\204\000\062\000\202\000\000\000\
\\194\002\000\000\
\\195\002\064\000\073\001\000\000\
\\196\002\000\000\
\\197\002\015\000\204\000\062\000\202\000\064\000\065\001\000\000\
\\198\002\000\000\
\\199\002\015\000\204\000\016\000\242\001\062\000\202\000\000\000\
\\200\002\000\000\
\\201\002\013\000\200\000\000\000\
\\202\002\031\000\062\000\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\\203\002\031\000\062\000\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\\204\002\062\000\004\001\000\000\
\\205\002\014\000\024\001\000\000\
\\206\002\013\000\078\001\000\000\
\\207\002\031\000\062\000\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\\208\002\031\000\062\000\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\\209\002\000\000\
\\210\002\000\000\
\\211\002\000\000\
\\212\002\016\000\002\001\000\000\
\\213\002\000\000\
\\214\002\013\000\005\001\000\000\
\\215\002\013\000\115\001\000\000\
\\216\002\000\000\
\\217\002\000\000\
\\218\002\003\000\108\000\004\000\085\000\006\000\051\000\007\000\050\000\
\\008\000\106\000\010\000\105\000\011\000\104\000\043\000\102\000\
\\058\000\100\000\061\000\083\000\065\000\099\000\066\000\098\000\
\\067\000\149\000\074\000\096\000\000\000\
\\219\002\000\000\
\\220\002\031\000\062\000\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\\221\002\014\000\024\001\000\000\
\\222\002\013\000\231\000\000\000\
\\223\002\000\000\
\\224\002\000\000\
\\225\002\005\000\112\000\067\000\111\000\000\000\
\\226\002\000\000\
\\227\002\000\000\
\\228\002\064\000\070\001\000\000\
\\229\002\000\000\
\\230\002\000\000\
\\231\002\013\000\013\001\000\000\
\\232\002\000\000\
\\233\002\000\000\
\\234\002\000\000\
\\235\002\000\000\
\\236\002\000\000\
\\237\002\000\000\
\\238\002\016\000\207\001\000\000\
\\239\002\000\000\
\\240\002\042\000\013\002\000\000\
\\241\002\014\000\024\001\000\000\
\\242\002\022\000\120\001\042\000\119\001\000\000\
\\243\002\014\000\024\001\000\000\
\\244\002\000\000\
\\245\002\013\000\010\001\000\000\
\\246\002\003\000\122\000\004\000\085\000\061\000\083\000\000\000\
\\247\002\000\000\
\\248\002\006\000\051\000\007\000\050\000\000\000\
\\249\002\000\000\
\\250\002\006\000\051\000\007\000\050\000\000\000\
\\251\002\000\000\
\\252\002\000\000\
\\253\002\013\000\200\000\000\000\
\\254\002\013\000\200\000\000\000\
\\255\002\013\000\078\001\000\000\
\\000\003\013\000\078\001\000\000\
\\001\003\000\000\
\\002\003\000\000\
\\003\003\013\000\231\000\000\000\
\\004\003\000\000\
\\005\003\060\000\012\001\000\000\
\\006\003\013\000\231\000\000\000\
\\007\003\000\000\
\\008\003\000\000\
\\009\003\013\000\010\001\000\000\
\\010\003\000\000\
\\011\003\000\000\
\\012\003\031\000\062\000\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\\013\003\000\000\
\\014\003\000\000\
\\015\003\013\000\193\001\031\000\062\000\062\000\061\000\071\000\060\000\
\\072\000\059\000\000\000\
\\016\003\000\000\
\\017\003\002\000\131\000\012\000\045\000\018\000\043\000\024\000\041\000\
\\025\000\040\000\029\000\038\000\036\000\034\000\037\000\033\000\
\\040\000\130\000\041\000\030\000\044\000\028\000\045\000\027\000\
\\054\000\023\000\055\000\022\000\000\000\
\\018\003\000\000\
\\019\003\000\000\
\\020\003\000\000\
\\021\003\003\000\057\000\004\000\052\000\022\000\042\000\061\000\020\000\000\000\
\\022\003\000\000\
\\023\003\002\000\051\001\003\000\050\001\018\000\049\001\023\000\048\001\
\\024\000\047\001\030\000\046\001\035\000\045\001\048\000\044\001\
\\052\000\043\001\054\000\042\001\055\000\041\001\000\000\
\\023\003\002\000\051\001\018\000\049\001\023\000\048\001\024\000\047\001\
\\030\000\046\001\035\000\045\001\048\000\044\001\052\000\043\001\
\\054\000\042\001\055\000\041\001\000\000\
\\024\003\000\000\
\\025\003\000\000\
\\026\003\013\000\225\001\000\000\
\\027\003\013\000\232\001\000\000\
\\028\003\000\000\
\\029\003\060\000\238\001\000\000\
\\030\003\013\000\231\000\000\000\
\\031\003\013\000\223\001\000\000\
\\032\003\013\000\223\001\000\000\
\\033\003\013\000\221\001\000\000\
\\034\003\013\000\236\001\000\000\
\\035\003\013\000\227\001\000\000\
\\036\003\056\000\190\001\000\000\
\\037\003\000\000\
\\038\003\003\000\231\001\000\000\
\\039\003\000\000\
\\040\003\013\000\225\001\000\000\
\\041\003\022\000\054\002\056\000\190\001\000\000\
\\042\003\000\000\
\\043\003\013\000\232\001\000\000\
\\044\003\000\000\
\\045\003\013\000\223\001\000\000\
\\046\003\022\000\019\002\000\000\
\\047\003\014\000\024\001\000\000\
\\048\003\013\000\221\001\000\000\
\\049\003\014\000\024\001\000\000\
\\050\003\013\000\236\001\000\000\
\\051\003\042\000\237\001\000\000\
\\052\003\014\000\024\001\000\000\
\\053\003\013\000\227\001\000\000\
\\054\003\000\000\
\\055\003\000\000\
\\056\003\022\000\228\001\000\000\
\\057\003\000\000\
\\058\003\013\000\045\002\000\000\
\\059\003\014\000\024\001\000\000\
\\060\003\000\000\
\\061\003\000\000\
\\061\003\003\000\231\001\000\000\
\\062\003\000\000\
\\063\003\013\000\045\002\000\000\
\\064\003\062\000\236\000\063\000\235\000\000\000\
\\065\003\056\000\190\001\000\000\
\\066\003\056\000\190\001\000\000\
\\067\003\062\000\000\001\063\000\255\000\067\000\188\000\000\000\
\\068\003\000\000\
\\069\003\000\000\
\\070\003\013\000\237\000\000\000\
\\071\003\056\000\190\001\000\000\
\\072\003\013\000\186\000\000\000\
\\073\003\056\000\190\001\000\000\
\\074\003\000\000\
\\075\003\056\000\190\001\000\000\
\\076\003\067\000\248\001\000\000\
\\077\003\000\000\
\\078\003\000\000\
\\079\003\000\000\
\\080\003\056\000\190\001\000\000\
\\081\003\056\000\190\001\000\000\
\\082\003\000\000\
\\083\003\000\000\
\\084\003\067\000\248\001\000\000\
\\085\003\067\000\248\001\000\000\
\\086\003\000\000\
\\087\003\000\000\
\\088\003\002\000\255\001\003\000\122\000\004\000\085\000\012\000\045\000\
\\018\000\043\000\024\000\041\000\025\000\040\000\029\000\038\000\
\\030\000\254\001\036\000\034\000\037\000\033\000\039\000\189\001\
\\040\000\253\001\041\000\030\000\044\000\028\000\045\000\027\000\
\\051\000\188\001\052\000\252\001\054\000\023\000\055\000\022\000\
\\061\000\083\000\000\000\
\\088\003\002\000\255\001\012\000\045\000\018\000\043\000\024\000\041\000\
\\025\000\040\000\029\000\038\000\030\000\254\001\036\000\034\000\
\\037\000\033\000\040\000\253\001\041\000\030\000\044\000\028\000\
\\045\000\027\000\052\000\252\001\054\000\023\000\055\000\022\000\000\000\
\\089\003\000\000\
\\090\003\000\000\
\\091\003\002\000\127\000\012\000\045\000\018\000\043\000\024\000\041\000\
\\025\000\040\000\029\000\038\000\030\000\037\000\036\000\034\000\
\\037\000\033\000\040\000\031\000\041\000\030\000\044\000\028\000\
\\045\000\027\000\050\000\025\000\052\000\024\000\054\000\023\000\
\\055\000\022\000\073\000\016\000\000\000\
\\092\003\000\000\
\\093\003\012\000\045\000\018\000\043\000\024\000\041\000\025\000\040\000\
\\029\000\038\000\030\000\037\000\036\000\034\000\037\000\033\000\
\\040\000\031\000\041\000\030\000\044\000\028\000\045\000\027\000\
\\050\000\025\000\052\000\024\000\054\000\023\000\055\000\022\000\
\\073\000\016\000\000\000\
\\094\003\013\000\233\000\000\000\
\\095\003\013\000\252\000\000\000\
\\096\003\000\000\
\\097\003\000\000\
\\098\003\013\000\233\000\000\000\
\\099\003\013\000\237\000\000\000\
\\100\003\013\000\186\000\000\000\
\\101\003\013\000\252\000\000\000\
\\102\003\000\000\
\\103\003\000\000\
\\104\003\062\000\246\001\063\000\245\001\000\000\
\\105\003\013\000\233\000\000\000\
\\106\003\056\000\190\001\000\000\
\\107\003\000\000\
\\108\003\067\000\188\000\000\000\
\\109\003\000\000\
\\110\003\062\000\246\001\063\000\245\001\000\000\
\\111\003\000\000\
\\112\003\013\000\252\000\000\000\
\\113\003\067\000\248\001\000\000\
\\114\003\000\000\
\\115\003\000\000\
\\116\003\000\000\
\\117\003\031\000\062\000\062\000\061\000\071\000\060\000\072\000\059\000\000\000\
\"
val actionRowNumbers =
"\001\000\181\001\158\001\168\001\
\\006\000\220\000\196\000\190\000\
\\182\001\203\000\197\000\219\000\
\\126\000\002\000\007\000\004\000\
\\003\000\011\000\144\000\005\000\
\\016\000\031\001\027\000\028\000\
\\005\000\015\000\033\000\034\000\
\\058\001\156\001\079\001\056\001\
\\054\001\005\000\010\000\035\000\
\\017\000\019\000\005\000\149\000\
\\145\000\037\000\005\000\037\000\
\\207\000\206\000\205\000\204\000\
\\129\000\128\000\143\000\140\000\
\\157\001\073\001\083\001\139\000\
\\198\000\005\000\005\000\039\000\
\\019\000\199\000\127\000\040\000\
\\221\000\112\000\227\000\217\000\
\\165\001\108\000\116\000\183\000\
\\117\000\211\000\113\000\215\000\
\\109\000\182\000\072\000\071\000\
\\210\000\135\000\155\000\134\000\
\\130\000\090\000\020\000\231\000\
\\059\001\232\000\024\001\055\000\
\\241\000\234\000\023\000\018\000\
\\024\000\009\000\245\000\013\000\
\\041\000\026\000\244\000\243\000\
\\242\000\032\001\131\000\036\000\
\\065\001\050\000\029\001\163\001\
\\128\001\164\001\073\000\195\000\
\\058\000\072\001\052\001\151\000\
\\132\000\200\000\141\000\094\000\
\\156\001\156\001\095\000\079\001\
\\079\001\079\001\057\001\055\001\
\\093\000\208\000\154\000\166\001\
\\131\001\022\000\018\001\010\001\
\\063\001\020\001\026\000\057\000\
\\177\000\176\000\191\000\025\000\
\\026\000\074\001\071\001\015\000\
\\146\000\066\001\067\001\037\001\
\\036\000\074\000\050\000\031\001\
\\138\000\136\000\092\000\100\000\
\\075\000\042\000\084\001\188\000\
\\187\000\189\000\170\000\172\000\
\\167\000\157\000\039\000\012\000\
\\161\000\137\000\186\000\222\000\
\\223\000\091\000\216\000\005\000\
\\007\000\076\000\085\001\213\000\
\\005\000\005\000\212\000\214\000\
\\209\000\010\000\005\000\005\000\
\\060\001\013\000\021\000\025\001\
\\039\000\005\000\026\000\114\000\
\\003\001\248\000\118\000\054\000\
\\235\000\034\001\115\000\246\000\
\\110\000\001\001\077\000\059\000\
\\250\000\002\001\078\000\061\001\
\\010\001\014\000\015\000\014\000\
\\238\000\133\000\056\000\033\000\
\\079\000\031\001\119\000\027\000\
\\080\000\043\000\043\000\028\000\
\\043\000\039\000\005\000\053\001\
\\033\000\042\000\156\001\154\001\
\\155\001\005\000\080\001\096\000\
\\081\001\005\000\035\000\128\001\
\\081\000\044\000\045\000\064\001\
\\026\000\082\000\039\000\022\000\
\\021\001\005\000\026\000\175\000\
\\149\000\048\001\031\001\037\000\
\\083\000\147\000\036\000\019\000\
\\031\001\079\001\148\000\202\000\
\\153\000\142\000\039\000\166\000\
\\039\000\120\000\053\000\111\000\
\\160\000\101\000\163\000\038\000\
\\224\000\228\000\136\001\043\000\
\\121\000\086\001\172\001\149\000\
\\031\001\046\000\031\000\047\000\
\\048\000\015\000\031\001\037\000\
\\102\000\086\001\225\000\226\000\
\\184\000\185\000\181\000\180\000\
\\193\000\062\001\007\001\230\000\
\\009\001\229\000\249\000\026\000\
\\033\001\233\000\026\000\026\000\
\\050\000\247\000\251\000\008\000\
\\026\000\039\000\026\000\005\000\
\\013\000\016\001\122\000\010\001\
\\084\000\033\000\005\000\240\000\
\\039\000\028\001\030\001\170\001\
\\029\000\130\001\086\001\124\001\
\\129\001\134\001\135\001\052\000\
\\075\001\077\001\150\000\201\000\
\\061\000\062\000\079\001\060\000\
\\177\001\085\000\030\000\133\001\
\\132\001\019\001\005\000\011\001\
\\022\001\022\000\179\000\178\000\
\\051\001\039\000\033\000\068\001\
\\038\001\148\000\044\001\042\001\
\\039\001\015\000\038\000\149\000\
\\086\000\192\000\051\000\063\000\
\\042\000\171\000\168\000\169\000\
\\038\000\165\000\039\000\162\000\
\\010\000\039\000\156\000\137\001\
\\173\001\087\001\096\001\006\000\
\\094\001\036\000\089\001\103\000\
\\118\001\098\001\087\000\033\000\
\\099\001\125\001\090\001\104\000\
\\097\001\114\001\095\001\091\001\
\\092\001\043\000\088\001\004\001\
\\123\000\124\000\005\001\035\001\
\\000\001\252\000\254\000\253\000\
\\013\001\012\001\015\001\017\001\
\\005\000\239\000\008\001\027\001\
\\169\001\140\001\153\001\153\001\
\\032\000\064\000\005\000\005\000\
\\167\001\218\000\065\000\005\000\
\\029\000\176\001\178\001\153\001\
\\026\001\023\001\049\001\050\001\
\\040\001\149\000\046\001\036\001\
\\043\001\148\000\079\001\069\001\
\\152\000\164\000\174\000\173\000\
\\159\000\158\000\174\001\149\000\
\\106\000\031\001\109\001\046\000\
\\043\000\031\000\033\000\117\001\
\\100\001\101\001\048\000\107\000\
\\107\001\049\000\015\000\039\000\
\\031\001\171\001\236\000\237\000\
\\026\000\026\000\014\001\043\000\
\\043\000\142\001\152\001\066\000\
\\153\001\162\001\027\000\153\001\
\\035\000\153\001\097\000\127\001\
\\088\000\031\001\126\001\076\001\
\\078\001\079\001\194\000\175\001\
\\179\001\098\000\045\001\039\000\
\\041\001\067\000\111\001\039\000\
\\108\001\039\000\103\001\104\001\
\\116\001\120\001\119\001\102\001\
\\106\001\043\000\138\001\113\001\
\\115\001\093\001\006\001\255\000\
\\145\001\144\001\125\000\105\000\
\\141\001\150\001\159\001\099\000\
\\160\001\151\001\029\000\032\000\
\\033\000\033\000\082\001\030\000\
\\047\001\070\001\112\001\110\001\
\\033\000\139\001\149\001\148\001\
\\153\001\068\000\121\001\123\001\
\\089\000\069\000\105\001\146\001\
\\147\001\070\000\143\001\039\000\
\\180\001\161\001\122\001\000\000"
val gotoT =
"\
\\001\000\010\000\004\000\009\000\022\000\008\000\023\000\007\000\
\\024\000\006\000\027\000\005\000\057\000\004\000\058\000\003\000\
\\083\000\002\000\085\000\001\000\091\000\071\002\000\000\
\\000\000\
\\057\000\004\000\058\000\003\000\083\000\002\000\085\000\052\000\000\000\
\\000\000\
\\001\000\054\000\061\000\053\000\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\023\000\056\000\024\000\006\000\
\\027\000\005\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\023\000\061\000\024\000\006\000\
\\027\000\005\000\000\000\
\\000\000\
\\028\000\062\000\000\000\
\\001\000\010\000\004\000\009\000\022\000\066\000\023\000\007\000\
\\024\000\006\000\025\000\065\000\027\000\005\000\000\000\
\\077\000\068\000\000\000\
\\001\000\010\000\004\000\009\000\021\000\072\000\022\000\071\000\
\\023\000\007\000\024\000\006\000\026\000\070\000\027\000\005\000\000\000\
\\001\000\010\000\004\000\009\000\022\000\066\000\023\000\007\000\
\\024\000\006\000\025\000\074\000\027\000\005\000\000\000\
\\002\000\079\000\008\000\078\000\019\000\077\000\020\000\076\000\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\022\000\085\000\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\002\000\093\000\004\000\092\000\029\000\091\000\030\000\090\000\
\\031\000\089\000\037\000\088\000\043\000\087\000\047\000\086\000\000\000\
\\045\000\108\000\046\000\107\000\000\000\
\\086\000\111\000\000\000\
\\076\000\113\000\000\000\
\\001\000\010\000\004\000\009\000\022\000\115\000\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\002\000\116\000\000\000\
\\002\000\119\000\007\000\118\000\056\000\117\000\000\000\
\\001\000\121\000\000\000\
\\000\000\
\\057\000\004\000\058\000\003\000\083\000\124\000\084\000\123\000\000\000\
\\057\000\004\000\058\000\127\000\060\000\126\000\000\000\
\\004\000\130\000\000\000\
\\004\000\131\000\000\000\
\\001\000\010\000\004\000\009\000\022\000\132\000\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\002\000\134\000\008\000\133\000\000\000\
\\089\000\135\000\000\000\
\\002\000\093\000\004\000\092\000\030\000\090\000\031\000\089\000\
\\041\000\141\000\042\000\140\000\043\000\139\000\044\000\138\000\
\\047\000\137\000\000\000\
\\002\000\093\000\004\000\092\000\016\000\146\000\017\000\145\000\
\\018\000\144\000\029\000\143\000\030\000\090\000\031\000\089\000\
\\043\000\087\000\000\000\
\\001\000\010\000\004\000\009\000\022\000\149\000\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\005\000\151\000\055\000\150\000\000\000\
\\000\000\
\\003\000\157\000\047\000\156\000\049\000\155\000\050\000\154\000\
\\051\000\153\000\000\000\
\\001\000\010\000\004\000\009\000\022\000\162\000\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\003\000\164\000\047\000\156\000\049\000\155\000\050\000\163\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\054\000\061\000\166\000\000\000\
\\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\022\000\167\000\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\001\000\010\000\004\000\009\000\022\000\168\000\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\169\000\000\000\
\\002\000\093\000\004\000\092\000\016\000\178\000\017\000\145\000\
\\018\000\144\000\029\000\143\000\030\000\090\000\031\000\089\000\
\\043\000\087\000\000\000\
\\000\000\
\\000\000\
\\004\000\009\000\024\000\180\000\027\000\005\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\088\000\185\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\093\000\004\000\092\000\029\000\091\000\030\000\090\000\
\\031\000\089\000\037\000\196\000\043\000\087\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\093\000\004\000\092\000\030\000\090\000\031\000\089\000\
\\043\000\199\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\093\000\004\000\092\000\029\000\204\000\030\000\090\000\
\\031\000\089\000\035\000\203\000\043\000\087\000\000\000\
\\002\000\093\000\004\000\092\000\029\000\207\000\030\000\090\000\
\\031\000\089\000\043\000\087\000\048\000\206\000\000\000\
\\002\000\093\000\004\000\092\000\029\000\204\000\030\000\090\000\
\\031\000\089\000\035\000\210\000\043\000\087\000\000\000\
\\002\000\215\000\008\000\214\000\032\000\213\000\033\000\212\000\000\000\
\\000\000\
\\002\000\220\000\039\000\219\000\040\000\218\000\000\000\
\\002\000\224\000\000\000\
\\002\000\093\000\004\000\092\000\029\000\226\000\030\000\090\000\
\\031\000\089\000\043\000\087\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\228\000\000\000\
\\000\000\
\\048\000\230\000\000\000\
\\000\000\
\\000\000\
\\074\000\232\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\119\000\007\000\118\000\056\000\239\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\057\000\004\000\058\000\003\000\083\000\124\000\084\000\243\000\000\000\
\\057\000\004\000\058\000\003\000\083\000\124\000\084\000\244\000\000\000\
\\000\000\
\\057\000\004\000\058\000\127\000\060\000\246\000\000\000\
\\057\000\004\000\058\000\127\000\060\000\247\000\000\000\
\\057\000\004\000\058\000\127\000\060\000\248\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\075\000\252\000\088\000\251\000\000\000\
\\002\000\093\000\004\000\092\000\030\000\090\000\031\000\089\000\
\\041\000\141\000\042\000\255\000\043\000\139\000\044\000\138\000\000\000\
\\000\000\
\\038\000\001\001\000\000\
\\000\000\
\\000\000\
\\002\000\093\000\004\000\092\000\030\000\090\000\031\000\089\000\
\\041\000\004\001\043\000\139\000\044\000\138\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\093\000\004\000\092\000\029\000\207\000\030\000\090\000\
\\031\000\089\000\043\000\087\000\000\000\
\\002\000\093\000\004\000\092\000\017\000\007\001\018\000\144\000\
\\029\000\143\000\030\000\090\000\031\000\089\000\043\000\087\000\000\000\
\\000\000\
\\000\000\
\\002\000\009\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\012\001\000\000\
\\000\000\
\\048\000\206\000\000\000\
\\046\000\014\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\020\001\006\000\019\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\173\000\009\000\023\001\000\000\
\\000\000\
\\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\026\001\015\000\025\001\000\000\
\\002\000\134\000\008\000\029\001\010\000\028\001\011\000\027\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\028\000\032\001\000\000\
\\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\022\000\066\000\023\000\007\000\
\\024\000\006\000\025\000\033\001\027\000\005\000\000\000\
\\077\000\034\001\000\000\
\\000\000\
\\062\000\038\001\063\000\037\001\087\000\036\001\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\022\000\051\001\023\000\007\000\
\\024\000\006\000\026\000\050\001\027\000\005\000\000\000\
\\001\000\010\000\004\000\009\000\021\000\053\001\022\000\052\001\
\\023\000\007\000\024\000\006\000\027\000\005\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\079\000\008\000\078\000\019\000\077\000\020\000\054\001\000\000\
\\001\000\010\000\004\000\009\000\022\000\055\001\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\001\000\010\000\004\000\009\000\022\000\056\001\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\000\000\
\\002\000\220\000\039\000\057\001\040\000\218\000\000\000\
\\002\000\093\000\004\000\092\000\029\000\091\000\030\000\090\000\
\\031\000\089\000\037\000\058\001\043\000\087\000\000\000\
\\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\059\001\000\000\
\\001\000\010\000\004\000\009\000\022\000\060\001\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\002\000\093\000\004\000\092\000\029\000\061\001\030\000\090\000\
\\031\000\089\000\043\000\087\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\038\000\077\001\000\000\
\\002\000\220\000\040\000\078\001\000\000\
\\002\000\079\001\000\000\
\\002\000\220\000\040\000\080\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\119\000\007\000\083\001\000\000\
\\000\000\
\\045\000\085\001\046\000\107\000\000\000\
\\000\000\
\\086\000\087\001\000\000\
\\000\000\
\\073\000\089\001\000\000\
\\073\000\092\001\000\000\
\\076\000\093\001\000\000\
\\073\000\094\001\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\095\001\000\000\
\\001\000\010\000\004\000\009\000\022\000\097\001\023\000\007\000\
\\024\000\006\000\027\000\005\000\059\000\096\001\000\000\
\\000\000\
\\002\000\119\000\007\000\098\001\000\000\
\\001\000\020\001\006\000\099\001\000\000\
\\057\000\004\000\058\000\003\000\083\000\124\000\084\000\100\001\000\000\
\\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\021\000\101\001\022\000\052\001\
\\023\000\007\000\024\000\006\000\027\000\005\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\022\000\103\001\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\089\000\104\001\000\000\
\\074\000\105\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\093\000\004\000\092\000\030\000\090\000\031\000\089\000\
\\041\000\109\001\043\000\139\000\044\000\138\000\000\000\
\\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\111\001\000\000\
\\002\000\093\000\004\000\092\000\030\000\090\000\031\000\089\000\
\\041\000\141\000\042\000\112\001\043\000\139\000\044\000\138\000\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\022\000\114\001\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\002\000\093\000\004\000\092\000\017\000\115\001\018\000\144\000\
\\029\000\143\000\030\000\090\000\031\000\089\000\043\000\087\000\000\000\
\\000\000\
\\005\000\151\000\055\000\116\001\000\000\
\\000\000\
\\045\000\119\001\046\000\107\000\000\000\
\\003\000\164\000\047\000\156\000\049\000\155\000\050\000\120\001\000\000\
\\000\000\
\\005\000\125\001\052\000\124\001\053\000\123\001\054\000\122\001\000\000\
\\003\000\128\001\000\000\
\\002\000\093\000\004\000\092\000\016\000\129\001\017\000\145\000\
\\018\000\144\000\029\000\143\000\030\000\090\000\031\000\089\000\
\\043\000\087\000\000\000\
\\045\000\130\001\046\000\107\000\000\000\
\\057\000\004\000\058\000\127\000\060\000\131\001\000\000\
\\005\000\125\001\052\000\124\001\053\000\123\001\054\000\122\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\133\001\000\000\
\\000\000\
\\003\000\173\000\009\000\172\000\012\000\135\001\013\000\134\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\173\000\009\000\142\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\073\000\143\001\000\000\
\\000\000\
\\062\000\145\001\063\000\037\001\000\000\
\\000\000\
\\005\000\147\001\068\000\146\001\000\000\
\\046\000\149\001\067\000\148\001\000\000\
\\065\000\150\001\000\000\
\\002\000\119\000\007\000\154\001\070\000\153\001\071\000\152\001\000\000\
\\073\000\156\001\000\000\
\\066\000\158\001\000\000\
\\002\000\161\001\069\000\160\001\000\000\
\\046\000\149\001\067\000\162\001\000\000\
\\003\000\157\000\047\000\156\000\049\000\155\000\050\000\164\001\
\\051\000\163\001\000\000\
\\000\000\
\\062\000\166\001\063\000\037\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\093\000\004\000\092\000\029\000\204\000\030\000\090\000\
\\031\000\089\000\035\000\167\001\043\000\087\000\000\000\
\\000\000\
\\000\000\
\\002\000\093\000\004\000\092\000\029\000\204\000\030\000\090\000\
\\031\000\089\000\035\000\168\001\043\000\087\000\000\000\
\\002\000\093\000\004\000\092\000\029\000\170\001\030\000\090\000\
\\031\000\089\000\036\000\169\001\043\000\087\000\000\000\
\\048\000\171\001\000\000\
\\000\000\
\\000\000\
\\002\000\215\000\008\000\214\000\032\000\213\000\033\000\172\001\000\000\
\\002\000\093\000\004\000\092\000\029\000\173\001\030\000\090\000\
\\031\000\089\000\043\000\087\000\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\174\001\000\000\
\\002\000\093\000\004\000\092\000\029\000\175\001\030\000\090\000\
\\031\000\089\000\043\000\087\000\000\000\
\\001\000\010\000\004\000\009\000\022\000\176\001\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\002\000\220\000\039\000\177\001\040\000\218\000\000\000\
\\000\000\
\\000\000\
\\038\000\179\001\000\000\
\\000\000\
\\002\000\119\000\007\000\181\001\000\000\
\\001\000\010\000\004\000\009\000\022\000\182\001\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\183\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\119\000\007\000\185\001\079\000\184\001\000\000\
\\000\000\
\\062\000\189\001\063\000\037\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\057\000\004\000\058\000\127\000\060\000\194\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\119\000\007\000\198\001\090\000\197\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\022\000\200\001\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\000\000\
\\000\000\
\\002\000\093\000\004\000\092\000\030\000\090\000\031\000\089\000\
\\041\000\141\000\042\000\201\001\043\000\139\000\044\000\138\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\202\001\000\000\
\\002\000\119\000\007\000\203\001\000\000\
\\000\000\
\\000\000\
\\005\000\125\001\052\000\204\001\053\000\123\001\054\000\122\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\206\001\000\000\
\\003\000\173\000\009\000\207\001\000\000\
\\005\000\125\001\053\000\208\001\054\000\122\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\020\001\006\000\212\001\000\000\
\\000\000\
\\000\000\
\\003\000\173\000\009\000\023\001\000\000\
\\003\000\173\000\009\000\213\001\000\000\
\\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\215\001\015\000\214\001\000\000\
\\000\000\
\\002\000\134\000\008\000\029\001\010\000\028\001\011\000\216\001\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\217\001\000\000\
\\000\000\
\\000\000\
\\088\000\218\001\000\000\
\\000\000\
\\000\000\
\\001\000\220\001\000\000\
\\000\000\
\\003\000\222\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\119\000\007\000\154\001\071\000\227\001\000\000\
\\000\000\
\\064\000\228\001\000\000\
\\000\000\
\\078\000\232\001\088\000\231\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\073\000\237\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\022\000\242\001\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\080\000\245\001\000\000\
\\057\000\004\000\058\000\249\001\081\000\248\001\082\000\247\001\000\000\
\\057\000\004\000\058\000\249\001\081\000\248\001\082\000\254\001\000\000\
\\002\000\119\000\007\000\000\002\072\000\255\001\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\022\000\097\001\023\000\007\000\
\\024\000\006\000\027\000\005\000\059\000\003\002\000\000\
\\001\000\010\000\004\000\009\000\022\000\097\001\023\000\007\000\
\\024\000\006\000\027\000\005\000\059\000\004\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\010\000\004\000\009\000\022\000\006\002\023\000\007\000\
\\024\000\006\000\027\000\005\000\000\000\
\\002\000\119\000\007\000\185\001\079\000\007\002\000\000\
\\000\000\
\\080\000\008\002\000\000\
\\057\000\004\000\058\000\249\001\081\000\248\001\082\000\009\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\005\000\125\001\053\000\010\002\054\000\122\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\005\000\125\001\052\000\012\002\053\000\123\001\054\000\122\001\000\000\
\\057\000\004\000\058\000\127\000\060\000\013\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\005\000\147\001\068\000\014\002\000\000\
\\000\000\
\\046\000\149\001\067\000\016\002\000\000\
\\000\000\
\\065\000\018\002\000\000\
\\073\000\019\002\000\000\
\\002\000\119\000\007\000\154\001\070\000\020\002\071\000\152\001\000\000\
\\002\000\119\000\007\000\022\002\071\000\021\002\000\000\
\\000\000\
\\000\000\
\\064\000\023\002\000\000\
\\066\000\024\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\161\001\069\000\027\002\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\028\002\000\000\
\\045\000\029\002\046\000\107\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\093\000\004\000\092\000\029\000\170\001\030\000\090\000\
\\031\000\089\000\036\000\030\002\043\000\087\000\000\000\
\\002\000\093\000\004\000\092\000\029\000\031\002\030\000\090\000\
\\031\000\089\000\043\000\087\000\000\000\
\\000\000\
\\073\000\032\002\000\000\
\\073\000\033\002\000\000\
\\000\000\
\\002\000\119\000\007\000\185\001\057\000\004\000\058\000\249\001\
\\079\000\035\002\081\000\248\001\082\000\034\002\000\000\
\\000\000\
\\057\000\004\000\058\000\249\001\081\000\248\001\082\000\037\002\000\000\
\\000\000\
\\086\000\038\002\000\000\
\\057\000\004\000\058\000\249\001\081\000\248\001\082\000\039\002\000\000\
\\089\000\040\002\000\000\
\\057\000\004\000\058\000\249\001\081\000\248\001\082\000\041\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\046\000\045\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\057\000\004\000\058\000\127\000\060\000\046\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\048\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\050\002\000\000\
\\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\051\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\073\000\053\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\119\000\007\000\185\001\079\000\057\002\000\000\
\\002\000\119\000\007\000\000\002\072\000\058\002\000\000\
\\002\000\119\000\007\000\059\002\000\000\
\\002\000\119\000\007\000\060\002\000\000\
\\000\000\
\\002\000\119\000\007\000\198\001\090\000\061\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\119\000\007\000\062\002\000\000\
\\000\000\
\\080\000\063\002\000\000\
\\080\000\064\002\000\000\
\\057\000\004\000\058\000\249\001\081\000\248\001\082\000\065\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\173\000\009\000\172\000\012\000\171\000\013\000\170\000\
\\014\000\070\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\"
val numstates = 584
val numrules = 300
val s = ref "" and index = ref 0
val string_to_int = fn () => 
let val i = !index
in index := i+2; Char.ord(String.sub(!s,i)) + Char.ord(String.sub(!s,i+1)) * 256
end
val string_to_list = fn s' =>
    let val len = String.size s'
        fun f () =
           if !index < len then string_to_int() :: f()
           else nil
   in index := 0; s := s'; f ()
   end
val string_to_pairlist = fn (conv_key,conv_entry) =>
     let fun f () =
         case string_to_int()
         of 0 => EMPTY
          | n => PAIR(conv_key (n-1),conv_entry (string_to_int()),f())
     in f
     end
val string_to_pairlist_default = fn (conv_key,conv_entry) =>
    let val conv_row = string_to_pairlist(conv_key,conv_entry)
    in fn () =>
       let val default = conv_entry(string_to_int())
           val row = conv_row()
       in (row,default)
       end
   end
val string_to_table = fn (convert_row,s') =>
    let val len = String.size s'
        fun f ()=
           if !index < len then convert_row() :: f()
           else nil
     in (s := s'; index := 0; f ())
     end
local
  val memo = Array.array(numstates+numrules,ERROR)
  val _ =let fun g i=(Array.update(memo,i,REDUCE(i-numstates)); g(i+1))
       fun f i =
            if i=numstates then g i
            else (Array.update(memo,i,SHIFT (STATE i)); f (i+1))
          in f 0 handle General.Subscript => ()
          end
in
val entry_to_action = fn 0 => ACCEPT | 1 => ERROR | j => Array.sub(memo,(j-2))
end
val gotoT=Array.fromList(string_to_table(string_to_pairlist(NT,STATE),gotoT))
val actionRows=string_to_table(string_to_pairlist_default(T,entry_to_action),actionRows)
val actionRowNumbers = string_to_list actionRowNumbers
val actionT = let val actionRowLookUp=
let val a=Array.fromList(actionRows) in fn i=>Array.sub(a,i) end
in Array.fromList(List.map actionRowLookUp actionRowNumbers)
end
in LrTable.mkLrTable {actions=actionT,gotos=gotoT,numRules=numrules,
numStates=numstates,initialState=STATE 0}
end
end
local open Header in
type pos = int
type arg = pos*pos -> ErrorMsg.complainer
structure MlyValue = 
struct
datatype svalue = VOID | ntVOID of unit ->  unit
 | AQID of unit ->  (FastSymbol.raw_symbol)
 | OBJL of unit ->  (string) | ENDQ of unit ->  (string)
 | CHAR of unit ->  (string) | STRING of unit ->  (string)
 | REAL of unit ->  (string*RealLit.t)
 | WORD of unit ->  (string*IntInf.int)
 | INT0 of unit ->  (string*IntInf.int)
 | INT of unit ->  (string*IntInf.int)
 | TYVAR of unit ->  (FastSymbol.raw_symbol)
 | IDS of unit ->  (FastSymbol.raw_symbol)
 | IDA of unit ->  (FastSymbol.raw_symbol)
 | interdec of unit ->  (dec)
 | fct_exp of unit ->  (fsigexp sigConst -> fctexp)
 | fctb of unit ->  (fctb list)
 | fparamList of unit ->  ( ( symbol option * sigexp )  list)
 | fparam of unit ->  (symbol option*sigexp)
 | strb of unit ->  (strb list) | sdecs' of unit ->  (dec)
 | sdecs of unit ->  (dec) | sdec of unit ->  (dec)
 | strdecs of unit ->  (dec) | strdec of unit ->  (dec)
 | arg_fct of unit ->  ( ( strexp * bool )  list)
 | str of unit ->  (strexp) | fsig of unit ->  (fsigexp)
 | fsigb of unit ->  (fsigb list) | sigb of unit ->  (sigb list)
 | fsigconstraint_op of unit ->  (fsigexp sigConst)
 | sigconstraint_op of unit ->  (sigexp sigConst)
 | sign of unit ->  (sigexp) | whspec of unit ->  (wherespec list)
 | patheqn of unit ->  ( ( FastSymbol.raw_symbol ->symbol )  -> symbol list list)
 | sharespec of unit ->  (spec list)
 | exnspec of unit ->  ( ( symbol * ty option )  list)
 | valspec of unit ->  ( ( symbol * ty )  list)
 | tyspec of unit ->  ( ( symbol * tyvar list * ty option )  list)
 | fctspec of unit ->  ( ( symbol * fsigexp )  list)
 | strspec of unit ->  ( ( symbol * sigexp * path option )  list)
 | idents of unit ->  (spec list) | spec of unit ->  (spec list)
 | spec_s of unit ->  (spec list) | ops of unit ->  (symbol list)
 | ldecs of unit ->  (dec) | exp_pa of unit ->  (exp list)
 | ldec of unit ->  (dec) | fixity of unit ->  (fixity)
 | qid_p of unit ->  (Symbol.symbol list list)
 | eb of unit ->  (eb list) | constr of unit ->  (symbol*ty option)
 | constrs' of unit ->  ( ( symbol * ty option )  list)
 | constrs of unit ->  ( ( symbol * ty option )  list)
 | dtrepl of unit ->  (symbol*path) | dbs of unit ->  (db list)
 | db of unit ->  (db) | tyvar_pc of unit ->  (tyvar list)
 | tyvarseq of unit ->  (tyvar list) | tyvars of unit ->  (tyvar list)
 | tb of unit ->  (tb list) | clause of unit ->  (clause)
 | apats of unit ->  (pat fixitem list) | fb of unit ->  (fb list)
 | fb' of unit ->  (clause list)
 | rpat of unit ->  ( ( bool * exp )  -> rvb)
 | rvb of unit ->  (rvb list) | constraint of unit ->  (ty option)
 | vb of unit ->  (vb list) | or_pat_list of unit ->  (pat list)
 | pat_list of unit ->  (pat list) | pat_2c of unit ->  (pat list)
 | plabels of unit ->  ( ( (symbol * pat) list * bool ) )
 | plabel of unit ->  ( ( symbol * pat ) ) | apat' of unit ->  (pat)
 | apat of unit ->  (pat fixitem) | pat of unit ->  (pat)
 | ot_list of unit ->  (exp list) | quote of unit ->  (exp list)
 | exp_2c of unit ->  (exp list) | exp_list of unit ->  (exp list)
 | aexp of unit ->  (exp) | app_exp of unit ->  (exp fixitem list)
 | exp of unit ->  (exp) | exp_ps of unit ->  (exp list)
 | elabels of unit ->  ( ( symbol * exp )  list)
 | elabel of unit ->  ( ( symbol * exp ) ) | rule of unit ->  (rule)
 | match' of unit ->  (rule list) | match of unit ->  (rule list)
 | ty0_pc of unit ->  (ty list) | ty of unit ->  (ty)
 | tuple_ty of unit ->  (ty list) | ty' of unit ->  (ty)
 | tlabels of unit ->  ( ( symbol * ty )  list)
 | tlabel of unit ->  ( ( symbol * ty ) )
 | tycon of unit ->  (symbol list) | selector of unit ->  (symbol)
 | qid of unit ->  ( ( FastSymbol.raw_symbol -> symbol )  -> symbol list)
 | qident of unit ->  ( ( FastSymbol.raw_symbol -> symbol )  -> symbol list)
 | op_op of unit ->  (unit) | int of unit ->  (string*IntInf.int)
 | idtyc of unit ->  (FastSymbol.raw_symbol)
 | id of unit ->  (FastSymbol.raw_symbol)
 | ident of unit ->  (FastSymbol.raw_symbol)
end
type svalue = MlyValue.svalue
type result = dec
end
structure EC=
struct
open LrTable
infix 5 $$
fun x $$ y = y::x
val is_keyword =
fn (T 11) => true | (T 12) => true | (T 14) => true | (T 16) => true
 | (T 17) => true | (T 18) => true | (T 19) => true | (T 20) => true
 | (T 22) => true | (T 23) => true | (T 24) => true | (T 26) => true
 | (T 27) => true | (T 28) => true | (T 29) => true | (T 30) => true
 | (T 32) => true | (T 33) => true | (T 34) => true | (T 35) => true
 | (T 36) => true | (T 37) => true | (T 38) => true | (T 39) => true
 | (T 40) => true | (T 41) => true | (T 42) => true | (T 43) => true
 | (T 44) => true | (T 45) => true | (T 46) => true | (T 47) => true
 | (T 48) => true | (T 49) => true | (T 50) => true | (T 51) => true
 | (T 52) => true | (T 53) => true | (T 54) => true | (T 56) => true
 | (T 55) => true | (T 58) => true | (T 59) => true | (T 70) => true
 | (T 71) => true | _ => false
val preferred_change : (term list * term list) list = 
(nil
,nil
 $$ (T 54))::
(nil
,nil
 $$ (T 52))::
(nil
,nil
 $$ (T 19))::
(nil
,nil
 $$ (T 66))::
(nil
,nil
 $$ (T 1))::
(nil
 $$ (T 26),nil
 $$ (T 21))::
(nil
 $$ (T 21),nil
 $$ (T 26))::
(nil
 $$ (T 12),nil
 $$ (T 71))::
(nil
 $$ (T 61),nil
 $$ (T 41))::
(nil
 $$ (T 1),nil
 $$ (T 63))::
(nil
 $$ (T 63),nil
 $$ (T 1))::
(nil
,nil
 $$ (T 20) $$ (T 2) $$ (T 33))::
(nil
,nil
 $$ (T 2) $$ (T 19))::
nil
val noShift = 
fn (T 0) => true | _ => false
val showTerminal =
fn (T 0) => "EOF"
  | (T 1) => "SEMICOLON"
  | (T 2) => "IDA"
  | (T 3) => "IDS"
  | (T 4) => "TYVAR"
  | (T 5) => "INT"
  | (T 6) => "INT0"
  | (T 7) => "WORD"
  | (T 8) => "REAL"
  | (T 9) => "STRING"
  | (T 10) => "CHAR"
  | (T 11) => "ABSTYPE"
  | (T 12) => "AND"
  | (T 13) => "ARROW"
  | (T 14) => "AS"
  | (T 15) => "BAR"
  | (T 16) => "CASE"
  | (T 17) => "DATATYPE"
  | (T 18) => "DOTDOTDOT"
  | (T 19) => "ELSE"
  | (T 20) => "END"
  | (T 21) => "EQUALOP"
  | (T 22) => "EQTYPE"
  | (T 23) => "EXCEPTION"
  | (T 24) => "DO"
  | (T 25) => "DOT"
  | (T 26) => "DARROW"
  | (T 27) => "FN"
  | (T 28) => "FUN"
  | (T 29) => "FUNCTOR"
  | (T 30) => "HANDLE"
  | (T 31) => "HASH"
  | (T 32) => "IF"
  | (T 33) => "IN"
  | (T 34) => "INCLUDE"
  | (T 35) => "INFIX"
  | (T 36) => "INFIXR"
  | (T 37) => "LAZY"
  | (T 38) => "LET"
  | (T 39) => "LOCAL"
  | (T 40) => "NONFIX"
  | (T 41) => "OF"
  | (T 42) => "OP"
  | (T 43) => "OPEN"
  | (T 44) => "OVERLOAD"
  | (T 45) => "RAISE"
  | (T 46) => "REC"
  | (T 47) => "SHARING"
  | (T 48) => "SIG"
  | (T 49) => "SIGNATURE"
  | (T 50) => "STRUCT"
  | (T 51) => "STRUCTURE"
  | (T 52) => "THEN"
  | (T 53) => "TYPE"
  | (T 54) => "VAL"
  | (T 55) => "WHERE"
  | (T 56) => "WHILE"
  | (T 57) => "WILD"
  | (T 58) => "WITH"
  | (T 59) => "WITHTYPE"
  | (T 60) => "ASTERISK"
  | (T 61) => "COLON"
  | (T 62) => "COLONGT"
  | (T 63) => "COMMA"
  | (T 64) => "LBRACE"
  | (T 65) => "LBRACKET"
  | (T 66) => "LPAREN"
  | (T 67) => "RBRACE"
  | (T 68) => "RBRACKET"
  | (T 69) => "RPAREN"
  | (T 70) => "ORELSE"
  | (T 71) => "ANDALSO"
  | (T 72) => "FUNSIG"
  | (T 73) => "VECTORSTART"
  | (T 74) => "BEGINQ"
  | (T 75) => "ENDQ"
  | (T 76) => "OBJL"
  | (T 77) => "AQID"
  | _ => "bogus-term"
local open Header in
val errtermvalue=
fn (T 2) => MlyValue.IDA(fn () => (rawSymbol(bogusHash,bogusString))) | 
(T 3) => MlyValue.IDS(fn () => (rawSymbol(bogusHash,bogusString))) | 
(T 4) => MlyValue.TYVAR(fn () => (
rawSymbol(quotedBogusHash,quotedBogusString))) | 
(T 5) => MlyValue.INT(fn () => ("1", IntInf.fromInt 1)) | 
(T 6) => MlyValue.INT0(fn () => ("0", IntInf.fromInt 0)) | 
(T 7) => MlyValue.WORD(fn () => ("0w0", IntInf.fromInt 0)) | 
(T 8) => MlyValue.REAL(fn () => ("0.0", RealLit.zero false)) | 
(T 9) => MlyValue.STRING(fn () => ("")) | 
(T 10) => MlyValue.CHAR(fn () => ("a")) | 
_ => MlyValue.VOID
end
val terms : term list = nil
 $$ (T 74) $$ (T 73) $$ (T 72) $$ (T 71) $$ (T 70) $$ (T 69) $$ (T 68)
 $$ (T 67) $$ (T 66) $$ (T 65) $$ (T 64) $$ (T 63) $$ (T 62) $$ (T 61)
 $$ (T 60) $$ (T 59) $$ (T 58) $$ (T 57) $$ (T 56) $$ (T 55) $$ (T 54)
 $$ (T 53) $$ (T 52) $$ (T 51) $$ (T 50) $$ (T 49) $$ (T 48) $$ (T 47)
 $$ (T 46) $$ (T 45) $$ (T 44) $$ (T 43) $$ (T 42) $$ (T 41) $$ (T 40)
 $$ (T 39) $$ (T 38) $$ (T 37) $$ (T 36) $$ (T 35) $$ (T 34) $$ (T 33)
 $$ (T 32) $$ (T 31) $$ (T 30) $$ (T 29) $$ (T 28) $$ (T 27) $$ (T 26)
 $$ (T 25) $$ (T 24) $$ (T 23) $$ (T 22) $$ (T 21) $$ (T 20) $$ (T 19)
 $$ (T 18) $$ (T 17) $$ (T 16) $$ (T 15) $$ (T 14) $$ (T 13) $$ (T 12)
 $$ (T 11) $$ (T 1) $$ (T 0)end
structure Actions =
struct 
exception mlyAction of int
local open Header in
val actions = 
fn (i392,defaultPos,stack,
    (error):arg) =>
case (i392,stack)
of  ( 0, ( ( _, ( MlyValue.INT INT1, INT1left, INT1right)) :: rest671)
) => let val  result = MlyValue.int (fn _ => let val  (INT as INT1) = 
INT1 ()
 in (INT)
end)
 in ( LrTable.NT 3, ( result, INT1left, INT1right), rest671)
end
|  ( 1, ( ( _, ( MlyValue.INT0 INT01, INT01left, INT01right)) :: 
rest671)) => let val  result = MlyValue.int (fn _ => let val  (INT0
 as INT01) = INT01 ()
 in (INT0)
end)
 in ( LrTable.NT 3, ( result, INT01left, INT01right), rest671)
end
|  ( 2, ( ( _, ( MlyValue.IDA IDA1, IDA1left, IDA1right)) :: rest671))
 => let val  result = MlyValue.id (fn _ => let val  (IDA as IDA1) = 
IDA1 ()
 in (IDA)
end)
 in ( LrTable.NT 1, ( result, IDA1left, IDA1right), rest671)
end
|  ( 3, ( ( _, ( MlyValue.IDS IDS1, IDS1left, IDS1right)) :: rest671))
 => let val  result = MlyValue.id (fn _ => let val  (IDS as IDS1) = 
IDS1 ()
 in (IDS)
end)
 in ( LrTable.NT 1, ( result, IDS1left, IDS1right), rest671)
end
|  ( 4, ( ( _, ( _, ASTERISK1left, ASTERISK1right)) :: rest671)) =>
 let val  result = MlyValue.id (fn _ => (
rawSymbol (asteriskHash,asteriskString)))
 in ( LrTable.NT 1, ( result, ASTERISK1left, ASTERISK1right), rest671)

end
|  ( 5, ( ( _, ( MlyValue.IDA IDA1, IDA1left, IDA1right)) :: rest671))
 => let val  result = MlyValue.idtyc (fn _ => let val  (IDA as IDA1) =
 IDA1 ()
 in (IDA)
end)
 in ( LrTable.NT 2, ( result, IDA1left, IDA1right), rest671)
end
|  ( 6, ( ( _, ( MlyValue.IDS IDS1, IDS1left, IDS1right)) :: rest671))
 => let val  result = MlyValue.idtyc (fn _ => let val  (IDS as IDS1) =
 IDS1 ()
 in (IDS)
end)
 in ( LrTable.NT 2, ( result, IDS1left, IDS1right), rest671)
end
|  ( 7, ( ( _, ( MlyValue.IDA IDA1, IDA1left, IDA1right)) :: rest671))
 => let val  result = MlyValue.ident (fn _ => let val  (IDA as IDA1) =
 IDA1 ()
 in (IDA)
end)
 in ( LrTable.NT 0, ( result, IDA1left, IDA1right), rest671)
end
|  ( 8, ( ( _, ( MlyValue.IDS IDS1, IDS1left, IDS1right)) :: rest671))
 => let val  result = MlyValue.ident (fn _ => let val  (IDS as IDS1) =
 IDS1 ()
 in (IDS)
end)
 in ( LrTable.NT 0, ( result, IDS1left, IDS1right), rest671)
end
|  ( 9, ( ( _, ( _, ASTERISK1left, ASTERISK1right)) :: rest671)) =>
 let val  result = MlyValue.ident (fn _ => (
rawSymbol (asteriskHash,asteriskString)))
 in ( LrTable.NT 0, ( result, ASTERISK1left, ASTERISK1right), rest671)

end
|  ( 10, ( ( _, ( _, EQUALOP1left, EQUALOP1right)) :: rest671)) => let
 val  result = MlyValue.ident (fn _ => (
rawSymbol (equalHash,equalString)))
 in ( LrTable.NT 0, ( result, EQUALOP1left, EQUALOP1right), rest671)

end
|  ( 11, ( ( _, ( _, (OPleft as OP1left), (OPright as OP1right))) :: 
rest671)) => let val  result = MlyValue.op_op (fn _ => (
error (OPleft,OPright) WARN "unnecessary `op'"
			       nullErrorBody
))
 in ( LrTable.NT 4, ( result, OP1left, OP1right), rest671)
end
|  ( 12, ( rest671)) => let val  result = MlyValue.op_op (fn _ => ())
 in ( LrTable.NT 4, ( result, defaultPos, defaultPos), rest671)
end
|  ( 13, ( ( _, ( MlyValue.qid qid1, _, qid1right)) :: _ :: ( _, ( 
MlyValue.IDA IDA1, IDA1left, _)) :: rest671)) => let val  result = 
MlyValue.qid (fn _ => let val  (IDA as IDA1) = IDA1 ()
 val  (qid as qid1) = qid1 ()
 in (fn kind => strSymbol IDA :: qid kind)
end)
 in ( LrTable.NT 6, ( result, IDA1left, qid1right), rest671)
end
|  ( 14, ( ( _, ( MlyValue.id id1, id1left, id1right)) :: rest671)) =>
 let val  result = MlyValue.qid (fn _ => let val  (id as id1) = id1 ()
 in (fn kind => [kind id])
end)
 in ( LrTable.NT 6, ( result, id1left, id1right), rest671)
end
|  ( 15, ( ( _, ( MlyValue.qident qident1, _, qident1right)) :: _ :: (
 _, ( MlyValue.IDA IDA1, IDA1left, _)) :: rest671)) => let val  result
 = MlyValue.qident (fn _ => let val  (IDA as IDA1) = IDA1 ()
 val  (qident as qident1) = qident1 ()
 in (fn kind => strSymbol IDA :: qident kind)
end)
 in ( LrTable.NT 5, ( result, IDA1left, qident1right), rest671)
end
|  ( 16, ( ( _, ( MlyValue.ident ident1, ident1left, ident1right)) :: 
rest671)) => let val  result = MlyValue.qident (fn _ => let val  (
ident as ident1) = ident1 ()
 in (fn kind => [kind ident])
end)
 in ( LrTable.NT 5, ( result, ident1left, ident1right), rest671)
end
|  ( 17, ( ( _, ( MlyValue.id id1, id1left, id1right)) :: rest671)) =>
 let val  result = MlyValue.selector (fn _ => let val  (id as id1) = 
id1 ()
 in (labSymbol id)
end)
 in ( LrTable.NT 7, ( result, id1left, id1right), rest671)
end
|  ( 18, ( ( _, ( MlyValue.INT INT1, INT1left, INT1right)) :: rest671)
) => let val  result = MlyValue.selector (fn _ => let val  (INT as 
INT1) = INT1 ()
 in (Symbol.labSymbol(IntInf.toString(#2 INT)))
end)
 in ( LrTable.NT 7, ( result, INT1left, INT1right), rest671)
end
|  ( 19, ( ( _, ( MlyValue.tycon tycon1, _, tycon1right)) :: _ :: ( _,
 ( MlyValue.IDA IDA1, IDA1left, _)) :: rest671)) => let val  result = 
MlyValue.tycon (fn _ => let val  (IDA as IDA1) = IDA1 ()
 val  (tycon as tycon1) = tycon1 ()
 in (strSymbol IDA :: tycon)
end)
 in ( LrTable.NT 8, ( result, IDA1left, tycon1right), rest671)
end
|  ( 20, ( ( _, ( MlyValue.idtyc idtyc1, idtyc1left, idtyc1right)) :: 
rest671)) => let val  result = MlyValue.tycon (fn _ => let val  (idtyc
 as idtyc1) = idtyc1 ()
 in ([tycSymbol idtyc])
end)
 in ( LrTable.NT 8, ( result, idtyc1left, idtyc1right), rest671)
end
|  ( 21, ( ( _, ( MlyValue.ty ty1, _, ty1right)) :: _ :: ( _, ( 
MlyValue.selector selector1, selector1left, _)) :: rest671)) => let
 val  result = MlyValue.tlabel (fn _ => let val  (selector as 
selector1) = selector1 ()
 val  (ty as ty1) = ty1 ()
 in (selector, ty )
end)
 in ( LrTable.NT 9, ( result, selector1left, ty1right), rest671)
end
|  ( 22, ( ( _, ( MlyValue.tlabels tlabels1, _, tlabels1right)) :: _
 :: ( _, ( MlyValue.tlabel tlabel1, tlabel1left, _)) :: rest671)) =>
 let val  result = MlyValue.tlabels (fn _ => let val  (tlabel as 
tlabel1) = tlabel1 ()
 val  (tlabels as tlabels1) = tlabels1 ()
 in (tlabel :: tlabels)
end)
 in ( LrTable.NT 10, ( result, tlabel1left, tlabels1right), rest671)

end
|  ( 23, ( ( _, ( MlyValue.tlabel tlabel1, tlabel1left, tlabel1right))
 :: rest671)) => let val  result = MlyValue.tlabels (fn _ => let val 
 (tlabel as tlabel1) = tlabel1 ()
 in ([tlabel])
end)
 in ( LrTable.NT 10, ( result, tlabel1left, tlabel1right), rest671)

end
|  ( 24, ( ( _, ( MlyValue.TYVAR TYVAR1, (TYVARleft as TYVAR1left), (
TYVARright as TYVAR1right))) :: rest671)) => let val  result = 
MlyValue.ty' (fn _ => let val  (TYVAR as TYVAR1) = TYVAR1 ()
 in (MarkTy (VarTy(Tyv(tyvSymbol TYVAR)),
				 (TYVARleft,TYVARright))
)
end)
 in ( LrTable.NT 11, ( result, TYVAR1left, TYVAR1right), rest671)
end
|  ( 25, ( ( _, ( _, _, (RBRACEright as RBRACE1right))) :: ( _, ( 
MlyValue.tlabels tlabels1, _, _)) :: ( _, ( _, (LBRACEleft as 
LBRACE1left), _)) :: rest671)) => let val  result = MlyValue.ty' (fn _
 => let val  (tlabels as tlabels1) = tlabels1 ()
 in (MarkTy(RecordTy tlabels,(LBRACEleft,RBRACEright)))
end)
 in ( LrTable.NT 11, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 26, ( ( _, ( _, _, RBRACE1right)) :: ( _, ( _, LBRACE1left, _))
 :: rest671)) => let val  result = MlyValue.ty' (fn _ => (RecordTy [])
)
 in ( LrTable.NT 11, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 27, ( ( _, ( MlyValue.tycon tycon1, tyconleft, (tyconright as 
tycon1right))) :: _ :: ( _, ( MlyValue.ty0_pc ty0_pc1, _, _)) :: ( _, 
( _, LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.ty'
 (fn _ => let val  (ty0_pc as ty0_pc1) = ty0_pc1 ()
 val  (tycon as tycon1) = tycon1 ()
 in (MarkTy(ConTy(tycon,ty0_pc),(tyconleft,tyconright)))
end)
 in ( LrTable.NT 11, ( result, LPAREN1left, tycon1right), rest671)
end
|  ( 28, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ty ty1, _, _
)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ty' (fn _ => let val  (ty as ty1) = ty1 ()
 in (ty)
end)
 in ( LrTable.NT 11, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 29, ( ( _, ( MlyValue.tycon tycon1, tyconleft, (tyconright as 
tycon1right))) :: ( _, ( MlyValue.ty' ty'1, ty'1left, _)) :: rest671))
 => let val  result = MlyValue.ty' (fn _ => let val  (ty' as ty'1) = 
ty'1 ()
 val  (tycon as tycon1) = tycon1 ()
 in (MarkTy(ConTy(tycon,[ty']),(tyconleft,tyconright)))
end)
 in ( LrTable.NT 11, ( result, ty'1left, tycon1right), rest671)
end
|  ( 30, ( ( _, ( MlyValue.tycon tycon1, (tyconleft as tycon1left), (
tyconright as tycon1right))) :: rest671)) => let val  result = 
MlyValue.ty' (fn _ => let val  (tycon as tycon1) = tycon1 ()
 in (MarkTy(ConTy(tycon,[]),(tyconleft,tyconright)))
end)
 in ( LrTable.NT 11, ( result, tycon1left, tycon1right), rest671)
end
|  ( 31, ( ( _, ( MlyValue.tuple_ty tuple_ty1, _, tuple_ty1right)) ::
 _ :: ( _, ( MlyValue.ty' ty'1, ty'1left, _)) :: rest671)) => let val 
 result = MlyValue.tuple_ty (fn _ => let val  (ty' as ty'1) = ty'1 ()
 val  (tuple_ty as tuple_ty1) = tuple_ty1 ()
 in (ty' :: tuple_ty)
end)
 in ( LrTable.NT 12, ( result, ty'1left, tuple_ty1right), rest671)
end
|  ( 32, ( ( _, ( MlyValue.ty' ty'2, _, ty'2right)) :: _ :: ( _, ( 
MlyValue.ty' ty'1, ty'1left, _)) :: rest671)) => let val  result = 
MlyValue.tuple_ty (fn _ => let val  ty'1 = ty'1 ()
 val  ty'2 = ty'2 ()
 in ([ty'1,ty'2])
end)
 in ( LrTable.NT 12, ( result, ty'1left, ty'2right), rest671)
end
|  ( 33, ( ( _, ( MlyValue.tuple_ty tuple_ty1, tuple_ty1left, 
tuple_ty1right)) :: rest671)) => let val  result = MlyValue.ty (fn _
 => let val  (tuple_ty as tuple_ty1) = tuple_ty1 ()
 in (TupleTy(tuple_ty))
end)
 in ( LrTable.NT 13, ( result, tuple_ty1left, tuple_ty1right), rest671
)
end
|  ( 34, ( ( _, ( MlyValue.ty ty2, _, ty2right)) :: _ :: ( _, ( 
MlyValue.ty ty1, ty1left, _)) :: rest671)) => let val  result = 
MlyValue.ty (fn _ => let val  ty1 = ty1 ()
 val  ty2 = ty2 ()
 in (ConTy([arrowTycon], [ty1,ty2]))
end)
 in ( LrTable.NT 13, ( result, ty1left, ty2right), rest671)
end
|  ( 35, ( ( _, ( MlyValue.ty' ty'1, ty'1left, ty'1right)) :: rest671)
) => let val  result = MlyValue.ty (fn _ => let val  (ty' as ty'1) = 
ty'1 ()
 in (ty')
end)
 in ( LrTable.NT 13, ( result, ty'1left, ty'1right), rest671)
end
|  ( 36, ( ( _, ( MlyValue.ty ty2, _, ty2right)) :: _ :: ( _, ( 
MlyValue.ty ty1, ty1left, _)) :: rest671)) => let val  result = 
MlyValue.ty0_pc (fn _ => let val  ty1 = ty1 ()
 val  ty2 = ty2 ()
 in ([ty1,ty2])
end)
 in ( LrTable.NT 14, ( result, ty1left, ty2right), rest671)
end
|  ( 37, ( ( _, ( MlyValue.ty0_pc ty0_pc1, _, ty0_pc1right)) :: _ :: (
 _, ( MlyValue.ty ty1, ty1left, _)) :: rest671)) => let val  result = 
MlyValue.ty0_pc (fn _ => let val  (ty as ty1) = ty1 ()
 val  (ty0_pc as ty0_pc1) = ty0_pc1 ()
 in (ty :: ty0_pc)
end)
 in ( LrTable.NT 14, ( result, ty1left, ty0_pc1right), rest671)
end
|  ( 38, ( ( _, ( MlyValue.match' match'1, _, match'1right)) :: ( _, (
 _, BAR1left, _)) :: rest671)) => let val  result = MlyValue.match (fn
 _ => let val  (match' as match'1) = match'1 ()
 in (match')
end)
 in ( LrTable.NT 15, ( result, BAR1left, match'1right), rest671)
end
|  ( 39, ( ( _, ( MlyValue.match' match'1, match'1left, match'1right))
 :: rest671)) => let val  result = MlyValue.match (fn _ => let val  (
match' as match'1) = match'1 ()
 in (match')
end)
 in ( LrTable.NT 15, ( result, match'1left, match'1right), rest671)

end
|  ( 40, ( ( _, ( MlyValue.rule rule1, rule1left, rule1right)) :: 
rest671)) => let val  result = MlyValue.match' (fn _ => let val  (rule
 as rule1) = rule1 ()
 in ([rule])
end)
 in ( LrTable.NT 16, ( result, rule1left, rule1right), rest671)
end
|  ( 41, ( ( _, ( MlyValue.match' match'1, _, match'1right)) :: _ :: (
 _, ( MlyValue.rule rule1, rule1left, _)) :: rest671)) => let val  
result = MlyValue.match' (fn _ => let val  (rule as rule1) = rule1 ()
 val  (match' as match'1) = match'1 ()
 in (rule :: match')
end)
 in ( LrTable.NT 16, ( result, rule1left, match'1right), rest671)
end
|  ( 42, ( ( _, ( MlyValue.exp exp1, expleft, (expright as exp1right))
) :: _ :: ( _, ( MlyValue.pat pat1, pat1left, _)) :: rest671)) => let
 val  result = MlyValue.rule (fn _ => let val  (pat as pat1) = pat1 ()
 val  (exp as exp1) = exp1 ()
 in (Rule{pat=pat, exp=markexp(exp,expleft,expright)})
end)
 in ( LrTable.NT 17, ( result, pat1left, exp1right), rest671)
end
|  ( 43, ( ( _, ( MlyValue.exp exp1, _, exp1right)) :: _ :: ( _, ( 
MlyValue.selector selector1, selector1left, _)) :: rest671)) => let
 val  result = MlyValue.elabel (fn _ => let val  (selector as 
selector1) = selector1 ()
 val  (exp as exp1) = exp1 ()
 in (selector,exp)
end)
 in ( LrTable.NT 18, ( result, selector1left, exp1right), rest671)
end
|  ( 44, ( ( _, ( MlyValue.id id1, id1left, id1right)) :: rest671)) =>
 let val  result = MlyValue.elabel (fn _ => let val  (id as id1) = id1
 ()
 in (labSymbol id, VarExp [varSymbol id])
end)
 in ( LrTable.NT 18, ( result, id1left, id1right), rest671)
end
|  ( 45, ( ( _, ( MlyValue.elabels elabels1, _, elabels1right)) :: _
 :: ( _, ( MlyValue.elabel elabel1, elabel1left, _)) :: rest671)) =>
 let val  result = MlyValue.elabels (fn _ => let val  (elabel as 
elabel1) = elabel1 ()
 val  (elabels as elabels1) = elabels1 ()
 in (elabel :: elabels)
end)
 in ( LrTable.NT 19, ( result, elabel1left, elabels1right), rest671)

end
|  ( 46, ( ( _, ( MlyValue.elabel elabel1, elabel1left, elabel1right))
 :: rest671)) => let val  result = MlyValue.elabels (fn _ => let val 
 (elabel as elabel1) = elabel1 ()
 in ([elabel])
end)
 in ( LrTable.NT 19, ( result, elabel1left, elabel1right), rest671)

end
|  ( 47, ( ( _, ( MlyValue.exp exp1, (expleft as exp1left), (expright
 as exp1right))) :: rest671)) => let val  result = MlyValue.exp_ps (fn
 _ => let val  (exp as exp1) = exp1 ()
 in ([markexp (exp, expleft, expright)])
end)
 in ( LrTable.NT 20, ( result, exp1left, exp1right), rest671)
end
|  ( 48, ( ( _, ( MlyValue.exp_ps exp_ps1, _, exp_ps1right)) :: _ :: (
 _, ( MlyValue.exp exp1, (expleft as exp1left), expright)) :: rest671)
) => let val  result = MlyValue.exp_ps (fn _ => let val  (exp as exp1)
 = exp1 ()
 val  (exp_ps as exp_ps1) = exp_ps1 ()
 in (markexp (exp, expleft, expright) :: exp_ps)
end)
 in ( LrTable.NT 20, ( result, exp1left, exp_ps1right), rest671)
end
|  ( 49, ( ( _, ( MlyValue.match match1, _, match1right)) :: _ :: ( _,
 ( MlyValue.exp exp1, exp1left, _)) :: rest671)) => let val  result = 
MlyValue.exp (fn _ => let val  (exp as exp1) = exp1 ()
 val  (match as match1) = match1 ()
 in (HandleExp{expr=exp,rules=match})
end)
 in ( LrTable.NT 21, ( result, exp1left, match1right), rest671)
end
|  ( 50, ( ( _, ( MlyValue.exp exp2, exp2left, exp2right)) :: _ :: ( _
, ( MlyValue.exp exp1, exp1left, exp1right)) :: rest671)) => let val  
result = MlyValue.exp (fn _ => let val  exp1 = exp1 ()
 val  exp2 = exp2 ()
 in (
OrelseExp(markexp(exp1,exp1left,exp1right),
					   markexp(exp2,exp2left,exp2right))
)
end)
 in ( LrTable.NT 21, ( result, exp1left, exp2right), rest671)
end
|  ( 51, ( ( _, ( MlyValue.exp exp2, exp2left, exp2right)) :: _ :: ( _
, ( MlyValue.exp exp1, exp1left, exp1right)) :: rest671)) => let val  
result = MlyValue.exp (fn _ => let val  exp1 = exp1 ()
 val  exp2 = exp2 ()
 in (
AndalsoExp(markexp(exp1,exp1left,exp1right),
					    markexp(exp2,exp2left,exp2right))
)
end)
 in ( LrTable.NT 21, ( result, exp1left, exp2right), rest671)
end
|  ( 52, ( ( _, ( MlyValue.ty ty1, _, ty1right)) :: _ :: ( _, ( 
MlyValue.exp exp1, exp1left, _)) :: rest671)) => let val  result = 
MlyValue.exp (fn _ => let val  (exp as exp1) = exp1 ()
 val  (ty as ty1) = ty1 ()
 in (ConstraintExp{expr=exp,constraint=ty})
end)
 in ( LrTable.NT 21, ( result, exp1left, ty1right), rest671)
end
|  ( 53, ( ( _, ( MlyValue.app_exp app_exp1, app_exp1left, 
app_exp1right)) :: rest671)) => let val  result = MlyValue.exp (fn _
 => let val  (app_exp as app_exp1) = app_exp1 ()
 in (FlatAppExp(app_exp))
end)
 in ( LrTable.NT 21, ( result, app_exp1left, app_exp1right), rest671)

end
|  ( 54, ( ( _, ( MlyValue.match match1, _, (matchright as match1right
))) :: ( _, ( _, (FNleft as FN1left), _)) :: rest671)) => let val  
result = MlyValue.exp (fn _ => let val  (match as match1) = match1 ()
 in (markexp(FnExp match, FNleft,matchright))
end)
 in ( LrTable.NT 21, ( result, FN1left, match1right), rest671)
end
|  ( 55, ( ( _, ( MlyValue.match match1, _, (matchright as match1right
))) :: _ :: ( _, ( MlyValue.exp exp1, _, _)) :: ( _, ( _, (CASEleft
 as CASE1left), _)) :: rest671)) => let val  result = MlyValue.exp (fn
 _ => let val  (exp as exp1) = exp1 ()
 val  (match as match1) = match1 ()
 in (
markexp(CaseExp{expr=exp, rules=match},
					 CASEleft,matchright))

end)
 in ( LrTable.NT 21, ( result, CASE1left, match1right), rest671)
end
|  ( 56, ( ( _, ( MlyValue.exp exp2, exp2left, exp2right)) :: _ :: ( _
, ( MlyValue.exp exp1, exp1left, exp1right)) :: ( _, ( _, WHILE1left,
 _)) :: rest671)) => let val  result = MlyValue.exp (fn _ => let val  
exp1 = exp1 ()
 val  exp2 = exp2 ()
 in (
WhileExp
                                   {test=markexp(exp1, exp1left, exp1right),
				    expr=markexp(exp2, exp2left, exp2right)}
)
end)
 in ( LrTable.NT 21, ( result, WHILE1left, exp2right), rest671)
end
|  ( 57, ( ( _, ( MlyValue.exp exp3, exp3left, exp3right)) :: _ :: ( _
, ( MlyValue.exp exp2, exp2left, exp2right)) :: _ :: ( _, ( 
MlyValue.exp exp1, _, _)) :: ( _, ( _, IF1left, _)) :: rest671)) =>
 let val  result = MlyValue.exp (fn _ => let val  exp1 = exp1 ()
 val  exp2 = exp2 ()
 val  exp3 = exp3 ()
 in (
IfExp{test=exp1,
				   thenCase=markexp(exp2,exp2left,exp2right),
				   elseCase=markexp(exp3,exp3left,exp3right)}
)
end)
 in ( LrTable.NT 21, ( result, IF1left, exp3right), rest671)
end
|  ( 58, ( ( _, ( MlyValue.exp exp1, expleft, (expright as exp1right))
) :: ( _, ( _, (RAISEleft as RAISE1left), _)) :: rest671)) => let val 
 result = MlyValue.exp (fn _ => let val  (exp as exp1) = exp1 ()
 in (
markexp(markexp(RaiseExp exp, expleft,expright),
					 RAISEleft,expright)
)
end)
 in ( LrTable.NT 21, ( result, RAISE1left, exp1right), rest671)
end
|  ( 59, ( ( _, ( MlyValue.aexp aexp1, (aexpleft as aexp1left), (
aexpright as aexp1right))) :: rest671)) => let val  result = 
MlyValue.app_exp (fn _ => let val  (aexp as aexp1) = aexp1 ()
 in (
[{item=markexp(aexp,aexpleft,aexpright),
			   region=(aexpleft,aexpright), fixity=NONE}]
)
end)
 in ( LrTable.NT 22, ( result, aexp1left, aexp1right), rest671)
end
|  ( 60, ( ( _, ( MlyValue.ident ident1, (identleft as ident1left), (
identright as ident1right))) :: rest671)) => let val  result = 
MlyValue.app_exp (fn _ => let val  (ident as ident1) = ident1 ()
 in (
[let val (v,f) = var'n'fix ident
			    in {item=markexp(VarExp [v],identleft,identright),
				region=(identleft,identright),
				fixity=SOME f}
			    end]
)
end)
 in ( LrTable.NT 22, ( result, ident1left, ident1right), rest671)
end
|  ( 61, ( ( _, ( MlyValue.app_exp app_exp1, _, app_exp1right)) :: ( _
, ( MlyValue.aexp aexp1, (aexpleft as aexp1left), aexpright)) :: 
rest671)) => let val  result = MlyValue.app_exp (fn _ => let val  (
aexp as aexp1) = aexp1 ()
 val  (app_exp as app_exp1) = app_exp1 ()
 in (
{item=markexp(aexp,aexpleft,aexpright),
			  region=(aexpleft,aexpright), fixity=NONE}
                            :: app_exp
)
end)
 in ( LrTable.NT 22, ( result, aexp1left, app_exp1right), rest671)
end
|  ( 62, ( ( _, ( MlyValue.app_exp app_exp1, _, app_exp1right)) :: ( _
, ( MlyValue.ident ident1, (identleft as ident1left), identright)) :: 
rest671)) => let val  result = MlyValue.app_exp (fn _ => let val  (
ident as ident1) = ident1 ()
 val  (app_exp as app_exp1) = app_exp1 ()
 in (
let val (v,f) = var'n'fix ident
			  in {item=markexp(VarExp [v],identleft,identright),
			      region=(identleft,identright),
				fixity=SOME f} :: app_exp
			 end
)
end)
 in ( LrTable.NT 22, ( result, ident1left, app_exp1right), rest671)

end
|  ( 63, ( ( _, ( MlyValue.ident ident1, _, ident1right)) :: ( _, ( _,
 OP1left, _)) :: rest671)) => let val  result = MlyValue.aexp (fn _ =>
 let val  (ident as ident1) = ident1 ()
 in (VarExp [varSymbol ident])
end)
 in ( LrTable.NT 23, ( result, OP1left, ident1right), rest671)
end
|  ( 64, ( ( _, ( MlyValue.qident qident1, _, qident1right)) :: _ :: (
 _, ( MlyValue.IDA IDA1, _, _)) :: ( _, ( _, OP1left, _)) :: rest671))
 => let val  result = MlyValue.aexp (fn _ => let val  (IDA as IDA1) = 
IDA1 ()
 val  (qident as qident1) = qident1 ()
 in (VarExp (strSymbol IDA :: qident varSymbol))
end)
 in ( LrTable.NT 23, ( result, OP1left, qident1right), rest671)
end
|  ( 65, ( ( _, ( MlyValue.qident qident1, _, qident1right)) :: _ :: (
 _, ( MlyValue.IDA IDA1, IDA1left, _)) :: rest671)) => let val  result
 = MlyValue.aexp (fn _ => let val  (IDA as IDA1) = IDA1 ()
 val  (qident as qident1) = qident1 ()
 in (VarExp (strSymbol IDA :: qident varSymbol))
end)
 in ( LrTable.NT 23, ( result, IDA1left, qident1right), rest671)
end
|  ( 66, ( ( _, ( MlyValue.int int1, int1left, int1right)) :: rest671)
) => let val  result = MlyValue.aexp (fn _ => let val  (int as int1) =
 int1 ()
 in (IntExp int)
end)
 in ( LrTable.NT 23, ( result, int1left, int1right), rest671)
end
|  ( 67, ( ( _, ( MlyValue.WORD WORD1, WORD1left, WORD1right)) :: 
rest671)) => let val  result = MlyValue.aexp (fn _ => let val  (WORD
 as WORD1) = WORD1 ()
 in (WordExp WORD)
end)
 in ( LrTable.NT 23, ( result, WORD1left, WORD1right), rest671)
end
|  ( 68, ( ( _, ( MlyValue.REAL REAL1, REAL1left, REAL1right)) :: 
rest671)) => let val  result = MlyValue.aexp (fn _ => let val  (REAL
 as REAL1) = REAL1 ()
 in (RealExp REAL)
end)
 in ( LrTable.NT 23, ( result, REAL1left, REAL1right), rest671)
end
|  ( 69, ( ( _, ( MlyValue.STRING STRING1, STRING1left, STRING1right))
 :: rest671)) => let val  result = MlyValue.aexp (fn _ => let val  (
STRING as STRING1) = STRING1 ()
 in (StringExp STRING)
end)
 in ( LrTable.NT 23, ( result, STRING1left, STRING1right), rest671)

end
|  ( 70, ( ( _, ( MlyValue.CHAR CHAR1, CHAR1left, CHAR1right)) :: 
rest671)) => let val  result = MlyValue.aexp (fn _ => let val  (CHAR
 as CHAR1) = CHAR1 ()
 in (CharExp CHAR)
end)
 in ( LrTable.NT 23, ( result, CHAR1left, CHAR1right), rest671)
end
|  ( 71, ( ( _, ( MlyValue.selector selector1, _, (selectorright as 
selector1right))) :: ( _, ( _, (HASHleft as HASH1left), _)) :: rest671
)) => let val  result = MlyValue.aexp (fn _ => let val  (selector as 
selector1) = selector1 ()
 in (markexp(SelectorExp selector,
						   HASHleft, selectorright))

end)
 in ( LrTable.NT 23, ( result, HASH1left, selector1right), rest671)

end
|  ( 72, ( ( _, ( _, _, (RBRACEright as RBRACE1right))) :: ( _, ( 
MlyValue.elabels elabels1, _, _)) :: ( _, ( _, (LBRACEleft as 
LBRACE1left), _)) :: rest671)) => let val  result = MlyValue.aexp (fn
 _ => let val  (elabels as elabels1) = elabels1 ()
 in (markexp(RecordExp elabels,
					 LBRACEleft,RBRACEright))
end)
 in ( LrTable.NT 23, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 73, ( ( _, ( _, _, RBRACE1right)) :: ( _, ( _, LBRACE1left, _))
 :: rest671)) => let val  result = MlyValue.aexp (fn _ => (
RecordExp nil))
 in ( LrTable.NT 23, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 74, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( _, LPAREN1left, _))
 :: rest671)) => let val  result = MlyValue.aexp (fn _ => (unitExp))
 in ( LrTable.NT 23, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 75, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.exp_ps 
exp_ps1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.aexp (fn _ => let val  (exp_ps as exp_ps1) = 
exp_ps1 ()
 in (SeqExp exp_ps)
end)
 in ( LrTable.NT 23, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 76, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.exp_2c 
exp_2c1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.aexp (fn _ => let val  (exp_2c as exp_2c1) = 
exp_2c1 ()
 in (TupleExp exp_2c)
end)
 in ( LrTable.NT 23, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 77, ( ( _, ( _, _, RBRACKET1right)) :: ( _, ( MlyValue.exp_list 
exp_list1, _, _)) :: ( _, ( _, LBRACKET1left, _)) :: rest671)) => let
 val  result = MlyValue.aexp (fn _ => let val  (exp_list as exp_list1)
 = exp_list1 ()
 in (ListExp exp_list)
end)
 in ( LrTable.NT 23, ( result, LBRACKET1left, RBRACKET1right), rest671
)
end
|  ( 78, ( ( _, ( _, _, RBRACKET1right)) :: ( _, ( _, LBRACKET1left, _
)) :: rest671)) => let val  result = MlyValue.aexp (fn _ => (
ListExp nil))
 in ( LrTable.NT 23, ( result, LBRACKET1left, RBRACKET1right), rest671
)
end
|  ( 79, ( ( _, ( _, _, RBRACKET1right)) :: ( _, ( MlyValue.exp_list 
exp_list1, _, _)) :: ( _, ( _, VECTORSTART1left, _)) :: rest671)) =>
 let val  result = MlyValue.aexp (fn _ => let val  (exp_list as 
exp_list1) = exp_list1 ()
 in (VectorExp exp_list)
end)
 in ( LrTable.NT 23, ( result, VECTORSTART1left, RBRACKET1right), 
rest671)
end
|  ( 80, ( ( _, ( _, _, RBRACKET1right)) :: ( _, ( _, VECTORSTART1left
, _)) :: rest671)) => let val  result = MlyValue.aexp (fn _ => (
VectorExp nil))
 in ( LrTable.NT 23, ( result, VECTORSTART1left, RBRACKET1right), 
rest671)
end
|  ( 81, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.exp_ps exp_ps1, _, _)) :: _ :: ( _, ( MlyValue.ldecs ldecs1, 
ldecsleft, ldecsright)) :: ( _, ( _, (LETleft as LET1left), _)) :: 
rest671)) => let val  result = MlyValue.aexp (fn _ => let val  (ldecs
 as ldecs1) = ldecs1 ()
 val  (exp_ps as exp_ps1) = exp_ps1 ()
 in (
markexp (LetExp{dec=markdec(ldecs,ldecsleft,
							     ldecsright),
						 expr=SeqExp exp_ps},
					  LETleft,ENDright)
)
end)
 in ( LrTable.NT 23, ( result, LET1left, END1right), rest671)
end
|  ( 82, ( ( _, ( MlyValue.AQID AQID1, AQID1left, AQID1right)) :: 
rest671)) => let val  result = MlyValue.aexp (fn _ => let val  (AQID
 as AQID1) = AQID1 ()
 in (VarExp([varSymbol AQID]))
end)
 in ( LrTable.NT 23, ( result, AQID1left, AQID1right), rest671)
end
|  ( 83, ( ( _, ( MlyValue.quote quote1, quote1left, quote1right)) :: 
rest671)) => let val  result = MlyValue.aexp (fn _ => let val  (quote
 as quote1) = quote1 ()
 in (ListExp quote)
end)
 in ( LrTable.NT 23, ( result, quote1left, quote1right), rest671)
end
|  ( 84, ( ( _, ( MlyValue.ENDQ ENDQ1, _, ENDQ1right)) :: ( _, ( _, 
BEGINQ1left, _)) :: rest671)) => let val  result = MlyValue.quote (fn
 _ => let val  (ENDQ as ENDQ1) = ENDQ1 ()
 in ([quoteExp ENDQ])
end)
 in ( LrTable.NT 26, ( result, BEGINQ1left, ENDQ1right), rest671)
end
|  ( 85, ( ( _, ( MlyValue.ENDQ ENDQ1, _, ENDQ1right)) :: ( _, ( 
MlyValue.ot_list ot_list1, _, _)) :: ( _, ( _, BEGINQ1left, _)) :: 
rest671)) => let val  result = MlyValue.quote (fn _ => let val  (
ot_list as ot_list1) = ot_list1 ()
 val  (ENDQ as ENDQ1) = ENDQ1 ()
 in (ot_list @ [quoteExp ENDQ])
end)
 in ( LrTable.NT 26, ( result, BEGINQ1left, ENDQ1right), rest671)
end
|  ( 86, ( ( _, ( MlyValue.aexp aexp1, _, aexp1right)) :: ( _, ( 
MlyValue.OBJL OBJL1, OBJL1left, _)) :: rest671)) => let val  result = 
MlyValue.ot_list (fn _ => let val  (OBJL as OBJL1) = OBJL1 ()
 val  (aexp as aexp1) = aexp1 ()
 in ([quoteExp OBJL, antiquoteExp aexp])
end)
 in ( LrTable.NT 27, ( result, OBJL1left, aexp1right), rest671)
end
|  ( 87, ( ( _, ( MlyValue.ot_list ot_list1, _, ot_list1right)) :: ( _
, ( MlyValue.aexp aexp1, _, _)) :: ( _, ( MlyValue.OBJL OBJL1, 
OBJL1left, _)) :: rest671)) => let val  result = MlyValue.ot_list (fn
 _ => let val  (OBJL as OBJL1) = OBJL1 ()
 val  (aexp as aexp1) = aexp1 ()
 val  (ot_list as ot_list1) = ot_list1 ()
 in (
quoteExp OBJL :: antiquoteExp aexp ::
                                            ot_list
)
end)
 in ( LrTable.NT 27, ( result, OBJL1left, ot_list1right), rest671)
end
|  ( 88, ( ( _, ( MlyValue.exp_2c exp_2c1, _, exp_2c1right)) :: _ :: (
 _, ( MlyValue.exp exp1, exp1left, _)) :: rest671)) => let val  result
 = MlyValue.exp_2c (fn _ => let val  (exp as exp1) = exp1 ()
 val  (exp_2c as exp_2c1) = exp_2c1 ()
 in (exp :: exp_2c)
end)
 in ( LrTable.NT 25, ( result, exp1left, exp_2c1right), rest671)
end
|  ( 89, ( ( _, ( MlyValue.exp exp2, _, exp2right)) :: _ :: ( _, ( 
MlyValue.exp exp1, exp1left, _)) :: rest671)) => let val  result = 
MlyValue.exp_2c (fn _ => let val  exp1 = exp1 ()
 val  exp2 = exp2 ()
 in ([exp1, exp2])
end)
 in ( LrTable.NT 25, ( result, exp1left, exp2right), rest671)
end
|  ( 90, ( ( _, ( MlyValue.exp exp1, exp1left, exp1right)) :: rest671)
) => let val  result = MlyValue.exp_list (fn _ => let val  (exp as 
exp1) = exp1 ()
 in ([exp])
end)
 in ( LrTable.NT 24, ( result, exp1left, exp1right), rest671)
end
|  ( 91, ( ( _, ( MlyValue.exp_list exp_list1, _, exp_list1right)) ::
 _ :: ( _, ( MlyValue.exp exp1, exp1left, _)) :: rest671)) => let val 
 result = MlyValue.exp_list (fn _ => let val  (exp as exp1) = exp1 ()
 val  (exp_list as exp_list1) = exp_list1 ()
 in (exp :: exp_list)
end)
 in ( LrTable.NT 24, ( result, exp1left, exp_list1right), rest671)
end
|  ( 92, ( ( _, ( MlyValue.pat pat2, _, pat2right)) :: _ :: ( _, ( 
MlyValue.pat pat1, pat1left, _)) :: rest671)) => let val  result = 
MlyValue.pat (fn _ => let val  pat1 = pat1 ()
 val  pat2 = pat2 ()
 in (layered(pat1, pat2,
					 error(pat1left,pat2right)))
end)
 in ( LrTable.NT 28, ( result, pat1left, pat2right), rest671)
end
|  ( 93, ( ( _, ( MlyValue.ty ty1, _, (tyright as ty1right))) :: _ :: 
( _, ( MlyValue.pat pat1, (patleft as pat1left), _)) :: rest671)) =>
 let val  result = MlyValue.pat (fn _ => let val  (pat as pat1) = pat1
 ()
 val  (ty as ty1) = ty1 ()
 in (
markpat(ConstraintPat{pattern=pat, constraint=ty},patleft,tyright))

end)
 in ( LrTable.NT 28, ( result, pat1left, ty1right), rest671)
end
|  ( 94, ( ( _, ( MlyValue.apats apats1, (apatsleft as apats1left), (
apatsright as apats1right))) :: rest671)) => let val  result = 
MlyValue.pat (fn _ => let val  (apats as apats1) = apats1 ()
 in (markpat(FlatAppPat apats, apatsleft, apatsright))
end)
 in ( LrTable.NT 28, ( result, apats1left, apats1right), rest671)
end
|  ( 95, ( ( _, ( MlyValue.apat' apat'1, (apat'left as apat'1left), (
apat'right as apat'1right))) :: rest671)) => let val  result = 
MlyValue.apat (fn _ => let val  (apat' as apat'1) = apat'1 ()
 in (
{item=markpat(apat',apat'left,apat'right),
				  region=(apat'left,apat'right),
			          fixity=NONE}
)
end)
 in ( LrTable.NT 29, ( result, apat'1left, apat'1right), rest671)
end
|  ( 96, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.pat pat1, _, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)
) :: rest671)) => let val  result = MlyValue.apat (fn _ => let val  (
pat as pat1) = pat1 ()
 in (
{item=pat,
				  region=(LPARENleft,RPARENright),
				  fixity=NONE})

end)
 in ( LrTable.NT 29, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 97, ( ( _, ( MlyValue.id id1, (idleft as id1left), (idright as 
id1right))) :: rest671)) => let val  result = MlyValue.apat (fn _ =>
 let val  (id as id1) = id1 ()
 in (
let val (v,f) = var'n'fix id
				 in {item=markpat(VarPat [v],idleft,idright),
				     region=(idleft,idright),
				     fixity=SOME f} end
)
end)
 in ( LrTable.NT 29, ( result, id1left, id1right), rest671)
end
|  ( 98, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( _, (
LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.apat (fn _ => (
{item=markpat(unitPat,LPARENleft,RPARENright),
				  region=(LPARENleft,RPARENright),
				  fixity=NONE}
))
 in ( LrTable.NT 29, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 99, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.pat_list pat_list1, _, _)) :: _ :: ( _, ( MlyValue.pat pat1,
 _, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) =>
 let val  result = MlyValue.apat (fn _ => let val  (pat as pat1) = 
pat1 ()
 val  (pat_list as pat_list1) = pat_list1 ()
 in (
{item=markpat(TuplePat(pat :: pat_list),LPARENleft,RPARENright),
				  region=(LPARENleft,RPARENright),
				  fixity=NONE}
)
end)
 in ( LrTable.NT 29, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 100, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.or_pat_list or_pat_list1, _, _)) :: _ :: ( _, ( MlyValue.pat 
pat1, _, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)
) => let val  result = MlyValue.apat (fn _ => let val  (pat as pat1) =
 pat1 ()
 val  (or_pat_list as or_pat_list1) = or_pat_list1 ()
 in (
{item=markpat(OrPat(pat :: or_pat_list),LPARENleft,RPARENright),
				  region=(LPARENleft,RPARENright),
				  fixity=NONE}
)
end)
 in ( LrTable.NT 29, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 101, ( ( _, ( MlyValue.id id1, _, id1right)) :: ( _, ( _, OP1left
, _)) :: rest671)) => let val  result = MlyValue.apat' (fn _ => let
 val  (id as id1) = id1 ()
 in (VarPat [varSymbol id])
end)
 in ( LrTable.NT 30, ( result, OP1left, id1right), rest671)
end
|  ( 102, ( ( _, ( MlyValue.qid qid1, _, qid1right)) :: _ :: ( _, ( 
MlyValue.IDA IDA1, _, _)) :: ( _, ( _, OP1left, _)) :: rest671)) =>
 let val  result = MlyValue.apat' (fn _ => let val  (IDA as IDA1) = 
IDA1 ()
 val  (qid as qid1) = qid1 ()
 in (VarPat (strSymbol IDA :: qid varSymbol))
end)
 in ( LrTable.NT 30, ( result, OP1left, qid1right), rest671)
end
|  ( 103, ( ( _, ( MlyValue.qid qid1, _, qid1right)) :: _ :: ( _, ( 
MlyValue.IDA IDA1, IDA1left, _)) :: rest671)) => let val  result = 
MlyValue.apat' (fn _ => let val  (IDA as IDA1) = IDA1 ()
 val  (qid as qid1) = qid1 ()
 in (VarPat (strSymbol IDA :: qid varSymbol))
end)
 in ( LrTable.NT 30, ( result, IDA1left, qid1right), rest671)
end
|  ( 104, ( ( _, ( MlyValue.int int1, int1left, int1right)) :: rest671
)) => let val  result = MlyValue.apat' (fn _ => let val  (int as int1)
 = int1 ()
 in (IntPat int)
end)
 in ( LrTable.NT 30, ( result, int1left, int1right), rest671)
end
|  ( 105, ( ( _, ( MlyValue.WORD WORD1, WORD1left, WORD1right)) :: 
rest671)) => let val  result = MlyValue.apat' (fn _ => let val  (WORD
 as WORD1) = WORD1 ()
 in (WordPat WORD)
end)
 in ( LrTable.NT 30, ( result, WORD1left, WORD1right), rest671)
end
|  ( 106, ( ( _, ( MlyValue.STRING STRING1, STRING1left, STRING1right)
) :: rest671)) => let val  result = MlyValue.apat' (fn _ => let val  (
STRING as STRING1) = STRING1 ()
 in (StringPat STRING)
end)
 in ( LrTable.NT 30, ( result, STRING1left, STRING1right), rest671)

end
|  ( 107, ( ( _, ( MlyValue.CHAR CHAR1, CHAR1left, CHAR1right)) :: 
rest671)) => let val  result = MlyValue.apat' (fn _ => let val  (CHAR
 as CHAR1) = CHAR1 ()
 in (CharPat CHAR)
end)
 in ( LrTable.NT 30, ( result, CHAR1left, CHAR1right), rest671)
end
|  ( 108, ( ( _, ( _, WILD1left, WILD1right)) :: rest671)) => let val 
 result = MlyValue.apat' (fn _ => (WildPat))
 in ( LrTable.NT 30, ( result, WILD1left, WILD1right), rest671)
end
|  ( 109, ( ( _, ( _, _, RBRACKET1right)) :: ( _, ( _, LBRACKET1left,
 _)) :: rest671)) => let val  result = MlyValue.apat' (fn _ => (
ListPat nil))
 in ( LrTable.NT 30, ( result, LBRACKET1left, RBRACKET1right), rest671
)
end
|  ( 110, ( ( _, ( _, _, RBRACKET1right)) :: ( _, ( MlyValue.pat_list 
pat_list1, _, _)) :: ( _, ( _, LBRACKET1left, _)) :: rest671)) => let
 val  result = MlyValue.apat' (fn _ => let val  (pat_list as pat_list1
) = pat_list1 ()
 in (ListPat pat_list)
end)
 in ( LrTable.NT 30, ( result, LBRACKET1left, RBRACKET1right), rest671
)
end
|  ( 111, ( ( _, ( _, _, RBRACKET1right)) :: ( _, ( _, 
VECTORSTART1left, _)) :: rest671)) => let val  result = MlyValue.apat'
 (fn _ => (VectorPat nil))
 in ( LrTable.NT 30, ( result, VECTORSTART1left, RBRACKET1right), 
rest671)
end
|  ( 112, ( ( _, ( _, _, RBRACKET1right)) :: ( _, ( MlyValue.pat_list 
pat_list1, _, _)) :: ( _, ( _, VECTORSTART1left, _)) :: rest671)) =>
 let val  result = MlyValue.apat' (fn _ => let val  (pat_list as 
pat_list1) = pat_list1 ()
 in (VectorPat pat_list)
end)
 in ( LrTable.NT 30, ( result, VECTORSTART1left, RBRACKET1right), 
rest671)
end
|  ( 113, ( ( _, ( _, _, RBRACE1right)) :: ( _, ( _, LBRACE1left, _))
 :: rest671)) => let val  result = MlyValue.apat' (fn _ => (unitPat))
 in ( LrTable.NT 30, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 114, ( ( _, ( _, _, RBRACE1right)) :: ( _, ( MlyValue.plabels 
plabels1, _, _)) :: ( _, ( _, LBRACE1left, _)) :: rest671)) => let
 val  result = MlyValue.apat' (fn _ => let val  (plabels as plabels1)
 = plabels1 ()
 in (
let val (d,f) = plabels
			          in RecordPat{def=d,flexibility=f}
                                 end
)
end)
 in ( LrTable.NT 30, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 115, ( ( _, ( MlyValue.pat pat1, _, pat1right)) :: _ :: ( _, ( 
MlyValue.selector selector1, selector1left, _)) :: rest671)) => let
 val  result = MlyValue.plabel (fn _ => let val  (selector as 
selector1) = selector1 ()
 val  (pat as pat1) = pat1 ()
 in ((selector,pat))
end)
 in ( LrTable.NT 31, ( result, selector1left, pat1right), rest671)
end
|  ( 116, ( ( _, ( MlyValue.id id1, id1left, id1right)) :: rest671))
 => let val  result = MlyValue.plabel (fn _ => let val  (id as id1) = 
id1 ()
 in (labSymbol id, VarPat [varSymbol id])
end)
 in ( LrTable.NT 31, ( result, id1left, id1right), rest671)
end
|  ( 117, ( ( _, ( MlyValue.pat pat1, _, pat1right)) :: _ :: ( _, ( 
MlyValue.id id1, id1left, _)) :: rest671)) => let val  result = 
MlyValue.plabel (fn _ => let val  (id as id1) = id1 ()
 val  (pat as pat1) = pat1 ()
 in (
labSymbol id,
				 LayeredPat{varPat=VarPat [varSymbol id],
					    expPat=pat}
)
end)
 in ( LrTable.NT 31, ( result, id1left, pat1right), rest671)
end
|  ( 118, ( ( _, ( MlyValue.ty ty1, _, ty1right)) :: _ :: ( _, ( 
MlyValue.id id1, id1left, _)) :: rest671)) => let val  result = 
MlyValue.plabel (fn _ => let val  (id as id1) = id1 ()
 val  (ty as ty1) = ty1 ()
 in (
labSymbol id,
				 ConstraintPat{pattern=VarPat [varSymbol id],
					       constraint=ty}
)
end)
 in ( LrTable.NT 31, ( result, id1left, ty1right), rest671)
end
|  ( 119, ( ( _, ( MlyValue.pat pat1, _, pat1right)) :: _ :: ( _, ( 
MlyValue.ty ty1, _, _)) :: _ :: ( _, ( MlyValue.id id1, id1left, _))
 :: rest671)) => let val  result = MlyValue.plabel (fn _ => let val  (
id as id1) = id1 ()
 val  (ty as ty1) = ty1 ()
 val  (pat as pat1) = pat1 ()
 in (
labSymbol id,
				 LayeredPat
				 {varPat=ConstraintPat{pattern=VarPat [varSymbol id],
						       constraint=ty},
				  expPat=pat}
)
end)
 in ( LrTable.NT 31, ( result, id1left, pat1right), rest671)
end
|  ( 120, ( ( _, ( MlyValue.plabels plabels1, _, plabels1right)) :: _
 :: ( _, ( MlyValue.plabel plabel1, plabel1left, _)) :: rest671)) =>
 let val  result = MlyValue.plabels (fn _ => let val  (plabel as 
plabel1) = plabel1 ()
 val  (plabels as plabels1) = plabels1 ()
 in (let val (a,(b,fx))=(plabel, plabels)
				 in (a::b, fx) end)
end)
 in ( LrTable.NT 32, ( result, plabel1left, plabels1right), rest671)

end
|  ( 121, ( ( _, ( MlyValue.plabel plabel1, plabel1left, plabel1right)
) :: rest671)) => let val  result = MlyValue.plabels (fn _ => let val 
 (plabel as plabel1) = plabel1 ()
 in ([plabel],false)
end)
 in ( LrTable.NT 32, ( result, plabel1left, plabel1right), rest671)

end
|  ( 122, ( ( _, ( _, DOTDOTDOT1left, DOTDOTDOT1right)) :: rest671))
 => let val  result = MlyValue.plabels (fn _ => (nil, true))
 in ( LrTable.NT 32, ( result, DOTDOTDOT1left, DOTDOTDOT1right), 
rest671)
end
|  ( 123, ( ( _, ( MlyValue.pat pat1, pat1left, pat1right)) :: rest671
)) => let val  result = MlyValue.pat_list (fn _ => let val  (pat as 
pat1) = pat1 ()
 in ([pat])
end)
 in ( LrTable.NT 34, ( result, pat1left, pat1right), rest671)
end
|  ( 124, ( ( _, ( MlyValue.pat_list pat_list1, _, pat_list1right)) ::
 _ :: ( _, ( MlyValue.pat pat1, pat1left, _)) :: rest671)) => let val 
 result = MlyValue.pat_list (fn _ => let val  (pat as pat1) = pat1 ()
 val  (pat_list as pat_list1) = pat_list1 ()
 in (pat :: pat_list)
end)
 in ( LrTable.NT 34, ( result, pat1left, pat_list1right), rest671)
end
|  ( 125, ( ( _, ( MlyValue.pat pat1, pat1left, pat1right)) :: rest671
)) => let val  result = MlyValue.or_pat_list (fn _ => let val  (pat
 as pat1) = pat1 ()
 in ([pat])
end)
 in ( LrTable.NT 35, ( result, pat1left, pat1right), rest671)
end
|  ( 126, ( ( _, ( MlyValue.or_pat_list or_pat_list1, _, 
or_pat_list1right)) :: _ :: ( _, ( MlyValue.pat pat1, pat1left, _)) ::
 rest671)) => let val  result = MlyValue.or_pat_list (fn _ => let val 
 (pat as pat1) = pat1 ()
 val  (or_pat_list as or_pat_list1) = or_pat_list1 ()
 in (pat :: or_pat_list)
end)
 in ( LrTable.NT 35, ( result, pat1left, or_pat_list1right), rest671)

end
|  ( 127, ( ( _, ( MlyValue.vb vb2, _, vb2right)) :: _ :: ( _, ( 
MlyValue.vb vb1, vb1left, _)) :: rest671)) => let val  result = 
MlyValue.vb (fn _ => let val  vb1 = vb1 ()
 val  vb2 = vb2 ()
 in (vb1 @ vb2)
end)
 in ( LrTable.NT 36, ( result, vb1left, vb2right), rest671)
end
|  ( 128, ( ( _, ( MlyValue.exp exp1, _, (expright as exp1right))) ::
 _ :: ( _, ( MlyValue.pat pat1, patleft, _)) :: ( _, ( _, LAZY1left, _
)) :: rest671)) => let val  result = MlyValue.vb (fn _ => let val  (
pat as pat1) = pat1 ()
 val  (exp as exp1) = exp1 ()
 in (
[MarkVb(Vb{exp=exp, pat=pat, lazyp=true},
	                                 (patleft,expright))]
)
end)
 in ( LrTable.NT 36, ( result, LAZY1left, exp1right), rest671)
end
|  ( 129, ( ( _, ( MlyValue.exp exp1, _, (expright as exp1right))) ::
 _ :: ( _, ( MlyValue.pat pat1, (patleft as pat1left), _)) :: rest671)
) => let val  result = MlyValue.vb (fn _ => let val  (pat as pat1) = 
pat1 ()
 val  (exp as exp1) = exp1 ()
 in (
[MarkVb(Vb{exp=exp, pat=pat, lazyp=false},
	                                 (patleft,expright))]
)
end)
 in ( LrTable.NT 36, ( result, pat1left, exp1right), rest671)
end
|  ( 130, ( rest671)) => let val  result = MlyValue.constraint (fn _
 => (NONE))
 in ( LrTable.NT 37, ( result, defaultPos, defaultPos), rest671)
end
|  ( 131, ( ( _, ( MlyValue.ty ty1, _, ty1right)) :: ( _, ( _, 
COLON1left, _)) :: rest671)) => let val  result = MlyValue.constraint
 (fn _ => let val  (ty as ty1) = ty1 ()
 in (SOME ty)
end)
 in ( LrTable.NT 37, ( result, COLON1left, ty1right), rest671)
end
|  ( 132, ( ( _, ( MlyValue.rvb rvb2, _, rvb2right)) :: _ :: ( _, ( 
MlyValue.rvb rvb1, rvb1left, _)) :: rest671)) => let val  result = 
MlyValue.rvb (fn _ => let val  rvb1 = rvb1 ()
 val  rvb2 = rvb2 ()
 in (rvb1 @ rvb2)
end)
 in ( LrTable.NT 38, ( result, rvb1left, rvb2right), rest671)
end
|  ( 133, ( ( _, ( MlyValue.exp exp1, _, (expright as exp1right))) ::
 _ :: ( _, ( MlyValue.rpat rpat1, (rpatleft as rpat1left), _)) :: 
rest671)) => let val  result = MlyValue.rvb (fn _ => let val  (rpat
 as rpat1) = rpat1 ()
 val  (exp as exp1) = exp1 ()
 in ([MarkRvb(rpat (false, exp), (rpatleft, expright))])
end)
 in ( LrTable.NT 38, ( result, rpat1left, exp1right), rest671)
end
|  ( 134, ( ( _, ( MlyValue.exp exp1, _, (expright as exp1right))) ::
 _ :: ( _, ( MlyValue.rpat rpat1, _, _)) :: ( _, ( _, (LAZYleft as 
LAZY1left), _)) :: rest671)) => let val  result = MlyValue.rvb (fn _
 => let val  (rpat as rpat1) = rpat1 ()
 val  (exp as exp1) = exp1 ()
 in ([MarkRvb(rpat (true, exp), (LAZYleft, expright))])
end)
 in ( LrTable.NT 38, ( result, LAZY1left, exp1right), rest671)
end
|  ( 135, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.rpat rpat1,
 _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result
 = MlyValue.rpat (fn _ => let val  (rpat as rpat1) = rpat1 ()
 in (rpat)
end)
 in ( LrTable.NT 39, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 136, ( ( _, ( MlyValue.constraint constraint1, _, 
constraint1right)) :: ( _, ( MlyValue.id id1, (idleft as id1left), 
idright)) :: rest671)) => let val  result = MlyValue.rpat (fn _ => let
 val  (id as id1) = id1 ()
 val  (constraint as constraint1) = constraint1 ()
 in (
fn (lazy, exp) => let
				  val (v,f) = var'n'fix id
	                	  in
				    Rvb{
				        var = v, fixity = SOME(f, (idleft, idright)),
				        resultty = constraint,
				        exp = exp, lazyp = lazy
				      }
				  end
)
end)
 in ( LrTable.NT 39, ( result, id1left, constraint1right), rest671)

end
|  ( 137, ( ( _, ( MlyValue.constraint constraint1, _, 
constraint1right)) :: ( _, ( MlyValue.id id1, _, _)) :: ( _, ( _, 
OP1left, _)) :: rest671)) => let val  result = MlyValue.rpat (fn _ =>
 let val  (id as id1) = id1 ()
 val  (constraint as constraint1) = constraint1 ()
 in (
fn (lazy, exp) => Rvb{
				    var = varSymbol id, fixity = NONE,
				    resultty = constraint,
				    exp = exp, lazyp = lazy
				  }
)
end)
 in ( LrTable.NT 39, ( result, OP1left, constraint1right), rest671)

end
|  ( 138, ( ( _, ( MlyValue.clause clause1, clause1left, clause1right)
) :: rest671)) => let val  result = MlyValue.fb' (fn _ => let val  (
clause as clause1) = clause1 ()
 in ([clause])
end)
 in ( LrTable.NT 40, ( result, clause1left, clause1right), rest671)

end
|  ( 139, ( ( _, ( MlyValue.fb' fb'1, _, fb'1right)) :: _ :: ( _, ( 
MlyValue.clause clause1, clause1left, _)) :: rest671)) => let val  
result = MlyValue.fb' (fn _ => let val  (clause as clause1) = clause1
 ()
 val  (fb' as fb'1) = fb'1 ()
 in (clause :: fb')
end)
 in ( LrTable.NT 40, ( result, clause1left, fb'1right), rest671)
end
|  ( 140, ( ( _, ( MlyValue.fb' fb'1, (fb'left as fb'1left), (fb'right
 as fb'1right))) :: rest671)) => let val  result = MlyValue.fb (fn _
 => let val  (fb' as fb'1) = fb'1 ()
 in ([MarkFb(Fb(fb',false), (fb'left,fb'right))])
end)
 in ( LrTable.NT 41, ( result, fb'1left, fb'1right), rest671)
end
|  ( 141, ( ( _, ( MlyValue.fb' fb'1, fb'left, (fb'right as fb'1right)
)) :: ( _, ( _, LAZY1left, _)) :: rest671)) => let val  result = 
MlyValue.fb (fn _ => let val  (fb' as fb'1) = fb'1 ()
 in ([MarkFb(Fb(fb',true), (fb'left,fb'right))])
end)
 in ( LrTable.NT 41, ( result, LAZY1left, fb'1right), rest671)
end
|  ( 142, ( ( _, ( MlyValue.fb fb1, _, fb1right)) :: _ :: ( _, ( 
MlyValue.fb' fb'1, (fb'left as fb'1left), fb'right)) :: rest671)) =>
 let val  result = MlyValue.fb (fn _ => let val  (fb' as fb'1) = fb'1
 ()
 val  (fb as fb1) = fb1 ()
 in (MarkFb(Fb(fb',false), (fb'left,fb'right)) :: fb)
end)
 in ( LrTable.NT 41, ( result, fb'1left, fb1right), rest671)
end
|  ( 143, ( ( _, ( MlyValue.fb fb1, _, fb1right)) :: _ :: ( _, ( 
MlyValue.fb' fb'1, fb'left, fb'right)) :: ( _, ( _, LAZY1left, _)) :: 
rest671)) => let val  result = MlyValue.fb (fn _ => let val  (fb' as 
fb'1) = fb'1 ()
 val  (fb as fb1) = fb1 ()
 in (MarkFb(Fb(fb',true), (fb'left,fb'right)) :: fb)
end)
 in ( LrTable.NT 41, ( result, LAZY1left, fb1right), rest671)
end
|  ( 144, ( ( _, ( MlyValue.apat apat1, apat1left, apat1right)) :: 
rest671)) => let val  result = MlyValue.apats (fn _ => let val  (apat
 as apat1) = apat1 ()
 in ([apat])
end)
 in ( LrTable.NT 42, ( result, apat1left, apat1right), rest671)
end
|  ( 145, ( ( _, ( MlyValue.apats apats1, _, apats1right)) :: ( _, ( 
MlyValue.apat apat1, apat1left, _)) :: rest671)) => let val  result = 
MlyValue.apats (fn _ => let val  (apat as apat1) = apat1 ()
 val  (apats as apats1) = apats1 ()
 in (apat :: apats)
end)
 in ( LrTable.NT 42, ( result, apat1left, apats1right), rest671)
end
|  ( 146, ( ( _, ( MlyValue.exp exp1, expleft, (expright as exp1right)
)) :: _ :: ( _, ( MlyValue.constraint constraint1, _, _)) :: ( _, ( 
MlyValue.apats apats1, apats1left, _)) :: rest671)) => let val  result
 = MlyValue.clause (fn _ => let val  (apats as apats1) = apats1 ()
 val  (constraint as constraint1) = constraint1 ()
 val  (exp as exp1) = exp1 ()
 in (
Clause{pats=apats,
			resultty=constraint,
			exp=markexp(exp,expleft,expright)}
)
end)
 in ( LrTable.NT 43, ( result, apats1left, exp1right), rest671)
end
|  ( 147, ( ( _, ( MlyValue.ty ty1, _, (tyright as ty1right))) :: _ ::
 ( _, ( MlyValue.idtyc idtyc1, _, _)) :: ( _, ( MlyValue.tyvars 
tyvars1, (tyvarsleft as tyvars1left), _)) :: rest671)) => let val  
result = MlyValue.tb (fn _ => let val  (tyvars as tyvars1) = tyvars1
 ()
 val  (idtyc as idtyc1) = idtyc1 ()
 val  (ty as ty1) = ty1 ()
 in (
[MarkTb(
				   Tb{tyvars=tyvars,tyc=tycSymbol idtyc,def=ty},
				   (tyvarsleft,tyright))]
)
end)
 in ( LrTable.NT 44, ( result, tyvars1left, ty1right), rest671)
end
|  ( 148, ( ( _, ( MlyValue.tb tb2, _, tb2right)) :: _ :: ( _, ( 
MlyValue.tb tb1, tb1left, _)) :: rest671)) => let val  result = 
MlyValue.tb (fn _ => let val  tb1 = tb1 ()
 val  tb2 = tb2 ()
 in (tb1 @ tb2)
end)
 in ( LrTable.NT 44, ( result, tb1left, tb2right), rest671)
end
|  ( 149, ( ( _, ( MlyValue.TYVAR TYVAR1, (TYVARleft as TYVAR1left), (
TYVARright as TYVAR1right))) :: rest671)) => let val  result = 
MlyValue.tyvars (fn _ => let val  (TYVAR as TYVAR1) = TYVAR1 ()
 in ([MarkTyv(Tyv(tyvSymbol TYVAR),
					 (TYVARleft,TYVARright))])

end)
 in ( LrTable.NT 45, ( result, TYVAR1left, TYVAR1right), rest671)
end
|  ( 150, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.tyvar_pc 
tyvar_pc1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.tyvars (fn _ => let val  (tyvar_pc as 
tyvar_pc1) = tyvar_pc1 ()
 in (tyvar_pc)
end)
 in ( LrTable.NT 45, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 151, ( rest671)) => let val  result = MlyValue.tyvars (fn _ => (
nil))
 in ( LrTable.NT 45, ( result, defaultPos, defaultPos), rest671)
end
|  ( 152, ( ( _, ( MlyValue.TYVAR TYVAR1, (TYVARleft as TYVAR1left), (
TYVARright as TYVAR1right))) :: rest671)) => let val  result = 
MlyValue.tyvarseq (fn _ => let val  (TYVAR as TYVAR1) = TYVAR1 ()
 in ([MarkTyv(Tyv(tyvSymbol TYVAR),
					 (TYVARleft,TYVARright))])

end)
 in ( LrTable.NT 46, ( result, TYVAR1left, TYVAR1right), rest671)
end
|  ( 153, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.tyvar_pc 
tyvar_pc1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.tyvarseq (fn _ => let val  (tyvar_pc as 
tyvar_pc1) = tyvar_pc1 ()
 in (tyvar_pc)
end)
 in ( LrTable.NT 46, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 154, ( ( _, ( MlyValue.TYVAR TYVAR1, (TYVARleft as TYVAR1left), (
TYVARright as TYVAR1right))) :: rest671)) => let val  result = 
MlyValue.tyvar_pc (fn _ => let val  (TYVAR as TYVAR1) = TYVAR1 ()
 in ([MarkTyv(Tyv(tyvSymbol TYVAR), (TYVARleft,TYVARright))])
end)
 in ( LrTable.NT 47, ( result, TYVAR1left, TYVAR1right), rest671)
end
|  ( 155, ( ( _, ( MlyValue.tyvar_pc tyvar_pc1, _, tyvar_pc1right)) ::
 _ :: ( _, ( MlyValue.TYVAR TYVAR1, (TYVARleft as TYVAR1left), 
TYVARright)) :: rest671)) => let val  result = MlyValue.tyvar_pc (fn _
 => let val  (TYVAR as TYVAR1) = TYVAR1 ()
 val  (tyvar_pc as tyvar_pc1) = tyvar_pc1 ()
 in (
MarkTyv(Tyv(tyvSymbol TYVAR),(TYVARleft,TYVARright))
				 :: tyvar_pc)

end)
 in ( LrTable.NT 47, ( result, TYVAR1left, tyvar_pc1right), rest671)

end
|  ( 156, ( ( _, ( MlyValue.tycon tycon1, _, tycon1right)) :: _ :: _
 :: ( _, ( MlyValue.idtyc idtyc1, idtyc1left, _)) :: rest671)) => let
 val  result = MlyValue.dtrepl (fn _ => let val  (idtyc as idtyc1) = 
idtyc1 ()
 val  (tycon as tycon1) = tycon1 ()
 in ((tycSymbol idtyc, tycon))
end)
 in ( LrTable.NT 50, ( result, idtyc1left, tycon1right), rest671)
end
|  ( 157, ( ( _, ( MlyValue.db db1, db1left, db1right)) :: rest671))
 => let val  result = MlyValue.dbs (fn _ => let val  (db as db1) = db1
 ()
 in ([db])
end)
 in ( LrTable.NT 49, ( result, db1left, db1right), rest671)
end
|  ( 158, ( ( _, ( MlyValue.dbs dbs1, _, dbs1right)) :: _ :: ( _, ( 
MlyValue.db db1, db1left, _)) :: rest671)) => let val  result = 
MlyValue.dbs (fn _ => let val  (db as db1) = db1 ()
 val  (dbs as dbs1) = dbs1 ()
 in (db :: dbs)
end)
 in ( LrTable.NT 49, ( result, db1left, dbs1right), rest671)
end
|  ( 159, ( ( _, ( MlyValue.constrs constrs1, _, constrs1right)) :: _
 :: ( _, ( MlyValue.idtyc idtyc1, idtyc1left, _)) :: rest671)) => let
 val  result = MlyValue.db (fn _ => let val  (idtyc as idtyc1) = 
idtyc1 ()
 val  (constrs as constrs1) = constrs1 ()
 in (
Db{tyc=tycSymbol idtyc,
					     tyvars=nil,
					     rhs=constrs,lazyp=false}
)
end)
 in ( LrTable.NT 48, ( result, idtyc1left, constrs1right), rest671)

end
|  ( 160, ( ( _, ( MlyValue.constrs constrs1, _, constrs1right)) :: _
 :: ( _, ( MlyValue.idtyc idtyc1, _, _)) :: ( _, ( MlyValue.tyvarseq 
tyvarseq1, tyvarseq1left, _)) :: rest671)) => let val  result = 
MlyValue.db (fn _ => let val  (tyvarseq as tyvarseq1) = tyvarseq1 ()
 val  (idtyc as idtyc1) = idtyc1 ()
 val  (constrs as constrs1) = constrs1 ()
 in (
Db{tyc=tycSymbol idtyc,
					     tyvars=tyvarseq,
					     rhs=constrs,lazyp=false}
)
end)
 in ( LrTable.NT 48, ( result, tyvarseq1left, constrs1right), rest671)

end
|  ( 161, ( ( _, ( MlyValue.constrs constrs1, _, constrs1right)) :: _
 :: ( _, ( MlyValue.idtyc idtyc1, _, _)) :: ( _, ( MlyValue.tyvars 
tyvars1, _, _)) :: ( _, ( _, LAZY1left, _)) :: rest671)) => let val  
result = MlyValue.db (fn _ => let val  (tyvars as tyvars1) = tyvars1
 ()
 val  (idtyc as idtyc1) = idtyc1 ()
 val  (constrs as constrs1) = constrs1 ()
 in (
Db{tyc=tycSymbol idtyc,
                                            tyvars=tyvars,
                                            rhs=constrs,lazyp=true}
)
end)
 in ( LrTable.NT 48, ( result, LAZY1left, constrs1right), rest671)
end
|  ( 162, ( ( _, ( MlyValue.constrs' constrs'1, constrs'1left, 
constrs'1right)) :: rest671)) => let val  result = MlyValue.constrs
 (fn _ => let val  (constrs' as constrs'1) = constrs'1 ()
 in (constrs')
end)
 in ( LrTable.NT 51, ( result, constrs'1left, constrs'1right), rest671
)
end
|  ( 163, ( ( _, ( MlyValue.constrs' constrs'1, _, constrs'1right)) ::
 ( _, ( _, BAR1left, _)) :: rest671)) => let val  result = 
MlyValue.constrs (fn _ => let val  (constrs' as constrs'1) = constrs'1
 ()
 in (constrs')
end)
 in ( LrTable.NT 51, ( result, BAR1left, constrs'1right), rest671)
end
|  ( 164, ( ( _, ( MlyValue.constr constr1, constr1left, constr1right)
) :: rest671)) => let val  result = MlyValue.constrs' (fn _ => let
 val  (constr as constr1) = constr1 ()
 in ([constr])
end)
 in ( LrTable.NT 52, ( result, constr1left, constr1right), rest671)

end
|  ( 165, ( ( _, ( MlyValue.constrs' constrs'1, _, constrs'1right)) ::
 _ :: ( _, ( MlyValue.constr constr1, constr1left, _)) :: rest671)) =>
 let val  result = MlyValue.constrs' (fn _ => let val  (constr as 
constr1) = constr1 ()
 val  (constrs' as constrs'1) = constrs'1 ()
 in (constr :: constrs')
end)
 in ( LrTable.NT 52, ( result, constr1left, constrs'1right), rest671)

end
|  ( 166, ( ( _, ( MlyValue.id id1, _, id1right)) :: ( _, ( 
MlyValue.op_op op_op1, op_op1left, _)) :: rest671)) => let val  result
 = MlyValue.constr (fn _ => let val  op_op1 = op_op1 ()
 val  (id as id1) = id1 ()
 in (varSymbol id, NONE)
end)
 in ( LrTable.NT 53, ( result, op_op1left, id1right), rest671)
end
|  ( 167, ( ( _, ( MlyValue.ty ty1, _, ty1right)) :: _ :: ( _, ( 
MlyValue.id id1, _, _)) :: ( _, ( MlyValue.op_op op_op1, op_op1left, _
)) :: rest671)) => let val  result = MlyValue.constr (fn _ => let val 
 op_op1 = op_op1 ()
 val  (id as id1) = id1 ()
 val  (ty as ty1) = ty1 ()
 in (varSymbol id, SOME ty)
end)
 in ( LrTable.NT 53, ( result, op_op1left, ty1right), rest671)
end
|  ( 168, ( ( _, ( MlyValue.id id1, _, id1right)) :: ( _, ( 
MlyValue.op_op op_op1, op_op1left, _)) :: rest671)) => let val  result
 = MlyValue.eb (fn _ => let val  op_op1 = op_op1 ()
 val  (id as id1) = id1 ()
 in ([EbGen{exn=(varSymbol id),etype=NONE}])
end)
 in ( LrTable.NT 54, ( result, op_op1left, id1right), rest671)
end
|  ( 169, ( ( _, ( MlyValue.ty ty1, _, ty1right)) :: _ :: ( _, ( 
MlyValue.id id1, _, _)) :: ( _, ( MlyValue.op_op op_op1, op_op1left, _
)) :: rest671)) => let val  result = MlyValue.eb (fn _ => let val  
op_op1 = op_op1 ()
 val  (id as id1) = id1 ()
 val  (ty as ty1) = ty1 ()
 in ([EbGen{exn=(varSymbol id),etype=SOME ty}])
end)
 in ( LrTable.NT 54, ( result, op_op1left, ty1right), rest671)
end
|  ( 170, ( ( _, ( MlyValue.qid qid1, _, qid1right)) :: _ :: ( _, ( 
MlyValue.id id1, _, _)) :: ( _, ( MlyValue.op_op op_op1, op_op1left, _
)) :: rest671)) => let val  result = MlyValue.eb (fn _ => let val  
op_op1 = op_op1 ()
 val  (id as id1) = id1 ()
 val  (qid as qid1) = qid1 ()
 in ([EbDef{exn=varSymbol id, edef=qid varSymbol}])
end)
 in ( LrTable.NT 54, ( result, op_op1left, qid1right), rest671)
end
|  ( 171, ( ( _, ( MlyValue.eb eb2, _, eb2right)) :: _ :: ( _, ( 
MlyValue.eb eb1, eb1left, _)) :: rest671)) => let val  result = 
MlyValue.eb (fn _ => let val  eb1 = eb1 ()
 val  eb2 = eb2 ()
 in (eb1 @ eb2)
end)
 in ( LrTable.NT 54, ( result, eb1left, eb2right), rest671)
end
|  ( 172, ( ( _, ( MlyValue.qid qid1, qid1left, qid1right)) :: rest671
)) => let val  result = MlyValue.qid_p (fn _ => let val  (qid as qid1)
 = qid1 ()
 in ([qid strSymbol])
end)
 in ( LrTable.NT 55, ( result, qid1left, qid1right), rest671)
end
|  ( 173, ( ( _, ( MlyValue.qid_p qid_p1, _, qid_p1right)) :: ( _, ( 
MlyValue.qid qid1, qid1left, _)) :: rest671)) => let val  result = 
MlyValue.qid_p (fn _ => let val  (qid as qid1) = qid1 ()
 val  (qid_p as qid_p1) = qid_p1 ()
 in (qid strSymbol :: qid_p)
end)
 in ( LrTable.NT 55, ( result, qid1left, qid_p1right), rest671)
end
|  ( 174, ( ( _, ( _, INFIX1left, INFIX1right)) :: rest671)) => let
 val  result = MlyValue.fixity (fn _ => (infixleft 0))
 in ( LrTable.NT 56, ( result, INFIX1left, INFIX1right), rest671)
end
|  ( 175, ( ( _, ( MlyValue.int int1, intleft, (intright as int1right)
)) :: ( _, ( _, INFIX1left, _)) :: rest671)) => let val  result = 
MlyValue.fixity (fn _ => let val  (int as int1) = int1 ()
 in (infixleft (checkFix(#2 int, error(intleft, intright))))
end)
 in ( LrTable.NT 56, ( result, INFIX1left, int1right), rest671)
end
|  ( 176, ( ( _, ( _, INFIXR1left, INFIXR1right)) :: rest671)) => let
 val  result = MlyValue.fixity (fn _ => (infixright 0))
 in ( LrTable.NT 56, ( result, INFIXR1left, INFIXR1right), rest671)

end
|  ( 177, ( ( _, ( MlyValue.int int1, intleft, (intright as int1right)
)) :: ( _, ( _, INFIXR1left, _)) :: rest671)) => let val  result = 
MlyValue.fixity (fn _ => let val  (int as int1) = int1 ()
 in (infixright (checkFix(#2 int, error(intleft, intright))))
end)
 in ( LrTable.NT 56, ( result, INFIXR1left, int1right), rest671)
end
|  ( 178, ( ( _, ( _, NONFIX1left, NONFIX1right)) :: rest671)) => let
 val  result = MlyValue.fixity (fn _ => (NONfix))
 in ( LrTable.NT 56, ( result, NONFIX1left, NONFIX1right), rest671)

end
|  ( 179, ( ( _, ( MlyValue.vb vb1, _, vb1right)) :: ( _, ( _, 
VAL1left, _)) :: rest671)) => let val  result = MlyValue.ldec (fn _ =>
 let val  (vb as vb1) = vb1 ()
 in (ValDec(vb,nil))
end)
 in ( LrTable.NT 57, ( result, VAL1left, vb1right), rest671)
end
|  ( 180, ( ( _, ( MlyValue.vb vb1, _, vb1right)) :: ( _, ( 
MlyValue.tyvarseq tyvarseq1, _, _)) :: ( _, ( _, VAL1left, _)) :: 
rest671)) => let val  result = MlyValue.ldec (fn _ => let val  (
tyvarseq as tyvarseq1) = tyvarseq1 ()
 val  (vb as vb1) = vb1 ()
 in (ValDec(vb,tyvarseq))
end)
 in ( LrTable.NT 57, ( result, VAL1left, vb1right), rest671)
end
|  ( 181, ( ( _, ( MlyValue.rvb rvb1, _, rvb1right)) :: _ :: ( _, ( _,
 VAL1left, _)) :: rest671)) => let val  result = MlyValue.ldec (fn _
 => let val  (rvb as rvb1) = rvb1 ()
 in (ValrecDec(rvb,nil))
end)
 in ( LrTable.NT 57, ( result, VAL1left, rvb1right), rest671)
end
|  ( 182, ( ( _, ( MlyValue.rvb rvb1, _, rvb1right)) :: _ :: ( _, ( 
MlyValue.tyvarseq tyvarseq1, _, _)) :: ( _, ( _, VAL1left, _)) :: 
rest671)) => let val  result = MlyValue.ldec (fn _ => let val  (
tyvarseq as tyvarseq1) = tyvarseq1 ()
 val  (rvb as rvb1) = rvb1 ()
 in (ValrecDec(rvb,tyvarseq))
end)
 in ( LrTable.NT 57, ( result, VAL1left, rvb1right), rest671)
end
|  ( 183, ( ( _, ( MlyValue.fb fb1, _, fb1right)) :: ( _, ( _, 
FUN1left, _)) :: rest671)) => let val  result = MlyValue.ldec (fn _ =>
 let val  (fb as fb1) = fb1 ()
 in (FunDec(fb,nil))
end)
 in ( LrTable.NT 57, ( result, FUN1left, fb1right), rest671)
end
|  ( 184, ( ( _, ( MlyValue.fb fb1, _, fb1right)) :: ( _, ( 
MlyValue.tyvarseq tyvarseq1, _, _)) :: ( _, ( _, FUN1left, _)) :: 
rest671)) => let val  result = MlyValue.ldec (fn _ => let val  (
tyvarseq as tyvarseq1) = tyvarseq1 ()
 val  (fb as fb1) = fb1 ()
 in (FunDec(fb,tyvarseq))
end)
 in ( LrTable.NT 57, ( result, FUN1left, fb1right), rest671)
end
|  ( 185, ( ( _, ( MlyValue.tb tb1, _, tb1right)) :: ( _, ( _, 
TYPE1left, _)) :: rest671)) => let val  result = MlyValue.ldec (fn _
 => let val  (tb as tb1) = tb1 ()
 in (TypeDec tb)
end)
 in ( LrTable.NT 57, ( result, TYPE1left, tb1right), rest671)
end
|  ( 186, ( ( _, ( MlyValue.dtrepl dtrepl1, _, dtrepl1right)) :: ( _, 
( _, DATATYPE1left, _)) :: rest671)) => let val  result = 
MlyValue.ldec (fn _ => let val  (dtrepl as dtrepl1) = dtrepl1 ()
 in (DataReplDec dtrepl)
end)
 in ( LrTable.NT 57, ( result, DATATYPE1left, dtrepl1right), rest671)

end
|  ( 187, ( ( _, ( MlyValue.dbs dbs1, _, dbs1right)) :: ( _, ( _, 
DATATYPE1left, _)) :: rest671)) => let val  result = MlyValue.ldec (fn
 _ => let val  (dbs as dbs1) = dbs1 ()
 in (DatatypeDec{datatycs=dbs,withtycs=[]})
end)
 in ( LrTable.NT 57, ( result, DATATYPE1left, dbs1right), rest671)
end
|  ( 188, ( ( _, ( MlyValue.tb tb1, _, tb1right)) :: _ :: ( _, ( 
MlyValue.dbs dbs1, _, _)) :: ( _, ( _, DATATYPE1left, _)) :: rest671))
 => let val  result = MlyValue.ldec (fn _ => let val  (dbs as dbs1) = 
dbs1 ()
 val  (tb as tb1) = tb1 ()
 in (DatatypeDec{datatycs=dbs,withtycs=tb})
end)
 in ( LrTable.NT 57, ( result, DATATYPE1left, tb1right), rest671)
end
|  ( 189, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.ldecs ldecs1,
 _, _)) :: _ :: ( _, ( MlyValue.dbs dbs1, _, _)) :: ( _, ( _, 
ABSTYPE1left, _)) :: rest671)) => let val  result = MlyValue.ldec (fn
 _ => let val  (dbs as dbs1) = dbs1 ()
 val  (ldecs as ldecs1) = ldecs1 ()
 in (AbstypeDec{abstycs=dbs,withtycs=[],
						 body=ldecs})
end)
 in ( LrTable.NT 57, ( result, ABSTYPE1left, END1right), rest671)
end
|  ( 190, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.ldecs ldecs1,
 _, _)) :: _ :: ( _, ( MlyValue.tb tb1, _, _)) :: _ :: ( _, ( 
MlyValue.dbs dbs1, _, _)) :: ( _, ( _, ABSTYPE1left, _)) :: rest671))
 => let val  result = MlyValue.ldec (fn _ => let val  (dbs as dbs1) = 
dbs1 ()
 val  (tb as tb1) = tb1 ()
 val  (ldecs as ldecs1) = ldecs1 ()
 in (
AbstypeDec{abstycs=dbs,
							      withtycs=tb,
							      body=ldecs}
)
end)
 in ( LrTable.NT 57, ( result, ABSTYPE1left, END1right), rest671)
end
|  ( 191, ( ( _, ( MlyValue.eb eb1, _, eb1right)) :: ( _, ( _, 
EXCEPTION1left, _)) :: rest671)) => let val  result = MlyValue.ldec
 (fn _ => let val  (eb as eb1) = eb1 ()
 in (ExceptionDec eb)
end)
 in ( LrTable.NT 57, ( result, EXCEPTION1left, eb1right), rest671)
end
|  ( 192, ( ( _, ( MlyValue.qid_p qid_p1, _, qid_p1right)) :: ( _, ( _
, OPEN1left, _)) :: rest671)) => let val  result = MlyValue.ldec (fn _
 => let val  (qid_p as qid_p1) = qid_p1 ()
 in (OpenDec qid_p)
end)
 in ( LrTable.NT 57, ( result, OPEN1left, qid_p1right), rest671)
end
|  ( 193, ( ( _, ( MlyValue.ops ops1, _, ops1right)) :: ( _, ( 
MlyValue.fixity fixity1, fixity1left, _)) :: rest671)) => let val  
result = MlyValue.ldec (fn _ => let val  (fixity as fixity1) = fixity1
 ()
 val  (ops as ops1) = ops1 ()
 in (FixDec{fixity=fixity, ops=ops})
end)
 in ( LrTable.NT 57, ( result, fixity1left, ops1right), rest671)
end
|  ( 194, ( ( _, ( MlyValue.exp exp1, _, exp1right)) :: ( _, ( _, 
DO1left, _)) :: rest671)) => let val  result = MlyValue.ldec (fn _ =>
 let val  (exp as exp1) = exp1 ()
 in (DoDec exp)
end)
 in ( LrTable.NT 57, ( result, DO1left, exp1right), rest671)
end
|  ( 195, ( ( _, ( MlyValue.exp_pa exp_pa1, _, exp_pa1right)) :: _ :: 
( _, ( MlyValue.id id1, _, _)) :: ( _, ( _, OVERLOAD1left, _)) :: 
rest671)) => let val  result = MlyValue.ldec (fn _ => let val  (id as 
id1) = id1 ()
 val  (exp_pa as exp_pa1) = exp_pa1 ()
 in (OvldDec(varSymbol id, exp_pa))
end)
 in ( LrTable.NT 57, ( result, OVERLOAD1left, exp_pa1right), rest671)

end
|  ( 196, ( ( _, ( MlyValue.exp_pa exp_pa1, _, exp_pa1right)) :: _ :: 
( _, ( MlyValue.ty ty1, _, _)) :: _ :: ( _, ( MlyValue.id id1, _, _))
 :: ( _, ( _, OVERLOAD1left, _)) :: rest671)) => let val  result = 
MlyValue.ldec (fn _ => let val  (id as id1) = id1 ()
 val  ty1 = ty1 ()
 val  (exp_pa as exp_pa1) = exp_pa1 ()
 in (OvldDec(varSymbol id, exp_pa))
end)
 in ( LrTable.NT 57, ( result, OVERLOAD1left, exp_pa1right), rest671)

end
|  ( 197, ( ( _, ( MlyValue.exp exp1, exp1left, exp1right)) :: rest671
)) => let val  result = MlyValue.exp_pa (fn _ => let val  (exp as exp1
) = exp1 ()
 in ([exp])
end)
 in ( LrTable.NT 58, ( result, exp1left, exp1right), rest671)
end
|  ( 198, ( ( _, ( MlyValue.exp_pa exp_pa1, _, exp_pa1right)) :: _ :: 
( _, ( MlyValue.exp exp1, exp1left, _)) :: rest671)) => let val  
result = MlyValue.exp_pa (fn _ => let val  (exp as exp1) = exp1 ()
 val  (exp_pa as exp_pa1) = exp_pa1 ()
 in (exp :: exp_pa)
end)
 in ( LrTable.NT 58, ( result, exp1left, exp_pa1right), rest671)
end
|  ( 199, ( rest671)) => let val  result = MlyValue.ldecs (fn _ => (
SeqDec nil))
 in ( LrTable.NT 59, ( result, defaultPos, defaultPos), rest671)
end
|  ( 200, ( ( _, ( MlyValue.ldecs ldecs1, _, ldecs1right)) :: ( _, ( 
MlyValue.ldec ldec1, (ldecleft as ldec1left), ldecright)) :: rest671))
 => let val  result = MlyValue.ldecs (fn _ => let val  (ldec as ldec1)
 = ldec1 ()
 val  (ldecs as ldecs1) = ldecs1 ()
 in (makeSEQdec
				 (markdec(ldec,ldecleft,ldecright), ldecs))
end)
 in ( LrTable.NT 59, ( result, ldec1left, ldecs1right), rest671)
end
|  ( 201, ( ( _, ( MlyValue.ldecs ldecs1, _, ldecs1right)) :: ( _, ( _
, SEMICOLON1left, _)) :: rest671)) => let val  result = MlyValue.ldecs
 (fn _ => let val  (ldecs as ldecs1) = ldecs1 ()
 in (ldecs)
end)
 in ( LrTable.NT 59, ( result, SEMICOLON1left, ldecs1right), rest671)

end
|  ( 202, ( ( _, ( MlyValue.ldecs ldecs3, _, ldecs3right)) :: ( _, ( _
, _, ENDright)) :: ( _, ( MlyValue.ldecs ldecs2, ldecs2left, 
ldecs2right)) :: _ :: ( _, ( MlyValue.ldecs ldecs1, ldecs1left, 
ldecs1right)) :: ( _, ( _, (LOCALleft as LOCAL1left), _)) :: rest671))
 => let val  result = MlyValue.ldecs (fn _ => let val  ldecs1 = ldecs1
 ()
 val  ldecs2 = ldecs2 ()
 val  ldecs3 = ldecs3 ()
 in (
makeSEQdec
 		   (markdec(LocalDec(markdec(ldecs1,ldecs1left,ldecs1right),
				     markdec(ldecs2,ldecs2left,ldecs2right)),
			    LOCALleft,ENDright),
 	            ldecs3)
)
end)
 in ( LrTable.NT 59, ( result, LOCAL1left, ldecs3right), rest671)
end
|  ( 203, ( ( _, ( MlyValue.ident ident1, ident1left, ident1right)) ::
 rest671)) => let val  result = MlyValue.ops (fn _ => let val  (ident
 as ident1) = ident1 ()
 in ([fixSymbol ident])
end)
 in ( LrTable.NT 60, ( result, ident1left, ident1right), rest671)
end
|  ( 204, ( ( _, ( MlyValue.ops ops1, _, ops1right)) :: ( _, ( 
MlyValue.ident ident1, ident1left, _)) :: rest671)) => let val  result
 = MlyValue.ops (fn _ => let val  (ident as ident1) = ident1 ()
 val  (ops as ops1) = ops1 ()
 in (fixSymbol ident :: ops)
end)
 in ( LrTable.NT 60, ( result, ident1left, ops1right), rest671)
end
|  ( 205, ( rest671)) => let val  result = MlyValue.spec_s (fn _ => (
[]))
 in ( LrTable.NT 61, ( result, defaultPos, defaultPos), rest671)
end
|  ( 206, ( ( _, ( MlyValue.spec_s spec_s1, _, spec_s1right)) :: ( _, 
( MlyValue.spec spec1, spec1left, _)) :: rest671)) => let val  result
 = MlyValue.spec_s (fn _ => let val  (spec as spec1) = spec1 ()
 val  (spec_s as spec_s1) = spec_s1 ()
 in (spec @ spec_s)
end)
 in ( LrTable.NT 61, ( result, spec1left, spec_s1right), rest671)
end
|  ( 207, ( ( _, ( MlyValue.spec_s spec_s1, _, spec_s1right)) :: ( _, 
( _, SEMICOLON1left, _)) :: rest671)) => let val  result = 
MlyValue.spec_s (fn _ => let val  (spec_s as spec_s1) = spec_s1 ()
 in (spec_s)
end)
 in ( LrTable.NT 61, ( result, SEMICOLON1left, spec_s1right), rest671)

end
|  ( 208, ( ( _, ( MlyValue.strspec strspec1, _, strspec1right)) :: (
 _, ( _, STRUCTURE1left, _)) :: rest671)) => let val  result = 
MlyValue.spec (fn _ => let val  (strspec as strspec1) = strspec1 ()
 in ([StrSpec strspec])
end)
 in ( LrTable.NT 62, ( result, STRUCTURE1left, strspec1right), rest671
)
end
|  ( 209, ( ( _, ( MlyValue.fctspec fctspec1, _, fctspec1right)) :: (
 _, ( _, FUNCTOR1left, _)) :: rest671)) => let val  result = 
MlyValue.spec (fn _ => let val  (fctspec as fctspec1) = fctspec1 ()
 in ([FctSpec fctspec])
end)
 in ( LrTable.NT 62, ( result, FUNCTOR1left, fctspec1right), rest671)

end
|  ( 210, ( ( _, ( MlyValue.dtrepl dtrepl1, _, dtrepl1right)) :: ( _, 
( _, DATATYPE1left, _)) :: rest671)) => let val  result = 
MlyValue.spec (fn _ => let val  (dtrepl as dtrepl1) = dtrepl1 ()
 in ([DataReplSpec dtrepl])
end)
 in ( LrTable.NT 62, ( result, DATATYPE1left, dtrepl1right), rest671)

end
|  ( 211, ( ( _, ( MlyValue.dbs dbs1, _, dbs1right)) :: ( _, ( _, 
DATATYPE1left, _)) :: rest671)) => let val  result = MlyValue.spec (fn
 _ => let val  (dbs as dbs1) = dbs1 ()
 in ([DataSpec{datatycs=dbs,withtycs=nil}])
end)
 in ( LrTable.NT 62, ( result, DATATYPE1left, dbs1right), rest671)
end
|  ( 212, ( ( _, ( MlyValue.tb tb1, _, tb1right)) :: _ :: ( _, ( 
MlyValue.dbs dbs1, _, _)) :: ( _, ( _, DATATYPE1left, _)) :: rest671))
 => let val  result = MlyValue.spec (fn _ => let val  (dbs as dbs1) = 
dbs1 ()
 val  (tb as tb1) = tb1 ()
 in ([DataSpec{datatycs=dbs,withtycs=tb}])
end)
 in ( LrTable.NT 62, ( result, DATATYPE1left, tb1right), rest671)
end
|  ( 213, ( ( _, ( MlyValue.tyspec tyspec1, _, tyspec1right)) :: ( _, 
( _, TYPE1left, _)) :: rest671)) => let val  result = MlyValue.spec
 (fn _ => let val  (tyspec as tyspec1) = tyspec1 ()
 in ([TycSpec(tyspec,false)])
end)
 in ( LrTable.NT 62, ( result, TYPE1left, tyspec1right), rest671)
end
|  ( 214, ( ( _, ( MlyValue.tyspec tyspec1, _, tyspec1right)) :: ( _, 
( _, EQTYPE1left, _)) :: rest671)) => let val  result = MlyValue.spec
 (fn _ => let val  (tyspec as tyspec1) = tyspec1 ()
 in ([TycSpec(tyspec,true)])
end)
 in ( LrTable.NT 62, ( result, EQTYPE1left, tyspec1right), rest671)

end
|  ( 215, ( ( _, ( MlyValue.valspec valspec1, _, valspec1right)) :: (
 _, ( _, VAL1left, _)) :: rest671)) => let val  result = MlyValue.spec
 (fn _ => let val  (valspec as valspec1) = valspec1 ()
 in ([ValSpec valspec])
end)
 in ( LrTable.NT 62, ( result, VAL1left, valspec1right), rest671)
end
|  ( 216, ( ( _, ( MlyValue.exnspec exnspec1, _, exnspec1right)) :: (
 _, ( _, EXCEPTION1left, _)) :: rest671)) => let val  result = 
MlyValue.spec (fn _ => let val  (exnspec as exnspec1) = exnspec1 ()
 in ([ExceSpec exnspec])
end)
 in ( LrTable.NT 62, ( result, EXCEPTION1left, exnspec1right), rest671
)
end
|  ( 217, ( ( _, ( MlyValue.sharespec sharespec1, _, sharespec1right))
 :: ( _, ( _, SHARING1left, _)) :: rest671)) => let val  result = 
MlyValue.spec (fn _ => let val  (sharespec as sharespec1) = sharespec1
 ()
 in (sharespec)
end)
 in ( LrTable.NT 62, ( result, SHARING1left, sharespec1right), rest671
)
end
|  ( 218, ( ( _, ( MlyValue.sign sign1, _, sign1right)) :: ( _, ( _, 
INCLUDE1left, _)) :: rest671)) => let val  result = MlyValue.spec (fn
 _ => let val  (sign as sign1) = sign1 ()
 in ([IncludeSpec sign])
end)
 in ( LrTable.NT 62, ( result, INCLUDE1left, sign1right), rest671)
end
|  ( 219, ( ( _, ( MlyValue.idents idents1, _, idents1right)) :: ( _, 
( MlyValue.IDA IDA1, _, _)) :: ( _, ( _, INCLUDE1left, _)) :: rest671)
) => let val  result = MlyValue.spec (fn _ => let val  (IDA as IDA1) =
 IDA1 ()
 val  (idents as idents1) = idents1 ()
 in (IncludeSpec(VarSig(FastSymbol.sigSymbol IDA)) :: idents)
end)
 in ( LrTable.NT 62, ( result, INCLUDE1left, idents1right), rest671)

end
|  ( 220, ( ( _, ( MlyValue.IDA IDA1, IDA1left, IDA1right)) :: rest671
)) => let val  result = MlyValue.idents (fn _ => let val  (IDA as IDA1
) = IDA1 ()
 in ([IncludeSpec(VarSig(FastSymbol.sigSymbol IDA))])
end)
 in ( LrTable.NT 63, ( result, IDA1left, IDA1right), rest671)
end
|  ( 221, ( ( _, ( MlyValue.idents idents1, _, idents1right)) :: ( _, 
( MlyValue.IDA IDA1, IDA1left, _)) :: rest671)) => let val  result = 
MlyValue.idents (fn _ => let val  (IDA as IDA1) = IDA1 ()
 val  (idents as idents1) = idents1 ()
 in (IncludeSpec(VarSig(FastSymbol.sigSymbol IDA)) :: idents)
end)
 in ( LrTable.NT 63, ( result, IDA1left, idents1right), rest671)
end
|  ( 222, ( ( _, ( MlyValue.strspec strspec2, _, strspec2right)) :: _
 :: ( _, ( MlyValue.strspec strspec1, strspec1left, _)) :: rest671))
 => let val  result = MlyValue.strspec (fn _ => let val  strspec1 = 
strspec1 ()
 val  strspec2 = strspec2 ()
 in (strspec1 @ strspec2)
end)
 in ( LrTable.NT 64, ( result, strspec1left, strspec2right), rest671)

end
|  ( 223, ( ( _, ( MlyValue.sign sign1, _, sign1right)) :: _ :: ( _, (
 MlyValue.IDA IDA1, IDA1left, _)) :: rest671)) => let val  result = 
MlyValue.strspec (fn _ => let val  (IDA as IDA1) = IDA1 ()
 val  (sign as sign1) = sign1 ()
 in ([(strSymbol IDA, sign, NONE)])
end)
 in ( LrTable.NT 64, ( result, IDA1left, sign1right), rest671)
end
|  ( 224, ( ( _, ( MlyValue.qid qid1, _, qid1right)) :: _ :: ( _, ( 
MlyValue.sign sign1, _, _)) :: _ :: ( _, ( MlyValue.IDA IDA1, IDA1left
, _)) :: rest671)) => let val  result = MlyValue.strspec (fn _ => let
 val  (IDA as IDA1) = IDA1 ()
 val  (sign as sign1) = sign1 ()
 val  (qid as qid1) = qid1 ()
 in ([(strSymbol IDA, sign, SOME(qid strSymbol))])
end)
 in ( LrTable.NT 64, ( result, IDA1left, qid1right), rest671)
end
|  ( 225, ( ( _, ( MlyValue.fctspec fctspec2, _, fctspec2right)) :: _
 :: ( _, ( MlyValue.fctspec fctspec1, fctspec1left, _)) :: rest671))
 => let val  result = MlyValue.fctspec (fn _ => let val  fctspec1 = 
fctspec1 ()
 val  fctspec2 = fctspec2 ()
 in (fctspec1 @ fctspec2)
end)
 in ( LrTable.NT 65, ( result, fctspec1left, fctspec2right), rest671)

end
|  ( 226, ( ( _, ( MlyValue.fsig fsig1, _, fsig1right)) :: ( _, ( 
MlyValue.IDA IDA1, IDA1left, _)) :: rest671)) => let val  result = 
MlyValue.fctspec (fn _ => let val  (IDA as IDA1) = IDA1 ()
 val  (fsig as fsig1) = fsig1 ()
 in ([(fctSymbol IDA, fsig)])
end)
 in ( LrTable.NT 65, ( result, IDA1left, fsig1right), rest671)
end
|  ( 227, ( ( _, ( MlyValue.tyspec tyspec2, _, tyspec2right)) :: _ :: 
( _, ( MlyValue.tyspec tyspec1, tyspec1left, _)) :: rest671)) => let
 val  result = MlyValue.tyspec (fn _ => let val  tyspec1 = tyspec1 ()
 val  tyspec2 = tyspec2 ()
 in (tyspec1 @ tyspec2)
end)
 in ( LrTable.NT 66, ( result, tyspec1left, tyspec2right), rest671)

end
|  ( 228, ( ( _, ( MlyValue.idtyc idtyc1, _, idtyc1right)) :: ( _, ( 
MlyValue.tyvars tyvars1, tyvars1left, _)) :: rest671)) => let val  
result = MlyValue.tyspec (fn _ => let val  (tyvars as tyvars1) = 
tyvars1 ()
 val  (idtyc as idtyc1) = idtyc1 ()
 in ([(tycSymbol idtyc,tyvars,NONE)])
end)
 in ( LrTable.NT 66, ( result, tyvars1left, idtyc1right), rest671)
end
|  ( 229, ( ( _, ( MlyValue.ty ty1, _, ty1right)) :: _ :: ( _, ( 
MlyValue.idtyc idtyc1, _, _)) :: ( _, ( MlyValue.tyvars tyvars1, 
tyvars1left, _)) :: rest671)) => let val  result = MlyValue.tyspec (fn
 _ => let val  (tyvars as tyvars1) = tyvars1 ()
 val  (idtyc as idtyc1) = idtyc1 ()
 val  (ty as ty1) = ty1 ()
 in ([(tycSymbol idtyc,tyvars,SOME ty)])
end)
 in ( LrTable.NT 66, ( result, tyvars1left, ty1right), rest671)
end
|  ( 230, ( ( _, ( MlyValue.valspec valspec2, _, valspec2right)) :: _
 :: ( _, ( MlyValue.valspec valspec1, valspec1left, _)) :: rest671))
 => let val  result = MlyValue.valspec (fn _ => let val  valspec1 = 
valspec1 ()
 val  valspec2 = valspec2 ()
 in (valspec1 @ valspec2)
end)
 in ( LrTable.NT 67, ( result, valspec1left, valspec2right), rest671)

end
|  ( 231, ( ( _, ( MlyValue.ty ty1, _, ty1right)) :: _ :: ( _, ( 
MlyValue.ident ident1, _, _)) :: ( _, ( MlyValue.op_op op_op1, 
op_op1left, _)) :: rest671)) => let val  result = MlyValue.valspec (fn
 _ => let val  op_op1 = op_op1 ()
 val  (ident as ident1) = ident1 ()
 val  (ty as ty1) = ty1 ()
 in ([(varSymbol ident,ty)])
end)
 in ( LrTable.NT 67, ( result, op_op1left, ty1right), rest671)
end
|  ( 232, ( ( _, ( MlyValue.exnspec exnspec2, _, exnspec2right)) :: _
 :: ( _, ( MlyValue.exnspec exnspec1, exnspec1left, _)) :: rest671))
 => let val  result = MlyValue.exnspec (fn _ => let val  exnspec1 = 
exnspec1 ()
 val  exnspec2 = exnspec2 ()
 in (exnspec1 @ exnspec2)
end)
 in ( LrTable.NT 68, ( result, exnspec1left, exnspec2right), rest671)

end
|  ( 233, ( ( _, ( MlyValue.id id1, id1left, id1right)) :: rest671))
 => let val  result = MlyValue.exnspec (fn _ => let val  (id as id1) =
 id1 ()
 in ([(varSymbol id,NONE)])
end)
 in ( LrTable.NT 68, ( result, id1left, id1right), rest671)
end
|  ( 234, ( ( _, ( MlyValue.ty ty1, _, ty1right)) :: _ :: ( _, ( 
MlyValue.id id1, id1left, _)) :: rest671)) => let val  result = 
MlyValue.exnspec (fn _ => let val  (id as id1) = id1 ()
 val  (ty as ty1) = ty1 ()
 in ([(varSymbol id,SOME ty)])
end)
 in ( LrTable.NT 68, ( result, id1left, ty1right), rest671)
end
|  ( 235, ( ( _, ( MlyValue.sharespec sharespec2, _, sharespec2right))
 :: _ :: ( _, ( MlyValue.sharespec sharespec1, sharespec1left, _)) :: 
rest671)) => let val  result = MlyValue.sharespec (fn _ => let val  
sharespec1 = sharespec1 ()
 val  sharespec2 = sharespec2 ()
 in (sharespec1 @ sharespec2)
end)
 in ( LrTable.NT 69, ( result, sharespec1left, sharespec2right), 
rest671)
end
|  ( 236, ( ( _, ( MlyValue.patheqn patheqn1, patheqnleft, (
patheqnright as patheqn1right))) :: ( _, ( _, TYPE1left, _)) :: 
rest671)) => let val  result = MlyValue.sharespec (fn _ => let val  (
patheqn as patheqn1) = patheqn1 ()
 in (
[MarkSpec (ShareTycSpec(patheqn tycSymbol),
				    (patheqnleft,patheqnright))]
)
end)
 in ( LrTable.NT 69, ( result, TYPE1left, patheqn1right), rest671)
end
|  ( 237, ( ( _, ( MlyValue.patheqn patheqn1, (patheqnleft as 
patheqn1left), (patheqnright as patheqn1right))) :: rest671)) => let
 val  result = MlyValue.sharespec (fn _ => let val  (patheqn as 
patheqn1) = patheqn1 ()
 in (
[MarkSpec (ShareStrSpec (patheqn strSymbol),
				    (patheqnleft,patheqnright))]
)
end)
 in ( LrTable.NT 69, ( result, patheqn1left, patheqn1right), rest671)

end
|  ( 238, ( ( _, ( MlyValue.qid qid2, _, qid2right)) :: _ :: ( _, ( 
MlyValue.qid qid1, qid1left, _)) :: rest671)) => let val  result = 
MlyValue.patheqn (fn _ => let val  qid1 = qid1 ()
 val  qid2 = qid2 ()
 in (fn kind => [qid1 kind, qid2 kind])
end)
 in ( LrTable.NT 70, ( result, qid1left, qid2right), rest671)
end
|  ( 239, ( ( _, ( MlyValue.patheqn patheqn1, _, patheqn1right)) :: _
 :: ( _, ( MlyValue.qid qid1, qid1left, _)) :: rest671)) => let val  
result = MlyValue.patheqn (fn _ => let val  (qid as qid1) = qid1 ()
 val  (patheqn as patheqn1) = patheqn1 ()
 in (fn kind => qid kind :: patheqn kind)
end)
 in ( LrTable.NT 70, ( result, qid1left, patheqn1right), rest671)
end
|  ( 240, ( ( _, ( MlyValue.whspec whspec2, _, whspec2right)) :: _ :: 
( _, ( MlyValue.whspec whspec1, whspec1left, _)) :: rest671)) => let
 val  result = MlyValue.whspec (fn _ => let val  whspec1 = whspec1 ()
 val  whspec2 = whspec2 ()
 in (whspec1 @ whspec2)
end)
 in ( LrTable.NT 71, ( result, whspec1left, whspec2right), rest671)

end
|  ( 241, ( ( _, ( MlyValue.ty ty1, _, ty1right)) :: _ :: ( _, ( 
MlyValue.qid qid1, _, _)) :: ( _, ( MlyValue.tyvars tyvars1, _, _)) ::
 ( _, ( _, TYPE1left, _)) :: rest671)) => let val  result = 
MlyValue.whspec (fn _ => let val  (tyvars as tyvars1) = tyvars1 ()
 val  (qid as qid1) = qid1 ()
 val  (ty as ty1) = ty1 ()
 in ([WhType(qid tycSymbol,tyvars,ty)])
end)
 in ( LrTable.NT 71, ( result, TYPE1left, ty1right), rest671)
end
|  ( 242, ( ( _, ( MlyValue.qid qid2, _, qid2right)) :: _ :: ( _, ( 
MlyValue.qid qid1, qid1left, _)) :: rest671)) => let val  result = 
MlyValue.whspec (fn _ => let val  qid1 = qid1 ()
 val  qid2 = qid2 ()
 in ([WhStruct(qid1 strSymbol,qid2 strSymbol)])
end)
 in ( LrTable.NT 71, ( result, qid1left, qid2right), rest671)
end
|  ( 243, ( ( _, ( MlyValue.IDA IDA1, (IDAleft as IDA1left), (IDAright
 as IDA1right))) :: rest671)) => let val  result = MlyValue.sign (fn _
 => let val  (IDA as IDA1) = IDA1 ()
 in (MarkSig(VarSig (sigSymbol IDA),
				         (IDAleft,IDAright)))

end)
 in ( LrTable.NT 72, ( result, IDA1left, IDA1right), rest671)
end
|  ( 244, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.spec_s spec_s1
, spec_sleft, spec_sright)) :: ( _, ( _, SIG1left, _)) :: rest671)) =>
 let val  result = MlyValue.sign (fn _ => let val  (spec_s as spec_s1)
 = spec_s1 ()
 in (MarkSig(BaseSig(spec_s),(spec_sleft,spec_sright)))
end)
 in ( LrTable.NT 72, ( result, SIG1left, END1right), rest671)
end
|  ( 245, ( ( _, ( MlyValue.whspec whspec1, _, (whspecright as 
whspec1right))) :: _ :: ( _, ( MlyValue.sign sign1, (signleft as 
sign1left), _)) :: rest671)) => let val  result = MlyValue.sign (fn _
 => let val  (sign as sign1) = sign1 ()
 val  (whspec as whspec1) = whspec1 ()
 in (MarkSig(AugSig(sign,whspec),(signleft,whspecright)))
end)
 in ( LrTable.NT 72, ( result, sign1left, whspec1right), rest671)
end
|  ( 246, ( rest671)) => let val  result = MlyValue.sigconstraint_op
 (fn _ => (NoSig))
 in ( LrTable.NT 73, ( result, defaultPos, defaultPos), rest671)
end
|  ( 247, ( ( _, ( MlyValue.sign sign1, _, sign1right)) :: ( _, ( _, 
COLON1left, _)) :: rest671)) => let val  result = 
MlyValue.sigconstraint_op (fn _ => let val  (sign as sign1) = sign1 ()
 in (Transparent(sign))
end)
 in ( LrTable.NT 73, ( result, COLON1left, sign1right), rest671)
end
|  ( 248, ( ( _, ( MlyValue.sign sign1, _, sign1right)) :: ( _, ( _, 
COLONGT1left, _)) :: rest671)) => let val  result = 
MlyValue.sigconstraint_op (fn _ => let val  (sign as sign1) = sign1 ()
 in (Opaque(sign))
end)
 in ( LrTable.NT 73, ( result, COLONGT1left, sign1right), rest671)
end
|  ( 249, ( rest671)) => let val  result = MlyValue.fsigconstraint_op
 (fn _ => (NoSig))
 in ( LrTable.NT 74, ( result, defaultPos, defaultPos), rest671)
end
|  ( 250, ( ( _, ( MlyValue.IDA IDA1, _, IDA1right)) :: ( _, ( _, 
COLON1left, _)) :: rest671)) => let val  result = 
MlyValue.fsigconstraint_op (fn _ => let val  (IDA as IDA1) = IDA1 ()
 in (Transparent(VarFsig (fsigSymbol IDA)))
end)
 in ( LrTable.NT 74, ( result, COLON1left, IDA1right), rest671)
end
|  ( 251, ( ( _, ( MlyValue.IDA IDA1, _, IDA1right)) :: ( _, ( _, 
COLONGT1left, _)) :: rest671)) => let val  result = 
MlyValue.fsigconstraint_op (fn _ => let val  (IDA as IDA1) = IDA1 ()
 in (Opaque(VarFsig (fsigSymbol IDA)))
end)
 in ( LrTable.NT 74, ( result, COLONGT1left, IDA1right), rest671)
end
|  ( 252, ( ( _, ( MlyValue.sigb sigb2, _, sigb2right)) :: _ :: ( _, (
 MlyValue.sigb sigb1, sigb1left, _)) :: rest671)) => let val  result =
 MlyValue.sigb (fn _ => let val  sigb1 = sigb1 ()
 val  sigb2 = sigb2 ()
 in (sigb1 @ sigb2)
end)
 in ( LrTable.NT 75, ( result, sigb1left, sigb2right), rest671)
end
|  ( 253, ( ( _, ( MlyValue.sign sign1, _, sign1right)) :: _ :: ( _, (
 MlyValue.IDA IDA1, IDA1left, _)) :: rest671)) => let val  result = 
MlyValue.sigb (fn _ => let val  (IDA as IDA1) = IDA1 ()
 val  (sign as sign1) = sign1 ()
 in ([Sigb{name=sigSymbol IDA, def=sign}])
end)
 in ( LrTable.NT 75, ( result, IDA1left, sign1right), rest671)
end
|  ( 254, ( ( _, ( MlyValue.fsigb fsigb2, _, fsigb2right)) :: _ :: ( _
, ( MlyValue.fsigb fsigb1, fsigb1left, _)) :: rest671)) => let val  
result = MlyValue.fsigb (fn _ => let val  fsigb1 = fsigb1 ()
 val  fsigb2 = fsigb2 ()
 in (fsigb1 @ fsigb2)
end)
 in ( LrTable.NT 76, ( result, fsigb1left, fsigb2right), rest671)
end
|  ( 255, ( ( _, ( MlyValue.sign sign1, _, sign1right)) :: _ :: ( _, (
 MlyValue.fparamList fparamList1, _, _)) :: ( _, ( MlyValue.IDA IDA1, 
IDA1left, _)) :: rest671)) => let val  result = MlyValue.fsigb (fn _
 => let val  (IDA as IDA1) = IDA1 ()
 val  (fparamList as fparamList1) = fparamList1 ()
 val  (sign as sign1) = sign1 ()
 in (
[Fsigb{name=fsigSymbol IDA,
			def=BaseFsig{param=fparamList,result=sign}}]
)
end)
 in ( LrTable.NT 76, ( result, IDA1left, sign1right), rest671)
end
|  ( 256, ( ( _, ( MlyValue.IDA IDA1, _, IDA1right)) :: ( _, ( _, 
COLON1left, _)) :: rest671)) => let val  result = MlyValue.fsig (fn _
 => let val  (IDA as IDA1) = IDA1 ()
 in (VarFsig (fsigSymbol IDA))
end)
 in ( LrTable.NT 77, ( result, COLON1left, IDA1right), rest671)
end
|  ( 257, ( ( _, ( MlyValue.sign sign1, _, sign1right)) :: _ :: ( _, (
 MlyValue.fparamList fparamList1, fparamList1left, _)) :: rest671)) =>
 let val  result = MlyValue.fsig (fn _ => let val  (fparamList as 
fparamList1) = fparamList1 ()
 val  (sign as sign1) = sign1 ()
 in (BaseFsig{param=fparamList,result=sign})
end)
 in ( LrTable.NT 77, ( result, fparamList1left, sign1right), rest671)

end
|  ( 258, ( ( _, ( MlyValue.qid qid1, (qidleft as qid1left), (qidright
 as qid1right))) :: rest671)) => let val  result = MlyValue.str (fn _
 => let val  (qid as qid1) = qid1 ()
 in ((MarkStr(VarStr(qid strSymbol),(qidleft,qidright))))
end)
 in ( LrTable.NT 78, ( result, qid1left, qid1right), rest671)
end
|  ( 259, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.strdecs strdecs1, _, _)) :: ( _, ( _, (STRUCTleft as 
STRUCT1left), _)) :: rest671)) => let val  result = MlyValue.str (fn _
 => let val  (strdecs as strdecs1) = strdecs1 ()
 in (MarkStr(BaseStr strdecs,(STRUCTleft,ENDright)))
end)
 in ( LrTable.NT 78, ( result, STRUCT1left, END1right), rest671)
end
|  ( 260, ( ( _, ( MlyValue.arg_fct arg_fct1, _, (arg_fctright as 
arg_fct1right))) :: ( _, ( MlyValue.qid qid1, (qidleft as qid1left), _
)) :: rest671)) => let val  result = MlyValue.str (fn _ => let val  (
qid as qid1) = qid1 ()
 val  (arg_fct as arg_fct1) = arg_fct1 ()
 in (
MarkStr(AppStr(qid fctSymbol,arg_fct),
			 (qidleft,arg_fctright)))

end)
 in ( LrTable.NT 78, ( result, qid1left, arg_fct1right), rest671)
end
|  ( 261, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.str str1, _, _)) :: _ :: ( _, ( MlyValue.strdecs strdecs1, _,
 _)) :: ( _, ( _, (LETleft as LET1left), _)) :: rest671)) => let val  
result = MlyValue.str (fn _ => let val  (strdecs as strdecs1) = 
strdecs1 ()
 val  (str as str1) = str1 ()
 in (MarkStr(LetStr(strdecs, str), (LETleft,ENDright)))
end)
 in ( LrTable.NT 78, ( result, LET1left, END1right), rest671)
end
|  ( 262, ( ( _, ( MlyValue.sign sign1, _, (signright as sign1right)))
 :: _ :: ( _, ( MlyValue.str str1, (strleft as str1left), _)) :: 
rest671)) => let val  result = MlyValue.str (fn _ => let val  (str as 
str1) = str1 ()
 val  (sign as sign1) = sign1 ()
 in (
MarkStr(ConstrainedStr(str,Transparent sign),
		         (strleft,signright))
)
end)
 in ( LrTable.NT 78, ( result, str1left, sign1right), rest671)
end
|  ( 263, ( ( _, ( MlyValue.sign sign1, _, (signright as sign1right)))
 :: _ :: ( _, ( MlyValue.str str1, (strleft as str1left), _)) :: 
rest671)) => let val  result = MlyValue.str (fn _ => let val  (str as 
str1) = str1 ()
 val  (sign as sign1) = sign1 ()
 in (
MarkStr(ConstrainedStr(str,Opaque sign),
		         (strleft,signright))
)
end)
 in ( LrTable.NT 78, ( result, str1left, sign1right), rest671)
end
|  ( 264, ( ( _, ( MlyValue.arg_fct arg_fct1, _, arg_fct1right)) :: _
 :: ( _, ( MlyValue.strdecs strdecs1, strdecsleft, strdecsright)) :: (
 _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.arg_fct (fn _ => let val  (strdecs as strdecs1) = strdecs1 ()
 val  (arg_fct as arg_fct1) = arg_fct1 ()
 in (
(MarkStr(BaseStr strdecs,
						  (strdecsleft,strdecsright)),
					  false) :: arg_fct
)
end)
 in ( LrTable.NT 79, ( result, LPAREN1left, arg_fct1right), rest671)

end
|  ( 265, ( ( _, ( MlyValue.arg_fct arg_fct1, _, arg_fct1right)) :: _
 :: ( _, ( MlyValue.str str1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.arg_fct (fn _ => let val  (str
 as str1) = str1 ()
 val  (arg_fct as arg_fct1) = arg_fct1 ()
 in ((str, true) :: arg_fct)
end)
 in ( LrTable.NT 79, ( result, LPAREN1left, arg_fct1right), rest671)

end
|  ( 266, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.str str1, _
, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.arg_fct (fn _ => let val  (str as str1) = str1 ()
 in ([(str, true)])
end)
 in ( LrTable.NT 79, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 267, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.strdecs 
strdecs1, strdecsleft, strdecsright)) :: ( _, ( _, LPAREN1left, _)) ::
 rest671)) => let val  result = MlyValue.arg_fct (fn _ => let val  (
strdecs as strdecs1) = strdecs1 ()
 in (
[(MarkStr(BaseStr strdecs,
						   (strdecsleft,strdecsright)),
					   false)]
)
end)
 in ( LrTable.NT 79, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 268, ( ( _, ( MlyValue.strdecs strdecs1, _, strdecs1right)) :: (
 _, ( MlyValue.strdec strdec1, (strdecleft as strdec1left), 
strdecright)) :: rest671)) => let val  result = MlyValue.strdecs (fn _
 => let val  (strdec as strdec1) = strdec1 ()
 val  (strdecs as strdecs1) = strdecs1 ()
 in (
makeSEQdec (markdec(strdec,strdecleft,strdecright),
					     strdecs)
)
end)
 in ( LrTable.NT 81, ( result, strdec1left, strdecs1right), rest671)

end
|  ( 269, ( ( _, ( MlyValue.strdecs strdecs1, _, strdecs1right)) :: (
 _, ( _, SEMICOLON1left, _)) :: rest671)) => let val  result = 
MlyValue.strdecs (fn _ => let val  (strdecs as strdecs1) = strdecs1 ()
 in (strdecs)
end)
 in ( LrTable.NT 81, ( result, SEMICOLON1left, strdecs1right), rest671
)
end
|  ( 270, ( rest671)) => let val  result = MlyValue.strdecs (fn _ => (
SeqDec[]))
 in ( LrTable.NT 81, ( result, defaultPos, defaultPos), rest671)
end
|  ( 271, ( ( _, ( MlyValue.sdecs sdecs1, _, sdecs1right)) :: ( _, ( 
MlyValue.sdec sdec1, (sdecleft as sdec1left), sdecright)) :: rest671))
 => let val  result = MlyValue.sdecs (fn _ => let val  (sdec as sdec1)
 = sdec1 ()
 val  (sdecs as sdecs1) = sdecs1 ()
 in (makeSEQdec (markdec(sdec,sdecleft,sdecright),
					     sdecs))

end)
 in ( LrTable.NT 83, ( result, sdec1left, sdecs1right), rest671)
end
|  ( 272, ( ( _, ( MlyValue.sdecs sdecs1, _, sdecs1right)) :: ( _, ( _
, SEMICOLON1left, _)) :: rest671)) => let val  result = MlyValue.sdecs
 (fn _ => let val  (sdecs as sdecs1) = sdecs1 ()
 in (sdecs)
end)
 in ( LrTable.NT 83, ( result, SEMICOLON1left, sdecs1right), rest671)

end
|  ( 273, ( rest671)) => let val  result = MlyValue.sdecs (fn _ => (
SeqDec[]))
 in ( LrTable.NT 83, ( result, defaultPos, defaultPos), rest671)
end
|  ( 274, ( ( _, ( MlyValue.sdecs' sdecs'1, _, sdecs'1right)) :: ( _, 
( MlyValue.sdec sdec1, (sdecleft as sdec1left), sdecright)) :: rest671
)) => let val  result = MlyValue.sdecs' (fn _ => let val  (sdec as 
sdec1) = sdec1 ()
 val  (sdecs' as sdecs'1) = sdecs'1 ()
 in (makeSEQdec (markdec(sdec,sdecleft,sdecright),
					     sdecs'))

end)
 in ( LrTable.NT 84, ( result, sdec1left, sdecs'1right), rest671)
end
|  ( 275, ( ( _, ( MlyValue.sdec sdec1, (sdecleft as sdec1left), (
sdecright as sdec1right))) :: rest671)) => let val  result = 
MlyValue.sdecs' (fn _ => let val  (sdec as sdec1) = sdec1 ()
 in (markdec(sdec, sdecleft,sdecright))
end)
 in ( LrTable.NT 84, ( result, sdec1left, sdec1right), rest671)
end
|  ( 276, ( ( _, ( MlyValue.strb strb1, _, strb1right)) :: ( _, ( _, 
STRUCTURE1left, _)) :: rest671)) => let val  result = MlyValue.strdec
 (fn _ => let val  (strb as strb1) = strb1 ()
 in (StrDec strb)
end)
 in ( LrTable.NT 80, ( result, STRUCTURE1left, strb1right), rest671)

end
|  ( 277, ( ( _, ( MlyValue.fctb fctb1, _, fctb1right)) :: ( _, ( _, 
FUNCTOR1left, _)) :: rest671)) => let val  result = MlyValue.strdec
 (fn _ => let val  (fctb as fctb1) = fctb1 ()
 in (FctDec fctb)
end)
 in ( LrTable.NT 80, ( result, FUNCTOR1left, fctb1right), rest671)
end
|  ( 278, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.strdecs 
strdecs2, strdecs2left, strdecs2right)) :: _ :: ( _, ( 
MlyValue.strdecs strdecs1, strdecs1left, strdecs1right)) :: ( _, ( _, 
LOCAL1left, _)) :: rest671)) => let val  result = MlyValue.strdec (fn
 _ => let val  strdecs1 = strdecs1 ()
 val  strdecs2 = strdecs2 ()
 in (
LocalDec(markdec(strdecs1,
				     strdecs1left,strdecs1right),
  			       markdec(strdecs2,strdecs2left,strdecs2right))
)
end)
 in ( LrTable.NT 80, ( result, LOCAL1left, END1right), rest671)
end
|  ( 279, ( ( _, ( MlyValue.ldec ldec1, (ldecleft as ldec1left), (
ldecright as ldec1right))) :: rest671)) => let val  result = 
MlyValue.strdec (fn _ => let val  (ldec as ldec1) = ldec1 ()
 in (markdec(ldec,ldecleft,ldecright))
end)
 in ( LrTable.NT 80, ( result, ldec1left, ldec1right), rest671)
end
|  ( 280, ( ( _, ( MlyValue.strb strb1, _, strb1right)) :: ( _, ( _, 
STRUCTURE1left, _)) :: rest671)) => let val  result = MlyValue.sdec
 (fn _ => let val  (strb as strb1) = strb1 ()
 in (StrDec strb)
end)
 in ( LrTable.NT 82, ( result, STRUCTURE1left, strb1right), rest671)

end
|  ( 281, ( ( _, ( MlyValue.sigb sigb1, _, sigb1right)) :: ( _, ( _, 
SIGNATURE1left, _)) :: rest671)) => let val  result = MlyValue.sdec
 (fn _ => let val  (sigb as sigb1) = sigb1 ()
 in (SigDec sigb)
end)
 in ( LrTable.NT 82, ( result, SIGNATURE1left, sigb1right), rest671)

end
|  ( 282, ( ( _, ( MlyValue.fsigb fsigb1, _, fsigb1right)) :: ( _, ( _
, FUNSIG1left, _)) :: rest671)) => let val  result = MlyValue.sdec (fn
 _ => let val  (fsigb as fsigb1) = fsigb1 ()
 in (FsigDec fsigb)
end)
 in ( LrTable.NT 82, ( result, FUNSIG1left, fsigb1right), rest671)
end
|  ( 283, ( ( _, ( MlyValue.fctb fctb1, _, fctb1right)) :: ( _, ( _, 
FUNCTOR1left, _)) :: rest671)) => let val  result = MlyValue.sdec (fn
 _ => let val  (fctb as fctb1) = fctb1 ()
 in (FctDec fctb)
end)
 in ( LrTable.NT 82, ( result, FUNCTOR1left, fctb1right), rest671)
end
|  ( 284, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.sdecs sdecs2, 
sdecs2left, sdecs2right)) :: _ :: ( _, ( MlyValue.sdecs sdecs1, 
sdecs1left, sdecs1right)) :: ( _, ( _, LOCAL1left, _)) :: rest671)) =>
 let val  result = MlyValue.sdec (fn _ => let val  sdecs1 = sdecs1 ()
 val  sdecs2 = sdecs2 ()
 in (
LocalDec(markdec(sdecs1,
						     sdecs1left,sdecs1right),
				    markdec(sdecs2,sdecs2left,sdecs2right))
)
end)
 in ( LrTable.NT 82, ( result, LOCAL1left, END1right), rest671)
end
|  ( 285, ( ( _, ( MlyValue.ldec ldec1, (ldecleft as ldec1left), (
ldecright as ldec1right))) :: rest671)) => let val  result = 
MlyValue.sdec (fn _ => let val  (ldec as ldec1) = ldec1 ()
 in (markdec(ldec,ldecleft,ldecright))
end)
 in ( LrTable.NT 82, ( result, ldec1left, ldec1right), rest671)
end
|  ( 286, ( ( _, ( MlyValue.str str1, _, (strright as str1right))) ::
 _ :: ( _, ( MlyValue.sigconstraint_op sigconstraint_op1, _, _)) :: (
 _, ( MlyValue.IDA IDA1, (IDAleft as IDA1left), _)) :: rest671)) =>
 let val  result = MlyValue.strb (fn _ => let val  (IDA as IDA1) = 
IDA1 ()
 val  (sigconstraint_op as sigconstraint_op1) = sigconstraint_op1 ()
 val  (str as str1) = str1 ()
 in (
[MarkStrb(Strb{name = strSymbol IDA, def = str,
					constraint=sigconstraint_op},
				   (IDAleft,strright))]
)
end)
 in ( LrTable.NT 85, ( result, IDA1left, str1right), rest671)
end
|  ( 287, ( ( _, ( MlyValue.strb strb2, _, strb2right)) :: _ :: ( _, (
 MlyValue.strb strb1, strb1left, _)) :: rest671)) => let val  result =
 MlyValue.strb (fn _ => let val  strb1 = strb1 ()
 val  strb2 = strb2 ()
 in (strb1 @ strb2)
end)
 in ( LrTable.NT 85, ( result, strb1left, strb2right), rest671)
end
|  ( 288, ( ( _, ( MlyValue.sign sign1, _, sign1right)) :: _ :: ( _, (
 MlyValue.IDA IDA1, IDA1left, _)) :: rest671)) => let val  result = 
MlyValue.fparam (fn _ => let val  (IDA as IDA1) = IDA1 ()
 val  (sign as sign1) = sign1 ()
 in ((SOME(strSymbol IDA),sign))
end)
 in ( LrTable.NT 86, ( result, IDA1left, sign1right), rest671)
end
|  ( 289, ( ( _, ( MlyValue.spec_s spec_s1, (spec_sleft as spec_s1left
), (spec_sright as spec_s1right))) :: rest671)) => let val  result = 
MlyValue.fparam (fn _ => let val  (spec_s as spec_s1) = spec_s1 ()
 in (
(NONE,MarkSig(BaseSig(spec_s),
					       (spec_sleft,spec_sright))))

end)
 in ( LrTable.NT 86, ( result, spec_s1left, spec_s1right), rest671)

end
|  ( 290, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.fparam 
fparam1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.fparamList (fn _ => let val  (fparam as fparam1) = 
fparam1 ()
 in ([fparam])
end)
 in ( LrTable.NT 87, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 291, ( ( _, ( MlyValue.fparamList fparamList1, _, 
fparamList1right)) :: _ :: ( _, ( MlyValue.fparam fparam1, _, _)) :: (
 _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.fparamList (fn _ => let val  (fparam as fparam1) = fparam1 ()
 val  (fparamList as fparamList1) = fparamList1 ()
 in (fparam :: fparamList)
end)
 in ( LrTable.NT 87, ( result, LPAREN1left, fparamList1right), rest671
)
end
|  ( 292, ( ( _, ( MlyValue.str str1, _, (strright as str1right))) ::
 _ :: ( _, ( MlyValue.sigconstraint_op sigconstraint_op1, _, _)) :: (
 _, ( MlyValue.fparamList fparamList1, _, _)) :: ( _, ( MlyValue.IDA 
IDA1, (IDAleft as IDA1left), _)) :: rest671)) => let val  result = 
MlyValue.fctb (fn _ => let val  (IDA as IDA1) = IDA1 ()
 val  (fparamList as fparamList1) = fparamList1 ()
 val  (sigconstraint_op as sigconstraint_op1) = sigconstraint_op1 ()
 val  (str as str1) = str1 ()
 in (
[MarkFctb(Fctb {name = fctSymbol IDA,
                                 def = BaseFct{params=fparamList, body=str,
				              constraint=sigconstraint_op}},
			   (IDAleft,strright))]
)
end)
 in ( LrTable.NT 88, ( result, IDA1left, str1right), rest671)
end
|  ( 293, ( ( _, ( MlyValue.fct_exp fct_exp1, _, (fct_expright as 
fct_exp1right))) :: _ :: ( _, ( MlyValue.fsigconstraint_op 
fsigconstraint_op1, _, _)) :: ( _, ( MlyValue.IDA IDA1, (IDAleft as 
IDA1left), _)) :: rest671)) => let val  result = MlyValue.fctb (fn _
 => let val  (IDA as IDA1) = IDA1 ()
 val  (fsigconstraint_op as fsigconstraint_op1) = fsigconstraint_op1
 ()
 val  (fct_exp as fct_exp1) = fct_exp1 ()
 in (
[MarkFctb(Fctb {name=fctSymbol IDA,
				 def=fct_exp (fsigconstraint_op)},
			   (IDAleft,fct_expright))]
)
end)
 in ( LrTable.NT 88, ( result, IDA1left, fct_exp1right), rest671)
end
|  ( 294, ( ( _, ( MlyValue.fctb fctb2, _, fctb2right)) :: _ :: ( _, (
 MlyValue.fctb fctb1, fctb1left, _)) :: rest671)) => let val  result =
 MlyValue.fctb (fn _ => let val  fctb1 = fctb1 ()
 val  fctb2 = fctb2 ()
 in (fctb1 @ fctb2)
end)
 in ( LrTable.NT 88, ( result, fctb1left, fctb2right), rest671)
end
|  ( 295, ( ( _, ( MlyValue.qid qid1, qid1left, qid1right)) :: rest671
)) => let val  result = MlyValue.fct_exp (fn _ => let val  (qid as 
qid1) = qid1 ()
 in (fn constraint => VarFct(qid fctSymbol,constraint))
end)
 in ( LrTable.NT 89, ( result, qid1left, qid1right), rest671)
end
|  ( 296, ( ( _, ( MlyValue.arg_fct arg_fct1, _, (arg_fctright as 
arg_fct1right))) :: ( _, ( MlyValue.qid qid1, (qidleft as qid1left), _
)) :: rest671)) => let val  result = MlyValue.fct_exp (fn _ => let
 val  (qid as qid1) = qid1 ()
 val  (arg_fct as arg_fct1) = arg_fct1 ()
 in (
fn constraint =>
		    MarkFct(AppFct(qid fctSymbol,arg_fct,constraint),
			    (qidleft,arg_fctright))
)
end)
 in ( LrTable.NT 89, ( result, qid1left, arg_fct1right), rest671)
end
|  ( 297, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.fct_exp fct_exp1, _, _)) :: _ :: ( _, ( MlyValue.strdecs 
strdecs1, _, _)) :: ( _, ( _, (LETleft as LET1left), _)) :: rest671))
 => let val  result = MlyValue.fct_exp (fn _ => let val  (strdecs as 
strdecs1) = strdecs1 ()
 val  (fct_exp as fct_exp1) = fct_exp1 ()
 in (
fn constraint =>
		   MarkFct(LetFct(strdecs, fct_exp constraint),
		   (LETleft,ENDright))
)
end)
 in ( LrTable.NT 89, ( result, LET1left, END1right), rest671)
end
|  ( 298, ( ( _, ( MlyValue.sdecs' sdecs'1, (sdecs'left as sdecs'1left
), (sdecs'right as sdecs'1right))) :: rest671)) => let val  result = 
MlyValue.interdec (fn _ => let val  (sdecs' as sdecs'1) = sdecs'1 ()
 in (markdec(sdecs',sdecs'left,sdecs'right))
end)
 in ( LrTable.NT 90, ( result, sdecs'1left, sdecs'1right), rest671)

end
|  ( 299, ( ( _, ( MlyValue.exp exp1, (expleft as exp1left), (expright
 as exp1right))) :: rest671)) => let val  result = MlyValue.interdec
 (fn _ => let val  (exp as exp1) = exp1 ()
 in (
markdec(ValDec([Vb{exp=exp,pat=VarPat itsym,lazyp=false}],nil),
				 expleft,expright)
)
end)
 in ( LrTable.NT 90, ( result, exp1left, exp1right), rest671)
end
| _ => raise (mlyAction i392)
end
val void = MlyValue.VOID
val extract = fn a => (fn MlyValue.interdec x => x
| _ => let exception ParseInternal
	in raise ParseInternal end) a ()
end
end
structure Tokens : SML_TOKENS =
struct
type svalue = ParserData.svalue
type ('a,'b) token = ('a,'b) Token.token
fun EOF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 0,(
ParserData.MlyValue.VOID,p1,p2))
fun SEMICOLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 1,(
ParserData.MlyValue.VOID,p1,p2))
fun IDA (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 2,(
ParserData.MlyValue.IDA (fn () => i),p1,p2))
fun IDS (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 3,(
ParserData.MlyValue.IDS (fn () => i),p1,p2))
fun TYVAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 4,(
ParserData.MlyValue.TYVAR (fn () => i),p1,p2))
fun INT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 5,(
ParserData.MlyValue.INT (fn () => i),p1,p2))
fun INT0 (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 6,(
ParserData.MlyValue.INT0 (fn () => i),p1,p2))
fun WORD (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 7,(
ParserData.MlyValue.WORD (fn () => i),p1,p2))
fun REAL (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 8,(
ParserData.MlyValue.REAL (fn () => i),p1,p2))
fun STRING (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 9,(
ParserData.MlyValue.STRING (fn () => i),p1,p2))
fun CHAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 10,(
ParserData.MlyValue.CHAR (fn () => i),p1,p2))
fun ABSTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 11,(
ParserData.MlyValue.VOID,p1,p2))
fun AND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 12,(
ParserData.MlyValue.VOID,p1,p2))
fun ARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 13,(
ParserData.MlyValue.VOID,p1,p2))
fun AS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 14,(
ParserData.MlyValue.VOID,p1,p2))
fun BAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 15,(
ParserData.MlyValue.VOID,p1,p2))
fun CASE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 16,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 17,(
ParserData.MlyValue.VOID,p1,p2))
fun DOTDOTDOT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 18,(
ParserData.MlyValue.VOID,p1,p2))
fun ELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 19,(
ParserData.MlyValue.VOID,p1,p2))
fun END (p1,p2) = Token.TOKEN (ParserData.LrTable.T 20,(
ParserData.MlyValue.VOID,p1,p2))
fun EQUALOP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 21,(
ParserData.MlyValue.VOID,p1,p2))
fun EQTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 22,(
ParserData.MlyValue.VOID,p1,p2))
fun EXCEPTION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 23,(
ParserData.MlyValue.VOID,p1,p2))
fun DO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 24,(
ParserData.MlyValue.VOID,p1,p2))
fun DOT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 25,(
ParserData.MlyValue.VOID,p1,p2))
fun DARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 26,(
ParserData.MlyValue.VOID,p1,p2))
fun FN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 27,(
ParserData.MlyValue.VOID,p1,p2))
fun FUN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 28,(
ParserData.MlyValue.VOID,p1,p2))
fun FUNCTOR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 29,(
ParserData.MlyValue.VOID,p1,p2))
fun HANDLE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 30,(
ParserData.MlyValue.VOID,p1,p2))
fun HASH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 31,(
ParserData.MlyValue.VOID,p1,p2))
fun IF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 32,(
ParserData.MlyValue.VOID,p1,p2))
fun IN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 33,(
ParserData.MlyValue.VOID,p1,p2))
fun INCLUDE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 34,(
ParserData.MlyValue.VOID,p1,p2))
fun INFIX (p1,p2) = Token.TOKEN (ParserData.LrTable.T 35,(
ParserData.MlyValue.VOID,p1,p2))
fun INFIXR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 36,(
ParserData.MlyValue.VOID,p1,p2))
fun LAZY (p1,p2) = Token.TOKEN (ParserData.LrTable.T 37,(
ParserData.MlyValue.VOID,p1,p2))
fun LET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 38,(
ParserData.MlyValue.VOID,p1,p2))
fun LOCAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 39,(
ParserData.MlyValue.VOID,p1,p2))
fun NONFIX (p1,p2) = Token.TOKEN (ParserData.LrTable.T 40,(
ParserData.MlyValue.VOID,p1,p2))
fun OF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 41,(
ParserData.MlyValue.VOID,p1,p2))
fun OP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 42,(
ParserData.MlyValue.VOID,p1,p2))
fun OPEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 43,(
ParserData.MlyValue.VOID,p1,p2))
fun OVERLOAD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 44,(
ParserData.MlyValue.VOID,p1,p2))
fun RAISE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 45,(
ParserData.MlyValue.VOID,p1,p2))
fun REC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 46,(
ParserData.MlyValue.VOID,p1,p2))
fun SHARING (p1,p2) = Token.TOKEN (ParserData.LrTable.T 47,(
ParserData.MlyValue.VOID,p1,p2))
fun SIG (p1,p2) = Token.TOKEN (ParserData.LrTable.T 48,(
ParserData.MlyValue.VOID,p1,p2))
fun SIGNATURE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 49,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 50,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCTURE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 51,(
ParserData.MlyValue.VOID,p1,p2))
fun THEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 52,(
ParserData.MlyValue.VOID,p1,p2))
fun TYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 53,(
ParserData.MlyValue.VOID,p1,p2))
fun VAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 54,(
ParserData.MlyValue.VOID,p1,p2))
fun WHERE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 55,(
ParserData.MlyValue.VOID,p1,p2))
fun WHILE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 56,(
ParserData.MlyValue.VOID,p1,p2))
fun WILD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 57,(
ParserData.MlyValue.VOID,p1,p2))
fun WITH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 58,(
ParserData.MlyValue.VOID,p1,p2))
fun WITHTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 59,(
ParserData.MlyValue.VOID,p1,p2))
fun ASTERISK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 60,(
ParserData.MlyValue.VOID,p1,p2))
fun COLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 61,(
ParserData.MlyValue.VOID,p1,p2))
fun COLONGT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 62,(
ParserData.MlyValue.VOID,p1,p2))
fun COMMA (p1,p2) = Token.TOKEN (ParserData.LrTable.T 63,(
ParserData.MlyValue.VOID,p1,p2))
fun LBRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 64,(
ParserData.MlyValue.VOID,p1,p2))
fun LBRACKET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 65,(
ParserData.MlyValue.VOID,p1,p2))
fun LPAREN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 66,(
ParserData.MlyValue.VOID,p1,p2))
fun RBRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 67,(
ParserData.MlyValue.VOID,p1,p2))
fun RBRACKET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 68,(
ParserData.MlyValue.VOID,p1,p2))
fun RPAREN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 69,(
ParserData.MlyValue.VOID,p1,p2))
fun ORELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 70,(
ParserData.MlyValue.VOID,p1,p2))
fun ANDALSO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 71,(
ParserData.MlyValue.VOID,p1,p2))
fun FUNSIG (p1,p2) = Token.TOKEN (ParserData.LrTable.T 72,(
ParserData.MlyValue.VOID,p1,p2))
fun VECTORSTART (p1,p2) = Token.TOKEN (ParserData.LrTable.T 73,(
ParserData.MlyValue.VOID,p1,p2))
fun BEGINQ (p1,p2) = Token.TOKEN (ParserData.LrTable.T 74,(
ParserData.MlyValue.VOID,p1,p2))
fun ENDQ (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 75,(
ParserData.MlyValue.ENDQ (fn () => i),p1,p2))
fun OBJL (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 76,(
ParserData.MlyValue.OBJL (fn () => i),p1,p2))
fun AQID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 77,(
ParserData.MlyValue.AQID (fn () => i),p1,p2))
end
end
