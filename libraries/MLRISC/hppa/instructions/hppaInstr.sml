(*
 * WARNING: This file was automatically generated by MDLGen (v3.1)
 * from the machine description file "hppa/hppa.mdl".
 * DO NOT EDIT this file directly
 *)


signature HPPAINSTR =
sig
   structure C : HPPACELLS
   structure CB : CELLS_BASIS = CellsBasis
   structure T : MLTREE
   structure Constant: CONSTANT
   structure Region : REGION
      sharing Constant = T.Constant
      sharing Region = T.Region
   datatype fmt =
     SGL
   | DBL
   | QUAD
   datatype loadi =
     LDW
   | LDH
   | LDB
   datatype store =
     STW
   | STH
   | STB
   datatype load =
     LDWX
   | LDWX_S
   | LDWX_M
   | LDWX_SM
   | LDHX
   | LDHX_S
   | LDHX_M
   | LDHX_SM
   | LDBX
   | LDBX_M
   datatype cmp =
     COMBT
   | COMBF
   datatype cmpi =
     COMIBT
   | COMIBF
   datatype arith =
     ADD
   | ADDL
   | ADDO
   | SH1ADD
   | SH1ADDL
   | SH1ADDO
   | SH2ADD
   | SH2ADDL
   | SH2ADDO
   | SH3ADD
   | SH3ADDL
   | SH3ADDO
   | SUB
   | SUBO
   | OR
   | XOR
   | AND
   | ANDCM
   datatype arithi =
     ADDI
   | ADDIO
   | ADDIL
   | SUBI
   | SUBIO
   datatype shiftv =
     VEXTRU
   | VEXTRS
   | ZVDEP
   datatype shift =
     EXTRU
   | EXTRS
   | ZDEP
   datatype farith =
     FADD_S
   | FADD_D
   | FADD_Q
   | FSUB_S
   | FSUB_D
   | FSUB_Q
   | FMPY_S
   | FMPY_D
   | FMPY_Q
   | FDIV_S
   | FDIV_D
   | FDIV_Q
   | XMPYU
   datatype funary =
     FCPY_S
   | FCPY_D
   | FCPY_Q
   | FABS_S
   | FABS_D
   | FABS_Q
   | FSQRT_S
   | FSQRT_D
   | FSQRT_Q
   | FRND_S
   | FRND_D
   | FRND_Q
   datatype fcnv =
     FCNVFF_SD
   | FCNVFF_SQ
   | FCNVFF_DS
   | FCNVFF_DQ
   | FCNVFF_QS
   | FCNVFF_QD
   | FCNVXF_S
   | FCNVXF_D
   | FCNVXF_Q
   | FCNVFX_S
   | FCNVFX_D
   | FCNVFX_Q
   | FCNVFXT_S
   | FCNVFXT_D
   | FCNVFXT_Q
   datatype fstore =
     FSTDS
   | FSTWS
   datatype fstorex =
     FSTDX
   | FSTDX_S
   | FSTDX_M
   | FSTDX_SM
   | FSTWX
   | FSTWX_S
   | FSTWX_M
   | FSTWX_SM
   datatype floadx =
     FLDDX
   | FLDDX_S
   | FLDDX_M
   | FLDDX_SM
   | FLDWX
   | FLDWX_S
   | FLDWX_M
   | FLDWX_SM
   datatype fload =
     FLDDS
   | FLDWS
   datatype bcond =
     EQ
   | LT
   | LE
   | LTU
   | LEU
   | NE
   | GE
   | GT
   | GTU
   | GEU
   datatype bitcond =
     BSET
   | BCLR
   datatype fcond =
     False_
   | False
   | ?
   | !<=>
   | ==
   | EQT
   | ?=
   | !<>
   | !?>=
   | <
   | ?<
   | !>=
   | !?>
   | <=
   | ?<=
   | !>
   | !?<=
   | >
   | ?>
   | !<=
   | !?<
   | >=
   | ?>=
   | !<
   | !?=
   | <>
   | !=
   | NET
   | !?
   | <=>
   | True_
   | True
   datatype scond =
     ALL_ZERO
   | LEFTMOST_ONE
   | LEFTMOST_ZERO
   | RIGHTMOST_ONE
   | RIGHTMOST_ZERO
   datatype field_selector =
     F
   | S
   | D
   | R
   | T
   | P
   datatype ea =
     Direct of CellsBasis.cell
   | FDirect of CellsBasis.cell
   | Displace of {base:CellsBasis.cell, disp:T.labexp, mem:Region.region}
   datatype operand =
     REG of CellsBasis.cell
   | IMMED of int
   | LabExp of T.labexp * field_selector
   | HILabExp of T.labexp * field_selector
   | LOLabExp of T.labexp * field_selector
   datatype addressing_mode =
     DISPea of CellsBasis.cell * operand
   | INDXea of CellsBasis.cell * CellsBasis.cell
   | INDXSCALEDea of CellsBasis.cell * CellsBasis.cell
   datatype instr =
     LOADI of {li:loadi, r:CellsBasis.cell, i:operand, t:CellsBasis.cell, mem:Region.region}
   | LOAD of {l:load, r1:CellsBasis.cell, r2:CellsBasis.cell, t:CellsBasis.cell, 
        mem:Region.region}
   | STORE of {st:store, b:CellsBasis.cell, d:operand, r:CellsBasis.cell, mem:Region.region}
   | ARITH of {a:arith, r1:CellsBasis.cell, r2:CellsBasis.cell, t:CellsBasis.cell}
   | ARITHI of {ai:arithi, i:operand, r:CellsBasis.cell, t:CellsBasis.cell}
   | COMCLR_LDO of {cc:bcond, r1:CellsBasis.cell, r2:CellsBasis.cell, t1:CellsBasis.cell, 
        i:int, b:CellsBasis.cell, t2:CellsBasis.cell}
   | COMICLR_LDO of {cc:bcond, i1:operand, r2:CellsBasis.cell, t1:CellsBasis.cell, 
        i2:int, b:CellsBasis.cell, t2:CellsBasis.cell}
   | SHIFTV of {sv:shiftv, r:CellsBasis.cell, len:int, t:CellsBasis.cell}
   | SHIFT of {s:shift, r:CellsBasis.cell, p:int, len:int, t:CellsBasis.cell}
   | BCOND of {cmp:cmp, bc:bcond, r1:CellsBasis.cell, r2:CellsBasis.cell, n:bool, 
        nop:bool, t:Label.label, f:Label.label}
   | BCONDI of {cmpi:cmpi, bc:bcond, i:int, r2:CellsBasis.cell, n:bool, nop:bool, 
        t:Label.label, f:Label.label}
   | BB of {bc:bitcond, r:CellsBasis.cell, p:int, n:bool, nop:bool, t:Label.label, 
        f:Label.label}
   | B of {lab:Label.label, n:bool}
   | LONGJUMP of {lab:Label.label, n:bool, tmp:CellsBasis.cell, tmpLab:Label.label}
   | BE of {b:CellsBasis.cell, d:operand, sr:int, n:bool, labs:Label.label list}
   | BV of {x:CellsBasis.cell, b:CellsBasis.cell, labs:Label.label list, n:bool}
   | BLR of {x:CellsBasis.cell, t:CellsBasis.cell, labs:Label.label list, n:bool}
   | BL of {lab:Label.label, t:CellsBasis.cell, defs:C.cellset, uses:C.cellset, 
        cutsTo:Label.label list, mem:Region.region, n:bool}
   | BLE of {d:operand, b:CellsBasis.cell, sr:int, t:CellsBasis.cell, defs:C.cellset, 
        uses:C.cellset, cutsTo:Label.label list, mem:Region.region}
   | LDIL of {i:operand, t:CellsBasis.cell}
   | LDO of {i:operand, b:CellsBasis.cell, t:CellsBasis.cell}
   | MTCTL of {r:CellsBasis.cell, t:CellsBasis.cell}
   | FSTORE of {fst:fstore, b:CellsBasis.cell, d:int, r:CellsBasis.cell, mem:Region.region}
   | FSTOREX of {fstx:fstorex, b:CellsBasis.cell, x:CellsBasis.cell, r:CellsBasis.cell, 
        mem:Region.region}
   | FLOAD of {fl:fload, b:CellsBasis.cell, d:int, t:CellsBasis.cell, mem:Region.region}
   | FLOADX of {flx:floadx, b:CellsBasis.cell, x:CellsBasis.cell, t:CellsBasis.cell, 
        mem:Region.region}
   | FARITH of {fa:farith, r1:CellsBasis.cell, r2:CellsBasis.cell, t:CellsBasis.cell}
   | FUNARY of {fu:funary, f:CellsBasis.cell, t:CellsBasis.cell}
   | FCNV of {fcnv:fcnv, f:CellsBasis.cell, t:CellsBasis.cell}
   | FBRANCH of {cc:fcond, fmt:fmt, f1:CellsBasis.cell, f2:CellsBasis.cell, 
        t:Label.label, f:Label.label, n:bool, long:bool}
   | BREAK of {code1:int, code2:int}
   | NOP
   | SOURCE of {}
   | SINK of {}
   | PHI of {}
   and instruction =
     LIVE of {regs: C.cellset, spilled: C.cellset}
   | KILL of {regs: C.cellset, spilled: C.cellset}
   | COPY of {k: CellsBasis.cellkind, 
              sz: int,          (* in bits *)
              dst: CellsBasis.cell list,
              src: CellsBasis.cell list,
              tmp: ea option (* NONE if |dst| = {src| = 1 *)}
   | ANNOTATION of {i:instruction, a:Annotations.annotation}
   | INSTR of instr
   val loadi : {li:loadi, r:CellsBasis.cell, i:operand, t:CellsBasis.cell, 
      mem:Region.region} -> instruction
   val load : {l:load, r1:CellsBasis.cell, r2:CellsBasis.cell, t:CellsBasis.cell, 
      mem:Region.region} -> instruction
   val store : {st:store, b:CellsBasis.cell, d:operand, r:CellsBasis.cell, 
      mem:Region.region} -> instruction
   val arith : {a:arith, r1:CellsBasis.cell, r2:CellsBasis.cell, t:CellsBasis.cell} -> instruction
   val arithi : {ai:arithi, i:operand, r:CellsBasis.cell, t:CellsBasis.cell} -> instruction
   val comclr_ldo : {cc:bcond, r1:CellsBasis.cell, r2:CellsBasis.cell, t1:CellsBasis.cell, 
      i:int, b:CellsBasis.cell, t2:CellsBasis.cell} -> instruction
   val comiclr_ldo : {cc:bcond, i1:operand, r2:CellsBasis.cell, t1:CellsBasis.cell, 
      i2:int, b:CellsBasis.cell, t2:CellsBasis.cell} -> instruction
   val shiftv : {sv:shiftv, r:CellsBasis.cell, len:int, t:CellsBasis.cell} -> instruction
   val shift : {s:shift, r:CellsBasis.cell, p:int, len:int, t:CellsBasis.cell} -> instruction
   val bcond : {cmp:cmp, bc:bcond, r1:CellsBasis.cell, r2:CellsBasis.cell, 
      n:bool, nop:bool, t:Label.label, f:Label.label} -> instruction
   val bcondi : {cmpi:cmpi, bc:bcond, i:int, r2:CellsBasis.cell, n:bool, nop:bool, 
      t:Label.label, f:Label.label} -> instruction
   val bb : {bc:bitcond, r:CellsBasis.cell, p:int, n:bool, nop:bool, t:Label.label, 
      f:Label.label} -> instruction
   val b : {lab:Label.label, n:bool} -> instruction
   val longjump : {lab:Label.label, n:bool, tmp:CellsBasis.cell, tmpLab:Label.label} -> instruction
   val be : {b:CellsBasis.cell, d:operand, sr:int, n:bool, labs:Label.label list} -> instruction
   val bv : {x:CellsBasis.cell, b:CellsBasis.cell, labs:Label.label list, n:bool} -> instruction
   val blr : {x:CellsBasis.cell, t:CellsBasis.cell, labs:Label.label list, 
      n:bool} -> instruction
   val bl : {lab:Label.label, t:CellsBasis.cell, defs:C.cellset, uses:C.cellset, 
      cutsTo:Label.label list, mem:Region.region, n:bool} -> instruction
   val ble : {d:operand, b:CellsBasis.cell, sr:int, t:CellsBasis.cell, defs:C.cellset, 
      uses:C.cellset, cutsTo:Label.label list, mem:Region.region} -> instruction
   val ldil : {i:operand, t:CellsBasis.cell} -> instruction
   val ldo : {i:operand, b:CellsBasis.cell, t:CellsBasis.cell} -> instruction
   val mtctl : {r:CellsBasis.cell, t:CellsBasis.cell} -> instruction
   val fstore : {fst:fstore, b:CellsBasis.cell, d:int, r:CellsBasis.cell, mem:Region.region} -> instruction
   val fstorex : {fstx:fstorex, b:CellsBasis.cell, x:CellsBasis.cell, r:CellsBasis.cell, 
      mem:Region.region} -> instruction
   val fload : {fl:fload, b:CellsBasis.cell, d:int, t:CellsBasis.cell, mem:Region.region} -> instruction
   val floadx : {flx:floadx, b:CellsBasis.cell, x:CellsBasis.cell, t:CellsBasis.cell, 
      mem:Region.region} -> instruction
   val farith : {fa:farith, r1:CellsBasis.cell, r2:CellsBasis.cell, t:CellsBasis.cell} -> instruction
   val funary : {fu:funary, f:CellsBasis.cell, t:CellsBasis.cell} -> instruction
   val fcnv : {fcnv:fcnv, f:CellsBasis.cell, t:CellsBasis.cell} -> instruction
   val fbranch : {cc:fcond, fmt:fmt, f1:CellsBasis.cell, f2:CellsBasis.cell, 
      t:Label.label, f:Label.label, n:bool, long:bool} -> instruction
   val break : {code1:int, code2:int} -> instruction
   val nop : instruction
   val source : {} -> instruction
   val sink : {} -> instruction
   val phi : {} -> instruction
end

functor HppaInstr(T: MLTREE
                 ) : HPPAINSTR =
struct
   structure C = HppaCells
   structure CB = CellsBasis
   structure T = T
   structure Region = T.Region
   structure Constant = T.Constant
   datatype fmt =
     SGL
   | DBL
   | QUAD
   datatype loadi =
     LDW
   | LDH
   | LDB
   datatype store =
     STW
   | STH
   | STB
   datatype load =
     LDWX
   | LDWX_S
   | LDWX_M
   | LDWX_SM
   | LDHX
   | LDHX_S
   | LDHX_M
   | LDHX_SM
   | LDBX
   | LDBX_M
   datatype cmp =
     COMBT
   | COMBF
   datatype cmpi =
     COMIBT
   | COMIBF
   datatype arith =
     ADD
   | ADDL
   | ADDO
   | SH1ADD
   | SH1ADDL
   | SH1ADDO
   | SH2ADD
   | SH2ADDL
   | SH2ADDO
   | SH3ADD
   | SH3ADDL
   | SH3ADDO
   | SUB
   | SUBO
   | OR
   | XOR
   | AND
   | ANDCM
   datatype arithi =
     ADDI
   | ADDIO
   | ADDIL
   | SUBI
   | SUBIO
   datatype shiftv =
     VEXTRU
   | VEXTRS
   | ZVDEP
   datatype shift =
     EXTRU
   | EXTRS
   | ZDEP
   datatype farith =
     FADD_S
   | FADD_D
   | FADD_Q
   | FSUB_S
   | FSUB_D
   | FSUB_Q
   | FMPY_S
   | FMPY_D
   | FMPY_Q
   | FDIV_S
   | FDIV_D
   | FDIV_Q
   | XMPYU
   datatype funary =
     FCPY_S
   | FCPY_D
   | FCPY_Q
   | FABS_S
   | FABS_D
   | FABS_Q
   | FSQRT_S
   | FSQRT_D
   | FSQRT_Q
   | FRND_S
   | FRND_D
   | FRND_Q
   datatype fcnv =
     FCNVFF_SD
   | FCNVFF_SQ
   | FCNVFF_DS
   | FCNVFF_DQ
   | FCNVFF_QS
   | FCNVFF_QD
   | FCNVXF_S
   | FCNVXF_D
   | FCNVXF_Q
   | FCNVFX_S
   | FCNVFX_D
   | FCNVFX_Q
   | FCNVFXT_S
   | FCNVFXT_D
   | FCNVFXT_Q
   datatype fstore =
     FSTDS
   | FSTWS
   datatype fstorex =
     FSTDX
   | FSTDX_S
   | FSTDX_M
   | FSTDX_SM
   | FSTWX
   | FSTWX_S
   | FSTWX_M
   | FSTWX_SM
   datatype floadx =
     FLDDX
   | FLDDX_S
   | FLDDX_M
   | FLDDX_SM
   | FLDWX
   | FLDWX_S
   | FLDWX_M
   | FLDWX_SM
   datatype fload =
     FLDDS
   | FLDWS
   datatype bcond =
     EQ
   | LT
   | LE
   | LTU
   | LEU
   | NE
   | GE
   | GT
   | GTU
   | GEU
   datatype bitcond =
     BSET
   | BCLR
   datatype fcond =
     False_
   | False
   | ?
   | !<=>
   | ==
   | EQT
   | ?=
   | !<>
   | !?>=
   | <
   | ?<
   | !>=
   | !?>
   | <=
   | ?<=
   | !>
   | !?<=
   | >
   | ?>
   | !<=
   | !?<
   | >=
   | ?>=
   | !<
   | !?=
   | <>
   | !=
   | NET
   | !?
   | <=>
   | True_
   | True
   datatype scond =
     ALL_ZERO
   | LEFTMOST_ONE
   | LEFTMOST_ZERO
   | RIGHTMOST_ONE
   | RIGHTMOST_ZERO
   datatype field_selector =
     F
   | S
   | D
   | R
   | T
   | P
   datatype ea =
     Direct of CellsBasis.cell
   | FDirect of CellsBasis.cell
   | Displace of {base:CellsBasis.cell, disp:T.labexp, mem:Region.region}
   datatype operand =
     REG of CellsBasis.cell
   | IMMED of int
   | LabExp of T.labexp * field_selector
   | HILabExp of T.labexp * field_selector
   | LOLabExp of T.labexp * field_selector
   datatype addressing_mode =
     DISPea of CellsBasis.cell * operand
   | INDXea of CellsBasis.cell * CellsBasis.cell
   | INDXSCALEDea of CellsBasis.cell * CellsBasis.cell
   datatype instr =
     LOADI of {li:loadi, r:CellsBasis.cell, i:operand, t:CellsBasis.cell, mem:Region.region}
   | LOAD of {l:load, r1:CellsBasis.cell, r2:CellsBasis.cell, t:CellsBasis.cell, 
        mem:Region.region}
   | STORE of {st:store, b:CellsBasis.cell, d:operand, r:CellsBasis.cell, mem:Region.region}
   | ARITH of {a:arith, r1:CellsBasis.cell, r2:CellsBasis.cell, t:CellsBasis.cell}
   | ARITHI of {ai:arithi, i:operand, r:CellsBasis.cell, t:CellsBasis.cell}
   | COMCLR_LDO of {cc:bcond, r1:CellsBasis.cell, r2:CellsBasis.cell, t1:CellsBasis.cell, 
        i:int, b:CellsBasis.cell, t2:CellsBasis.cell}
   | COMICLR_LDO of {cc:bcond, i1:operand, r2:CellsBasis.cell, t1:CellsBasis.cell, 
        i2:int, b:CellsBasis.cell, t2:CellsBasis.cell}
   | SHIFTV of {sv:shiftv, r:CellsBasis.cell, len:int, t:CellsBasis.cell}
   | SHIFT of {s:shift, r:CellsBasis.cell, p:int, len:int, t:CellsBasis.cell}
   | BCOND of {cmp:cmp, bc:bcond, r1:CellsBasis.cell, r2:CellsBasis.cell, n:bool, 
        nop:bool, t:Label.label, f:Label.label}
   | BCONDI of {cmpi:cmpi, bc:bcond, i:int, r2:CellsBasis.cell, n:bool, nop:bool, 
        t:Label.label, f:Label.label}
   | BB of {bc:bitcond, r:CellsBasis.cell, p:int, n:bool, nop:bool, t:Label.label, 
        f:Label.label}
   | B of {lab:Label.label, n:bool}
   | LONGJUMP of {lab:Label.label, n:bool, tmp:CellsBasis.cell, tmpLab:Label.label}
   | BE of {b:CellsBasis.cell, d:operand, sr:int, n:bool, labs:Label.label list}
   | BV of {x:CellsBasis.cell, b:CellsBasis.cell, labs:Label.label list, n:bool}
   | BLR of {x:CellsBasis.cell, t:CellsBasis.cell, labs:Label.label list, n:bool}
   | BL of {lab:Label.label, t:CellsBasis.cell, defs:C.cellset, uses:C.cellset, 
        cutsTo:Label.label list, mem:Region.region, n:bool}
   | BLE of {d:operand, b:CellsBasis.cell, sr:int, t:CellsBasis.cell, defs:C.cellset, 
        uses:C.cellset, cutsTo:Label.label list, mem:Region.region}
   | LDIL of {i:operand, t:CellsBasis.cell}
   | LDO of {i:operand, b:CellsBasis.cell, t:CellsBasis.cell}
   | MTCTL of {r:CellsBasis.cell, t:CellsBasis.cell}
   | FSTORE of {fst:fstore, b:CellsBasis.cell, d:int, r:CellsBasis.cell, mem:Region.region}
   | FSTOREX of {fstx:fstorex, b:CellsBasis.cell, x:CellsBasis.cell, r:CellsBasis.cell, 
        mem:Region.region}
   | FLOAD of {fl:fload, b:CellsBasis.cell, d:int, t:CellsBasis.cell, mem:Region.region}
   | FLOADX of {flx:floadx, b:CellsBasis.cell, x:CellsBasis.cell, t:CellsBasis.cell, 
        mem:Region.region}
   | FARITH of {fa:farith, r1:CellsBasis.cell, r2:CellsBasis.cell, t:CellsBasis.cell}
   | FUNARY of {fu:funary, f:CellsBasis.cell, t:CellsBasis.cell}
   | FCNV of {fcnv:fcnv, f:CellsBasis.cell, t:CellsBasis.cell}
   | FBRANCH of {cc:fcond, fmt:fmt, f1:CellsBasis.cell, f2:CellsBasis.cell, 
        t:Label.label, f:Label.label, n:bool, long:bool}
   | BREAK of {code1:int, code2:int}
   | NOP
   | SOURCE of {}
   | SINK of {}
   | PHI of {}
   and instruction =
     LIVE of {regs: C.cellset, spilled: C.cellset}
   | KILL of {regs: C.cellset, spilled: C.cellset}
   | COPY of {k: CellsBasis.cellkind, 
              sz: int,          (* in bits *)
              dst: CellsBasis.cell list,
              src: CellsBasis.cell list,
              tmp: ea option (* NONE if |dst| = {src| = 1 *)}
   | ANNOTATION of {i:instruction, a:Annotations.annotation}
   | INSTR of instr
   val loadi = INSTR o LOADI
   and load = INSTR o LOAD
   and store = INSTR o STORE
   and arith = INSTR o ARITH
   and arithi = INSTR o ARITHI
   and comclr_ldo = INSTR o COMCLR_LDO
   and comiclr_ldo = INSTR o COMICLR_LDO
   and shiftv = INSTR o SHIFTV
   and shift = INSTR o SHIFT
   and bcond = INSTR o BCOND
   and bcondi = INSTR o BCONDI
   and bb = INSTR o BB
   and b = INSTR o B
   and longjump = INSTR o LONGJUMP
   and be = INSTR o BE
   and bv = INSTR o BV
   and blr = INSTR o BLR
   and bl = INSTR o BL
   and ble = INSTR o BLE
   and ldil = INSTR o LDIL
   and ldo = INSTR o LDO
   and mtctl = INSTR o MTCTL
   and fstore = INSTR o FSTORE
   and fstorex = INSTR o FSTOREX
   and fload = INSTR o FLOAD
   and floadx = INSTR o FLOADX
   and farith = INSTR o FARITH
   and funary = INSTR o FUNARY
   and fcnv = INSTR o FCNV
   and fbranch = INSTR o FBRANCH
   and break = INSTR o BREAK
   and nop = INSTR NOP
   and source = INSTR o SOURCE
   and sink = INSTR o SINK
   and phi = INSTR o PHI
end

