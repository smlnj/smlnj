(*
 * WARNING: This file was automatically generated by MDLGen (v3.1)
 * from the machine description file "ppc/ppc.mdl".
 * DO NOT EDIT this file directly
 *)


signature PPCINSTR =
sig
   structure C : PPCCELLS
   structure CB : CELLS_BASIS = CellsBasis
   structure T : MLTREE
   structure Constant: CONSTANT
   structure Region : REGION
      sharing Constant = T.Constant
      sharing Region = T.Region
   type gpr = int
   type fpr = int
   type ccr = int
   type crf = int
   datatype spr =
     XER
   | LR
   | CTR
   datatype operand =
     RegOp of CellsBasis.cell
   | ImmedOp of int
   | LabelOp of T.labexp
   type addressing_mode = CellsBasis.cell * operand
   datatype ea =
     Direct of CellsBasis.cell
   | FDirect of CellsBasis.cell
   | Displace of {base:CellsBasis.cell, disp:T.labexp, mem:Region.region}
   datatype load =
     LBZ
   | LBZE
   | LHZ
   | LHZE
   | LHA
   | LHAE
   | LWZ
   | LWZE
   | LDE
   | LBZU
   | LHZU
   | LHAU
   | LWZU
   | LDZU
   datatype store =
     STB
   | STBE
   | STH
   | STHE
   | STW
   | STWE
   | STDE
   | STBU
   | STHU
   | STWU
   | STDU
   datatype fload =
     LFS
   | LFSE
   | LFD
   | LFDE
   | LFSU
   | LFDU
   datatype fstore =
     STFS
   | STFSE
   | STFD
   | STFDE
   | STFSU
   | STFDU
   datatype cmp =
     CMP
   | CMPL
   datatype fcmp =
     FCMPO
   | FCMPU
   datatype unary =
     NEG
   | EXTSB
   | EXTSH
   | EXTSW
   | CNTLZW
   | CNTLZD
   datatype funary =
     FMR
   | FNEG
   | FABS
   | FNABS
   | FSQRT
   | FSQRTS
   | FRSP
   | FCTIW
   | FCTIWZ
   | FCTID
   | FCTIDZ
   | FCFID
   datatype farith =
     FADD
   | FSUB
   | FMUL
   | FDIV
   | FADDS
   | FSUBS
   | FMULS
   | FDIVS
   datatype farith3 =
     FMADD
   | FMADDS
   | FMSUB
   | FMSUBS
   | FNMADD
   | FNMADDS
   | FNMSUB
   | FNMSUBS
   | FSEL
   datatype bo =
     TRUE
   | FALSE
   | ALWAYS
   | COUNTER of {eqZero:bool, cond:bool option}
   datatype arith =
     ADD
   | SUBF
   | MULLW
   | MULLD
   | MULHW
   | MULHWU
   | DIVW
   | DIVD
   | DIVWU
   | DIVDU
   | AND
   | OR
   | XOR
   | NAND
   | NOR
   | EQV
   | ANDC
   | ORC
   | SLW
   | SLD
   | SRW
   | SRD
   | SRAW
   | SRAD
   datatype arithi =
     ADDI
   | ADDIS
   | SUBFIC
   | MULLI
   | ANDI_Rc
   | ANDIS_Rc
   | ORI
   | ORIS
   | XORI
   | XORIS
   | SRAWI
   | SRADI
   datatype rotate =
     RLWNM
   | RLDCL
   | RLDCR
   datatype rotatei =
     RLWINM
   | RLWIMI
   | RLDICL
   | RLDICR
   | RLDIC
   | RLDIMI
   datatype ccarith =
     CRAND
   | CROR
   | CRXOR
   | CRNAND
   | CRNOR
   | CREQV
   | CRANDC
   | CRORC
   datatype bit =
     LT
   | GT
   | EQ
   | SO
   | FL
   | FG
   | FE
   | FU
   | FX
   | FEX
   | VX
   | OX
   datatype xerbit =
     SO64
   | OV64
   | CA64
   | SO32
   | OV32
   | CA32
   type cr_bit = (CellsBasis.cell) * bit
   datatype instr =
     L of {ld:load, rt:CellsBasis.cell, ra:CellsBasis.cell, d:operand, mem:Region.region}
   | LF of {ld:fload, ft:CellsBasis.cell, ra:CellsBasis.cell, d:operand, mem:Region.region}
   | ST of {st:store, rs:CellsBasis.cell, ra:CellsBasis.cell, d:operand, mem:Region.region}
   | STF of {st:fstore, fs:CellsBasis.cell, ra:CellsBasis.cell, d:operand, 
        mem:Region.region}
   | UNARY of {oper:unary, rt:CellsBasis.cell, ra:CellsBasis.cell, Rc:bool, 
        OE:bool}
   | ARITH of {oper:arith, rt:CellsBasis.cell, ra:CellsBasis.cell, rb:CellsBasis.cell, 
        Rc:bool, OE:bool}
   | ARITHI of {oper:arithi, rt:CellsBasis.cell, ra:CellsBasis.cell, im:operand}
   | ROTATE of {oper:rotate, ra:CellsBasis.cell, rs:CellsBasis.cell, sh:CellsBasis.cell, 
        mb:int, me:int option}
   | ROTATEI of {oper:rotatei, ra:CellsBasis.cell, rs:CellsBasis.cell, sh:operand, 
        mb:int, me:int option}
   | COMPARE of {cmp:cmp, l:bool, bf:CellsBasis.cell, ra:CellsBasis.cell, rb:operand}
   | FCOMPARE of {cmp:fcmp, bf:CellsBasis.cell, fa:CellsBasis.cell, fb:CellsBasis.cell}
   | FUNARY of {oper:funary, ft:CellsBasis.cell, fb:CellsBasis.cell, Rc:bool}
   | FARITH of {oper:farith, ft:CellsBasis.cell, fa:CellsBasis.cell, fb:CellsBasis.cell, 
        Rc:bool}
   | FARITH3 of {oper:farith3, ft:CellsBasis.cell, fa:CellsBasis.cell, fb:CellsBasis.cell, 
        fc:CellsBasis.cell, Rc:bool}
   | CCARITH of {oper:ccarith, bt:cr_bit, ba:cr_bit, bb:cr_bit}
   | MCRF of {bf:CellsBasis.cell, bfa:CellsBasis.cell}
   | MTSPR of {rs:CellsBasis.cell, spr:CellsBasis.cell}
   | MFSPR of {rt:CellsBasis.cell, spr:CellsBasis.cell}
   | LWARX of {rt:CellsBasis.cell, ra:CellsBasis.cell, rb:CellsBasis.cell}
   | STWCX of {rs:CellsBasis.cell, ra:CellsBasis.cell, rb:CellsBasis.cell}
   | TW of {to:int, ra:CellsBasis.cell, si:operand}
   | TD of {to:int, ra:CellsBasis.cell, si:operand}
   | BC of {bo:bo, bf:CellsBasis.cell, bit:bit, addr:operand, LK:bool, fall:operand}
   | BCLR of {bo:bo, bf:CellsBasis.cell, bit:bit, LK:bool, labels:Label.label list}
   | B of {addr:operand, LK:bool}
   | CALL of {def:C.cellset, use:C.cellset, cutsTo:Label.label list, mem:Region.region}
   | SOURCE of {}
   | SINK of {}
   | PHI of {}
   and instruction =
     LIVE of {regs: C.cellset, spilled: C.cellset}
   | KILL of {regs: C.cellset, spilled: C.cellset}
   | COPY of {k: CellsBasis.cellkind, 
              sz: int,          (* in bits *)
              dst: CellsBasis.cell list,
              src: CellsBasis.cell list,
              tmp: ea option (* NONE if |dst| = {src| = 1 *)}
   | ANNOTATION of {i:instruction, a:Annotations.annotation}
   | INSTR of instr
   val l : {ld:load, rt:CellsBasis.cell, ra:CellsBasis.cell, d:operand, mem:Region.region} -> instruction
   val lf : {ld:fload, ft:CellsBasis.cell, ra:CellsBasis.cell, d:operand, mem:Region.region} -> instruction
   val st : {st:store, rs:CellsBasis.cell, ra:CellsBasis.cell, d:operand, mem:Region.region} -> instruction
   val stf : {st:fstore, fs:CellsBasis.cell, ra:CellsBasis.cell, d:operand, 
      mem:Region.region} -> instruction
   val unary : {oper:unary, rt:CellsBasis.cell, ra:CellsBasis.cell, Rc:bool, 
      OE:bool} -> instruction
   val arith : {oper:arith, rt:CellsBasis.cell, ra:CellsBasis.cell, rb:CellsBasis.cell, 
      Rc:bool, OE:bool} -> instruction
   val arithi : {oper:arithi, rt:CellsBasis.cell, ra:CellsBasis.cell, im:operand} -> instruction
   val rotate : {oper:rotate, ra:CellsBasis.cell, rs:CellsBasis.cell, sh:CellsBasis.cell, 
      mb:int, me:int option} -> instruction
   val rotatei : {oper:rotatei, ra:CellsBasis.cell, rs:CellsBasis.cell, sh:operand, 
      mb:int, me:int option} -> instruction
   val compare : {cmp:cmp, l:bool, bf:CellsBasis.cell, ra:CellsBasis.cell, 
      rb:operand} -> instruction
   val fcompare : {cmp:fcmp, bf:CellsBasis.cell, fa:CellsBasis.cell, fb:CellsBasis.cell} -> instruction
   val funary : {oper:funary, ft:CellsBasis.cell, fb:CellsBasis.cell, Rc:bool} -> instruction
   val farith : {oper:farith, ft:CellsBasis.cell, fa:CellsBasis.cell, fb:CellsBasis.cell, 
      Rc:bool} -> instruction
   val farith3 : {oper:farith3, ft:CellsBasis.cell, fa:CellsBasis.cell, fb:CellsBasis.cell, 
      fc:CellsBasis.cell, Rc:bool} -> instruction
   val ccarith : {oper:ccarith, bt:cr_bit, ba:cr_bit, bb:cr_bit} -> instruction
   val mcrf : {bf:CellsBasis.cell, bfa:CellsBasis.cell} -> instruction
   val mtspr : {rs:CellsBasis.cell, spr:CellsBasis.cell} -> instruction
   val mfspr : {rt:CellsBasis.cell, spr:CellsBasis.cell} -> instruction
   val lwarx : {rt:CellsBasis.cell, ra:CellsBasis.cell, rb:CellsBasis.cell} -> instruction
   val stwcx : {rs:CellsBasis.cell, ra:CellsBasis.cell, rb:CellsBasis.cell} -> instruction
   val tw : {to:int, ra:CellsBasis.cell, si:operand} -> instruction
   val td : {to:int, ra:CellsBasis.cell, si:operand} -> instruction
   val bc : {bo:bo, bf:CellsBasis.cell, bit:bit, addr:operand, LK:bool, fall:operand} -> instruction
   val bclr : {bo:bo, bf:CellsBasis.cell, bit:bit, LK:bool, labels:Label.label list} -> instruction
   val b : {addr:operand, LK:bool} -> instruction
   val call : {def:C.cellset, use:C.cellset, cutsTo:Label.label list, mem:Region.region} -> instruction
   val source : {} -> instruction
   val sink : {} -> instruction
   val phi : {} -> instruction
end

functor PPCInstr(T: MLTREE
                ) : PPCINSTR =
struct
   structure C = PPCCells
   structure CB = CellsBasis
   structure T = T
   structure Region = T.Region
   structure Constant = T.Constant
   type gpr = int
   type fpr = int
   type ccr = int
   type crf = int
   datatype spr =
     XER
   | LR
   | CTR
   datatype operand =
     RegOp of CellsBasis.cell
   | ImmedOp of int
   | LabelOp of T.labexp
   type addressing_mode = CellsBasis.cell * operand
   datatype ea =
     Direct of CellsBasis.cell
   | FDirect of CellsBasis.cell
   | Displace of {base:CellsBasis.cell, disp:T.labexp, mem:Region.region}
   datatype load =
     LBZ
   | LBZE
   | LHZ
   | LHZE
   | LHA
   | LHAE
   | LWZ
   | LWZE
   | LDE
   | LBZU
   | LHZU
   | LHAU
   | LWZU
   | LDZU
   datatype store =
     STB
   | STBE
   | STH
   | STHE
   | STW
   | STWE
   | STDE
   | STBU
   | STHU
   | STWU
   | STDU
   datatype fload =
     LFS
   | LFSE
   | LFD
   | LFDE
   | LFSU
   | LFDU
   datatype fstore =
     STFS
   | STFSE
   | STFD
   | STFDE
   | STFSU
   | STFDU
   datatype cmp =
     CMP
   | CMPL
   datatype fcmp =
     FCMPO
   | FCMPU
   datatype unary =
     NEG
   | EXTSB
   | EXTSH
   | EXTSW
   | CNTLZW
   | CNTLZD
   datatype funary =
     FMR
   | FNEG
   | FABS
   | FNABS
   | FSQRT
   | FSQRTS
   | FRSP
   | FCTIW
   | FCTIWZ
   | FCTID
   | FCTIDZ
   | FCFID
   datatype farith =
     FADD
   | FSUB
   | FMUL
   | FDIV
   | FADDS
   | FSUBS
   | FMULS
   | FDIVS
   datatype farith3 =
     FMADD
   | FMADDS
   | FMSUB
   | FMSUBS
   | FNMADD
   | FNMADDS
   | FNMSUB
   | FNMSUBS
   | FSEL
   datatype bo =
     TRUE
   | FALSE
   | ALWAYS
   | COUNTER of {eqZero:bool, cond:bool option}
   datatype arith =
     ADD
   | SUBF
   | MULLW
   | MULLD
   | MULHW
   | MULHWU
   | DIVW
   | DIVD
   | DIVWU
   | DIVDU
   | AND
   | OR
   | XOR
   | NAND
   | NOR
   | EQV
   | ANDC
   | ORC
   | SLW
   | SLD
   | SRW
   | SRD
   | SRAW
   | SRAD
   datatype arithi =
     ADDI
   | ADDIS
   | SUBFIC
   | MULLI
   | ANDI_Rc
   | ANDIS_Rc
   | ORI
   | ORIS
   | XORI
   | XORIS
   | SRAWI
   | SRADI
   datatype rotate =
     RLWNM
   | RLDCL
   | RLDCR
   datatype rotatei =
     RLWINM
   | RLWIMI
   | RLDICL
   | RLDICR
   | RLDIC
   | RLDIMI
   datatype ccarith =
     CRAND
   | CROR
   | CRXOR
   | CRNAND
   | CRNOR
   | CREQV
   | CRANDC
   | CRORC
   datatype bit =
     LT
   | GT
   | EQ
   | SO
   | FL
   | FG
   | FE
   | FU
   | FX
   | FEX
   | VX
   | OX
   datatype xerbit =
     SO64
   | OV64
   | CA64
   | SO32
   | OV32
   | CA32
   type cr_bit = (CellsBasis.cell) * bit
   datatype instr =
     L of {ld:load, rt:CellsBasis.cell, ra:CellsBasis.cell, d:operand, mem:Region.region}
   | LF of {ld:fload, ft:CellsBasis.cell, ra:CellsBasis.cell, d:operand, mem:Region.region}
   | ST of {st:store, rs:CellsBasis.cell, ra:CellsBasis.cell, d:operand, mem:Region.region}
   | STF of {st:fstore, fs:CellsBasis.cell, ra:CellsBasis.cell, d:operand, 
        mem:Region.region}
   | UNARY of {oper:unary, rt:CellsBasis.cell, ra:CellsBasis.cell, Rc:bool, 
        OE:bool}
   | ARITH of {oper:arith, rt:CellsBasis.cell, ra:CellsBasis.cell, rb:CellsBasis.cell, 
        Rc:bool, OE:bool}
   | ARITHI of {oper:arithi, rt:CellsBasis.cell, ra:CellsBasis.cell, im:operand}
   | ROTATE of {oper:rotate, ra:CellsBasis.cell, rs:CellsBasis.cell, sh:CellsBasis.cell, 
        mb:int, me:int option}
   | ROTATEI of {oper:rotatei, ra:CellsBasis.cell, rs:CellsBasis.cell, sh:operand, 
        mb:int, me:int option}
   | COMPARE of {cmp:cmp, l:bool, bf:CellsBasis.cell, ra:CellsBasis.cell, rb:operand}
   | FCOMPARE of {cmp:fcmp, bf:CellsBasis.cell, fa:CellsBasis.cell, fb:CellsBasis.cell}
   | FUNARY of {oper:funary, ft:CellsBasis.cell, fb:CellsBasis.cell, Rc:bool}
   | FARITH of {oper:farith, ft:CellsBasis.cell, fa:CellsBasis.cell, fb:CellsBasis.cell, 
        Rc:bool}
   | FARITH3 of {oper:farith3, ft:CellsBasis.cell, fa:CellsBasis.cell, fb:CellsBasis.cell, 
        fc:CellsBasis.cell, Rc:bool}
   | CCARITH of {oper:ccarith, bt:cr_bit, ba:cr_bit, bb:cr_bit}
   | MCRF of {bf:CellsBasis.cell, bfa:CellsBasis.cell}
   | MTSPR of {rs:CellsBasis.cell, spr:CellsBasis.cell}
   | MFSPR of {rt:CellsBasis.cell, spr:CellsBasis.cell}
   | LWARX of {rt:CellsBasis.cell, ra:CellsBasis.cell, rb:CellsBasis.cell}
   | STWCX of {rs:CellsBasis.cell, ra:CellsBasis.cell, rb:CellsBasis.cell}
   | TW of {to:int, ra:CellsBasis.cell, si:operand}
   | TD of {to:int, ra:CellsBasis.cell, si:operand}
   | BC of {bo:bo, bf:CellsBasis.cell, bit:bit, addr:operand, LK:bool, fall:operand}
   | BCLR of {bo:bo, bf:CellsBasis.cell, bit:bit, LK:bool, labels:Label.label list}
   | B of {addr:operand, LK:bool}
   | CALL of {def:C.cellset, use:C.cellset, cutsTo:Label.label list, mem:Region.region}
   | SOURCE of {}
   | SINK of {}
   | PHI of {}
   and instruction =
     LIVE of {regs: C.cellset, spilled: C.cellset}
   | KILL of {regs: C.cellset, spilled: C.cellset}
   | COPY of {k: CellsBasis.cellkind, 
              sz: int,          (* in bits *)
              dst: CellsBasis.cell list,
              src: CellsBasis.cell list,
              tmp: ea option (* NONE if |dst| = {src| = 1 *)}
   | ANNOTATION of {i:instruction, a:Annotations.annotation}
   | INSTR of instr
   val l = INSTR o L
   and lf = INSTR o LF
   and st = INSTR o ST
   and stf = INSTR o STF
   and unary = INSTR o UNARY
   and arith = INSTR o ARITH
   and arithi = INSTR o ARITHI
   and rotate = INSTR o ROTATE
   and rotatei = INSTR o ROTATEI
   and compare = INSTR o COMPARE
   and fcompare = INSTR o FCOMPARE
   and funary = INSTR o FUNARY
   and farith = INSTR o FARITH
   and farith3 = INSTR o FARITH3
   and ccarith = INSTR o CCARITH
   and mcrf = INSTR o MCRF
   and mtspr = INSTR o MTSPR
   and mfspr = INSTR o MFSPR
   and lwarx = INSTR o LWARX
   and stwcx = INSTR o STWCX
   and tw = INSTR o TW
   and td = INSTR o TD
   and bc = INSTR o BC
   and bclr = INSTR o BCLR
   and b = INSTR o B
   and call = INSTR o CALL
   and source = INSTR o SOURCE
   and sink = INSTR o SINK
   and phi = INSTR o PHI
end

