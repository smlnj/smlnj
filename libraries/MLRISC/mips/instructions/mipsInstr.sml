(*
 * WARNING: This file was automatically generated by MDLGen (v3.0)
 * from the machine description file "mips/mips.mdl".
 * DO NOT EDIT this file directly
 *)


signature MIPSINSTR =
sig
   structure C : MIPSCELLS
   structure CB : CELLS_BASIS = CellsBasis
   structure T : MLTREE
   structure Constant: CONSTANT
   structure Region : REGION
      sharing Constant = T.Constant
      sharing Region = T.Region
   datatype load =
     LD
   | LW
   | LH
   | LHU
   | LB
   | LBU
   | LWL
   | LWR
   | LWU
   | LDL
   | LDR
   | ULH
   | ULHU
   | ULW
   | ULD
   datatype store =
     SD
   | SW
   | SH
   | SB
   | SWL
   | SWR
   | SDL
   | SDR
   | USH
   | USW
   | USD
   datatype fload =
     LDC1
   | LWC1
   datatype fstore =
     SDC1
   | SWC1
   datatype fcond =
     FF
   | FUN
   | FEQ
   | FUEQ
   | FOLT
   | FULT
   | FOLE
   | FULE
   | FNGLE
   | FSP
   | FNGL
   | FSEQ
   | FLT
   | FNGE
   | FLE
   | FNGT
   datatype cond =
     EQ
   | NE
   | LEZ
   | GTZ
   | LTZ
   | GEZ
   datatype fbranch =
     BC1T
   | BC1F
   datatype likely =
     LIKELY
   | UNLIKELY
   datatype arith =
     ADD
   | ADDU
   | AND
   | XOR
   | MUL
   | MULO
   | MULOU
   | NOR
   | OR
   | SEQ
   | SGT
   | SGE
   | SGEU
   | SGTU
   | SLT
   | SLE
   | SLEU
   | SLTU
   | SNE
   | SUB
   | SUBU
   | REM
   | REMU
   | SRA
   | SLL
   | SRL
   | ROR
   | ROL
   | MOVN
   | MOVZ
   | DADD
   | DADDU
   | DMUL
   | DMULO
   | DMULOU
   | DSUB
   | DSUBU
   | DREM
   | DREMU
   | DROL
   | DROR
   | DSLL
   | DSLL32
   | DSLLV
   | DSRA
   | DSRA32
   | DSRAV
   | DSRL
   | DSRL32
   | DSRLV
   datatype unary =
     ABS
   | NEG
   | NEGU
   | NOT
   | DABS
   | DNEG
   | DNEGU
   datatype multiply =
     MULT
   | MULTU
   | DMULT
   | DMULTU
   datatype divide =
     DIV
   | DIVU
   | DDIV
   | DDIVU
   datatype trap =
     TEQ
   | TNE
   | TLT
   | TLTU
   | TGE
   | TGEU
   datatype farith =
     ADD_D
   | ADD_S
   | SUB_D
   | SUB_S
   | MUL_D
   | MUL_S
   | DIV_D
   | DIV_S
   datatype funary =
     MOV_D
   | MOV_S
   | ABS_D
   | ABS_S
   | NEG_D
   | NEG_S
   | SQRT_D
   | SQRT_S
   | CVT_SD
   | CVT_SW
   | CVT_DS
   | CVT_DW
   | CVT_WS
   | CVT_WD
   | CVT_SL
   | CVT_DL
   | CVT_LS
   | CVT_LD
   datatype cvti2f =
     MTC1
   | DMTC1
   datatype cvtf2i =
     MFC1
   | DMFC1
   datatype farith3 =
     MADD_D
   | MADD_S
   | NMADD_D
   | NMADD_S
   | MSUB_D
   | MSUB_S
   | NMSUB_D
   | NMSUB_S
   datatype fround =
     TRUNC_WS
   | TRUNC_WD
   | ROUND_WS
   | ROUND_WD
   | CEIL_WD
   | CEIL_WS
   | CEILU_WD
   | CEILU_WS
   | FLOOR_WD
   | FLOOR_WS
   | FLOORU_WD
   | FLOORU_WS
   | ROUNDU_WD
   | ROUNDU_WS
   | TRUNCU_WD
   | TRUNCU_WS
   | TRUNC_LS
   | TRUNC_LD
   | ROUND_LS
   | ROUND_LD
   | CEIL_LS
   | CEIL_LD
   | FLOOR_LS
   | FLOOR_LD
   datatype fmt =
     SINGLE
   | DOUBLE
   datatype operand =
     Imm of int
   | Reg of CellsBasis.cell
   | Lab of T.labexp
   | HiLab of T.labexp
   | LoLab of T.labexp
   datatype ea =
     Direct of CellsBasis.cell
   | FDirect of CellsBasis.cell
   | Displace of {base:CellsBasis.cell, disp:int}
   type addressing_mode = C.cell * operand
   datatype instr =
     NOP
   | LUI of {rt:CellsBasis.cell, imm:operand}
   | LA of {rt:CellsBasis.cell, b:CellsBasis.cell, d:operand}
   | DLA of {rt:CellsBasis.cell, b:CellsBasis.cell, d:operand}
   | LOAD of {l:load, rt:CellsBasis.cell, b:CellsBasis.cell, d:operand, mem:Region.region}
   | STORE of {s:store, rs:CellsBasis.cell, b:CellsBasis.cell, d:operand, mem:Region.region}
   | FLOAD of {l:fload, ft:CellsBasis.cell, b:CellsBasis.cell, d:operand, mem:Region.region}
   | FSTORE of {s:fstore, fs:CellsBasis.cell, b:CellsBasis.cell, d:operand,
        mem:Region.region}
   | FCMP of {fcond:fcond, fmt:fmt, cc:CellsBasis.cell, fs1:CellsBasis.cell,
        fs2:CellsBasis.cell}
   | TRAP of {t:trap, rs:CellsBasis.cell, i:operand}
   | J of {lab:Label.label, nop:bool}
   | JR of {rs:CellsBasis.cell, labels:Label.label list, nop:bool}
   | JAL of {lab:Label.label, defs:C.cellset, uses:C.cellset, cutsTo:Label.label list,
        mem:Region.region, nop:bool}
   | JALR of {rt:CellsBasis.cell, rs:CellsBasis.cell, defs:C.cellset, uses:C.cellset,
        cutsTo:Label.label list, mem:Region.region, nop:bool}
   | RET of {nop:bool}
   | BRANCH of {likely:likely, cond:cond, rs:CellsBasis.cell, rt:CellsBasis.cell,
        lab:Label.label, nop:bool}
   | FBRANCH of {likely:likely, fbranch:fbranch, cc:CellsBasis.cell, lab:Label.label,
        nop:bool}
   | ARITH of {oper:arith, rt:CellsBasis.cell, rs:CellsBasis.cell, i:operand}
   | UNARY of {oper:unary, rt:CellsBasis.cell, rs:CellsBasis.cell}
   | MULTIPLY of {oper:multiply, rt:CellsBasis.cell, rs:CellsBasis.cell}
   | DIVIDE of {oper:divide, rt:CellsBasis.cell, rs:CellsBasis.cell}
   | MFLO of CellsBasis.cell
   | MTLO of CellsBasis.cell
   | MFHI of CellsBasis.cell
   | MTHI of CellsBasis.cell
   | BREAK of int
   | FARITH of {oper:farith, ft:CellsBasis.cell, fs1:CellsBasis.cell, fs2:CellsBasis.cell}
   | FUNARY of {oper:funary, ft:CellsBasis.cell, fs:CellsBasis.cell}
   | FARITH3 of {oper:farith3, ft:CellsBasis.cell, fs1:CellsBasis.cell, fs2:CellsBasis.cell,
        fs3:CellsBasis.cell}
   | FROUND of {oper:fround, ft:CellsBasis.cell, fs1:CellsBasis.cell, rs2:CellsBasis.cell}
   | CVTI2F of {cvt:cvti2f, rs:CellsBasis.cell, ft:CellsBasis.cell}
   | CVTF2I of {cvt:cvtf2i, fs:CellsBasis.cell, rt:CellsBasis.cell}
   | COPY of {dst:(CellsBasis.cell) list, src:(CellsBasis.cell) list, impl:instruction list option ref,
        tmp:ea option}
   | FCOPY of {dst:(CellsBasis.cell) list, src:(CellsBasis.cell) list, impl:instruction list option ref,
        tmp:ea option}
   | ANNOTATION of {i:instruction, a:Annotations.annotation}
   | PHI of {}
   | SOURCE of {}
   | SINK of {}
   and instruction =
     LIVE of {regs: C.cellset, spilled: C.cellset}
   | KILL of {regs: C.cellset, spilled: C.cellset}
   | COPY of {k: CellsBasis.cellkind,
              sz: int,          (* in bits *)
              dst: CellsBasis.cell list,
              src: CellsBasis.cell list,
              tmp: ea option (* NONE if |dst| = {src| = 1 *)}
   | ANNOTATION of {i:instruction, a:Annotations.annotation}
   | INSTR of instr
   val nop : instruction
   val lui : {rt:CellsBasis.cell, imm:operand} -> instruction
   val la : {rt:CellsBasis.cell, b:CellsBasis.cell, d:operand} -> instruction
   val dla : {rt:CellsBasis.cell, b:CellsBasis.cell, d:operand} -> instruction
   val load : {l:load, rt:CellsBasis.cell, b:CellsBasis.cell, d:operand, mem:Region.region} -> instruction
   val store : {s:store, rs:CellsBasis.cell, b:CellsBasis.cell, d:operand,
      mem:Region.region} -> instruction
   val fload : {l:fload, ft:CellsBasis.cell, b:CellsBasis.cell, d:operand,
      mem:Region.region} -> instruction
   val fstore : {s:fstore, fs:CellsBasis.cell, b:CellsBasis.cell, d:operand,
      mem:Region.region} -> instruction
   val fcmp : {fcond:fcond, fmt:fmt, cc:CellsBasis.cell, fs1:CellsBasis.cell,
      fs2:CellsBasis.cell} -> instruction
   val trap : {t:trap, rs:CellsBasis.cell, i:operand} -> instruction
   val j : {lab:Label.label, nop:bool} -> instruction
   val jr : {rs:CellsBasis.cell, labels:Label.label list, nop:bool} -> instruction
   val jal : {lab:Label.label, defs:C.cellset, uses:C.cellset, cutsTo:Label.label list,
      mem:Region.region, nop:bool} -> instruction
   val jalr : {rt:CellsBasis.cell, rs:CellsBasis.cell, defs:C.cellset, uses:C.cellset,
      cutsTo:Label.label list, mem:Region.region, nop:bool} -> instruction
   val ret : {nop:bool} -> instruction
   val branch : {likely:likely, cond:cond, rs:CellsBasis.cell, rt:CellsBasis.cell,
      lab:Label.label, nop:bool} -> instruction
   val fbranch : {likely:likely, fbranch:fbranch, cc:CellsBasis.cell, lab:Label.label,
      nop:bool} -> instruction
   val arith : {oper:arith, rt:CellsBasis.cell, rs:CellsBasis.cell, i:operand} -> instruction
   val unary : {oper:unary, rt:CellsBasis.cell, rs:CellsBasis.cell} -> instruction
   val multiply : {oper:multiply, rt:CellsBasis.cell, rs:CellsBasis.cell} -> instruction
   val divide : {oper:divide, rt:CellsBasis.cell, rs:CellsBasis.cell} -> instruction
   val mflo : CellsBasis.cell -> instruction
   val mtlo : CellsBasis.cell -> instruction
   val mfhi : CellsBasis.cell -> instruction
   val mthi : CellsBasis.cell -> instruction
   val break : int -> instruction
   val farith : {oper:farith, ft:CellsBasis.cell, fs1:CellsBasis.cell, fs2:CellsBasis.cell} -> instruction
   val funary : {oper:funary, ft:CellsBasis.cell, fs:CellsBasis.cell} -> instruction
   val farith3 : {oper:farith3, ft:CellsBasis.cell, fs1:CellsBasis.cell, fs2:CellsBasis.cell,
      fs3:CellsBasis.cell} -> instruction
   val fround : {oper:fround, ft:CellsBasis.cell, fs1:CellsBasis.cell, rs2:CellsBasis.cell} -> instruction
   val cvti2f : {cvt:cvti2f, rs:CellsBasis.cell, ft:CellsBasis.cell} -> instruction
   val cvtf2i : {cvt:cvtf2i, fs:CellsBasis.cell, rt:CellsBasis.cell} -> instruction
   val copy : {dst:(CellsBasis.cell) list, src:(CellsBasis.cell) list, impl:instruction list option ref,
      tmp:ea option} -> instruction
   val fcopy : {dst:(CellsBasis.cell) list, src:(CellsBasis.cell) list, impl:instruction list option ref,
      tmp:ea option} -> instruction
   val annotation : {i:instruction, a:Annotations.annotation} -> instruction
   val phi : {} -> instruction
   val source : {} -> instruction
   val sink : {} -> instruction
end

functor MIPSInstr(T: MLTREE
                 ) : MIPSINSTR =
struct
   structure C = MIPSCells
   structure CB = CellsBasis
   structure T = T
   structure Region = T.Region
   structure Constant = T.Constant
   datatype load =
     LD
   | LW
   | LH
   | LHU
   | LB
   | LBU
   | LWL
   | LWR
   | LWU
   | LDL
   | LDR
   | ULH
   | ULHU
   | ULW
   | ULD
   datatype store =
     SD
   | SW
   | SH
   | SB
   | SWL
   | SWR
   | SDL
   | SDR
   | USH
   | USW
   | USD
   datatype fload =
     LDC1
   | LWC1
   datatype fstore =
     SDC1
   | SWC1
   datatype fcond =
     FF
   | FUN
   | FEQ
   | FUEQ
   | FOLT
   | FULT
   | FOLE
   | FULE
   | FNGLE
   | FSP
   | FNGL
   | FSEQ
   | FLT
   | FNGE
   | FLE
   | FNGT
   datatype cond =
     EQ
   | NE
   | LEZ
   | GTZ
   | LTZ
   | GEZ
   datatype fbranch =
     BC1T
   | BC1F
   datatype likely =
     LIKELY
   | UNLIKELY
   datatype arith =
     ADD
   | ADDU
   | AND
   | XOR
   | MUL
   | MULO
   | MULOU
   | NOR
   | OR
   | SEQ
   | SGT
   | SGE
   | SGEU
   | SGTU
   | SLT
   | SLE
   | SLEU
   | SLTU
   | SNE
   | SUB
   | SUBU
   | REM
   | REMU
   | SRA
   | SLL
   | SRL
   | ROR
   | ROL
   | MOVN
   | MOVZ
   | DADD
   | DADDU
   | DMUL
   | DMULO
   | DMULOU
   | DSUB
   | DSUBU
   | DREM
   | DREMU
   | DROL
   | DROR
   | DSLL
   | DSLL32
   | DSLLV
   | DSRA
   | DSRA32
   | DSRAV
   | DSRL
   | DSRL32
   | DSRLV
   datatype unary =
     ABS
   | NEG
   | NEGU
   | NOT
   | DABS
   | DNEG
   | DNEGU
   datatype multiply =
     MULT
   | MULTU
   | DMULT
   | DMULTU
   datatype divide =
     DIV
   | DIVU
   | DDIV
   | DDIVU
   datatype trap =
     TEQ
   | TNE
   | TLT
   | TLTU
   | TGE
   | TGEU
   datatype farith =
     ADD_D
   | ADD_S
   | SUB_D
   | SUB_S
   | MUL_D
   | MUL_S
   | DIV_D
   | DIV_S
   datatype funary =
     MOV_D
   | MOV_S
   | ABS_D
   | ABS_S
   | NEG_D
   | NEG_S
   | SQRT_D
   | SQRT_S
   | CVT_SD
   | CVT_SW
   | CVT_DS
   | CVT_DW
   | CVT_WS
   | CVT_WD
   | CVT_SL
   | CVT_DL
   | CVT_LS
   | CVT_LD
   datatype cvti2f =
     MTC1
   | DMTC1
   datatype cvtf2i =
     MFC1
   | DMFC1
   datatype farith3 =
     MADD_D
   | MADD_S
   | NMADD_D
   | NMADD_S
   | MSUB_D
   | MSUB_S
   | NMSUB_D
   | NMSUB_S
   datatype fround =
     TRUNC_WS
   | TRUNC_WD
   | ROUND_WS
   | ROUND_WD
   | CEIL_WD
   | CEIL_WS
   | CEILU_WD
   | CEILU_WS
   | FLOOR_WD
   | FLOOR_WS
   | FLOORU_WD
   | FLOORU_WS
   | ROUNDU_WD
   | ROUNDU_WS
   | TRUNCU_WD
   | TRUNCU_WS
   | TRUNC_LS
   | TRUNC_LD
   | ROUND_LS
   | ROUND_LD
   | CEIL_LS
   | CEIL_LD
   | FLOOR_LS
   | FLOOR_LD
   datatype fmt =
     SINGLE
   | DOUBLE
   datatype operand =
     Imm of int
   | Reg of CellsBasis.cell
   | Lab of T.labexp
   | HiLab of T.labexp
   | LoLab of T.labexp
   datatype ea =
     Direct of CellsBasis.cell
   | FDirect of CellsBasis.cell
   | Displace of {base:CellsBasis.cell, disp:int}
   type addressing_mode = C.cell * operand
   datatype instr =
     NOP
   | LUI of {rt:CellsBasis.cell, imm:operand}
   | LA of {rt:CellsBasis.cell, b:CellsBasis.cell, d:operand}
   | DLA of {rt:CellsBasis.cell, b:CellsBasis.cell, d:operand}
   | LOAD of {l:load, rt:CellsBasis.cell, b:CellsBasis.cell, d:operand, mem:Region.region}
   | STORE of {s:store, rs:CellsBasis.cell, b:CellsBasis.cell, d:operand, mem:Region.region}
   | FLOAD of {l:fload, ft:CellsBasis.cell, b:CellsBasis.cell, d:operand, mem:Region.region}
   | FSTORE of {s:fstore, fs:CellsBasis.cell, b:CellsBasis.cell, d:operand,
        mem:Region.region}
   | FCMP of {fcond:fcond, fmt:fmt, cc:CellsBasis.cell, fs1:CellsBasis.cell,
        fs2:CellsBasis.cell}
   | TRAP of {t:trap, rs:CellsBasis.cell, i:operand}
   | J of {lab:Label.label, nop:bool}
   | JR of {rs:CellsBasis.cell, labels:Label.label list, nop:bool}
   | JAL of {lab:Label.label, defs:C.cellset, uses:C.cellset, cutsTo:Label.label list,
        mem:Region.region, nop:bool}
   | JALR of {rt:CellsBasis.cell, rs:CellsBasis.cell, defs:C.cellset, uses:C.cellset,
        cutsTo:Label.label list, mem:Region.region, nop:bool}
   | RET of {nop:bool}
   | BRANCH of {likely:likely, cond:cond, rs:CellsBasis.cell, rt:CellsBasis.cell,
        lab:Label.label, nop:bool}
   | FBRANCH of {likely:likely, fbranch:fbranch, cc:CellsBasis.cell, lab:Label.label,
        nop:bool}
   | ARITH of {oper:arith, rt:CellsBasis.cell, rs:CellsBasis.cell, i:operand}
   | UNARY of {oper:unary, rt:CellsBasis.cell, rs:CellsBasis.cell}
   | MULTIPLY of {oper:multiply, rt:CellsBasis.cell, rs:CellsBasis.cell}
   | DIVIDE of {oper:divide, rt:CellsBasis.cell, rs:CellsBasis.cell}
   | MFLO of CellsBasis.cell
   | MTLO of CellsBasis.cell
   | MFHI of CellsBasis.cell
   | MTHI of CellsBasis.cell
   | BREAK of int
   | FARITH of {oper:farith, ft:CellsBasis.cell, fs1:CellsBasis.cell, fs2:CellsBasis.cell}
   | FUNARY of {oper:funary, ft:CellsBasis.cell, fs:CellsBasis.cell}
   | FARITH3 of {oper:farith3, ft:CellsBasis.cell, fs1:CellsBasis.cell, fs2:CellsBasis.cell,
        fs3:CellsBasis.cell}
   | FROUND of {oper:fround, ft:CellsBasis.cell, fs1:CellsBasis.cell, rs2:CellsBasis.cell}
   | CVTI2F of {cvt:cvti2f, rs:CellsBasis.cell, ft:CellsBasis.cell}
   | CVTF2I of {cvt:cvtf2i, fs:CellsBasis.cell, rt:CellsBasis.cell}
   | COPY of {dst:(CellsBasis.cell) list, src:(CellsBasis.cell) list, impl:instruction list option ref,
        tmp:ea option}
   | FCOPY of {dst:(CellsBasis.cell) list, src:(CellsBasis.cell) list, impl:instruction list option ref,
        tmp:ea option}
   | ANNOTATION of {i:instruction, a:Annotations.annotation}
   | PHI of {}
   | SOURCE of {}
   | SINK of {}
   and instruction =
     LIVE of {regs: C.cellset, spilled: C.cellset}
   | KILL of {regs: C.cellset, spilled: C.cellset}
   | COPY of {k: CellsBasis.cellkind,
              sz: int,          (* in bits *)
              dst: CellsBasis.cell list,
              src: CellsBasis.cell list,
              tmp: ea option (* NONE if |dst| = {src| = 1 *)}
   | ANNOTATION of {i:instruction, a:Annotations.annotation}
   | INSTR of instr
   val nop = INSTR NOP
   and lui = INSTR o LUI
   and la = INSTR o LA
   and dla = INSTR o DLA
   and load = INSTR o LOAD
   and store = INSTR o STORE
   and fload = INSTR o FLOAD
   and fstore = INSTR o FSTORE
   and fcmp = INSTR o FCMP
   and trap = INSTR o TRAP
   and j = INSTR o J
   and jr = INSTR o JR
   and jal = INSTR o JAL
   and jalr = INSTR o JALR
   and ret = INSTR o RET
   and branch = INSTR o BRANCH
   and fbranch = INSTR o FBRANCH
   and arith = INSTR o ARITH
   and unary = INSTR o UNARY
   and multiply = INSTR o MULTIPLY
   and divide = INSTR o DIVIDE
   and mflo = INSTR o MFLO
   and mtlo = INSTR o MTLO
   and mfhi = INSTR o MFHI
   and mthi = INSTR o MTHI
   and break = INSTR o BREAK
   and farith = INSTR o FARITH
   and funary = INSTR o FUNARY
   and farith3 = INSTR o FARITH3
   and fround = INSTR o FROUND
   and cvti2f = INSTR o CVTI2F
   and cvtf2i = INSTR o CVTF2I
   and copy = INSTR o COPY
   and fcopy = INSTR o FCOPY
   and annotation = INSTR o ANNOTATION
   and phi = INSTR o PHI
   and source = INSTR o SOURCE
   and sink = INSTR o SINK
end

